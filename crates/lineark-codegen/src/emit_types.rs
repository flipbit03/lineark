use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{self, GqlType, ObjectDef, TypeKind};
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::HashMap;

pub fn emit(objects: &[ObjectDef], type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let structs: Vec<TokenStream> = objects
        .iter()
        .filter(|o| !o.name.is_empty())
        .map(|o| emit_struct(o, type_kind_map))
        .collect();

    quote! {
        //! GraphQL object types.
        //!
        //! Generated by lineark-codegen â€” do not edit.

        use serde::{Deserialize, Serialize};
        use super::enums::*;

        #(#structs)*
    }
}

fn emit_struct(obj: &ObjectDef, type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let name = quote::format_ident!("{}", obj.name);
    let doc = parser::doc_comment_tokens(&obj.description);

    let fields: Vec<TokenStream> = obj
        .fields
        .iter()
        .filter(|f| !f.name.is_empty() && is_scalar_or_enum_field(&f.ty, type_kind_map))
        .map(|f| {
            let field_name_str = f.name.to_snake_case();
            let safe_name = parser::safe_ident(&field_name_str);
            let field_ident = if safe_name.starts_with("r#") {
                // For raw identifiers, we need to use syn to parse them.
                let raw: TokenStream = safe_name.parse().unwrap();
                raw
            } else {
                let ident = quote::format_ident!("{}", safe_name);
                quote! { #ident }
            };
            let rust_type = resolve_type(&f.ty);
            let fdoc = parser::doc_comment_tokens(&f.description);
            quote! {
                #fdoc
                pub #field_ident: #rust_type,
            }
        })
        .collect();

    quote! {
        #doc
        #[derive(Debug, Clone, Default, Serialize, Deserialize)]
        #[serde(rename_all = "camelCase", default)]
        pub struct #name {
            #(#fields)*
        }
    }
}

/// Check if a field's base type is a scalar or enum (i.e., should be included in the struct).
fn is_scalar_or_enum_field(ty: &GqlType, type_kind_map: &HashMap<String, TypeKind>) -> bool {
    let base = ty.base_name();
    matches!(
        type_kind_map.get(base),
        Some(TypeKind::Scalar) | Some(TypeKind::Enum)
    )
}

/// Resolve a GraphQL type to its Rust type tokens.
/// All output type fields are wrapped in `Option<T>`.
fn resolve_type(ty: &GqlType) -> TokenStream {
    let inner = resolve_inner_type(ty);
    // Always wrap output type fields in Option since we do partial field selection.
    quote! { Option<#inner> }
}

/// Resolve the inner type (without the outer Option wrapper).
fn resolve_inner_type(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::Named(name) => graphql_type_to_rust(name),
        GqlType::NonNull(inner) => resolve_inner_type(inner),
        GqlType::List(inner) => {
            let elem = resolve_inner_type(inner);
            quote! { Vec<#elem> }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::FieldDef;

    fn make_type_kind_map() -> HashMap<String, TypeKind> {
        let mut map = HashMap::new();
        map.insert("String".to_string(), TypeKind::Scalar);
        map.insert("Int".to_string(), TypeKind::Scalar);
        map.insert("Float".to_string(), TypeKind::Scalar);
        map.insert("Boolean".to_string(), TypeKind::Scalar);
        map.insert("ID".to_string(), TypeKind::Scalar);
        map.insert("DateTime".to_string(), TypeKind::Scalar);
        map.insert("Status".to_string(), TypeKind::Enum);
        map.insert("Team".to_string(), TypeKind::Object);
        map
    }

    #[test]
    fn emit_struct_with_scalar_fields() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "User".to_string(),
            description: None,
            fields: vec![
                FieldDef {
                    name: "id".to_string(),
                    description: None,
                    ty: GqlType::NonNull(Box::new(GqlType::Named("ID".to_string()))),
                    arguments: vec![],
                },
                FieldDef {
                    name: "name".to_string(),
                    description: None,
                    ty: GqlType::NonNull(Box::new(GqlType::Named("String".to_string()))),
                    arguments: vec![],
                },
                FieldDef {
                    name: "active".to_string(),
                    description: None,
                    ty: GqlType::Named("Boolean".to_string()),
                    arguments: vec![],
                },
            ],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        assert!(output.contains("pub struct User"));
        assert!(output.contains("pub id"));
        assert!(output.contains("pub name"));
        assert!(output.contains("pub active"));
        assert!(output.contains("Option"));
    }

    #[test]
    fn emit_filters_out_object_fields() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "Issue".to_string(),
            description: None,
            fields: vec![
                FieldDef {
                    name: "id".to_string(),
                    description: None,
                    ty: GqlType::NonNull(Box::new(GqlType::Named("ID".to_string()))),
                    arguments: vec![],
                },
                FieldDef {
                    name: "team".to_string(),
                    description: None,
                    ty: GqlType::Named("Team".to_string()),
                    arguments: vec![],
                },
            ],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        assert!(output.contains("pub id"));
        // "team" field should be filtered out (Team is an Object, not Scalar/Enum)
        assert!(!output.contains("pub team"));
    }

    #[test]
    fn emit_includes_enum_fields() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "Issue".to_string(),
            description: None,
            fields: vec![FieldDef {
                name: "status".to_string(),
                description: None,
                ty: GqlType::Named("Status".to_string()),
                arguments: vec![],
            }],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        assert!(output.contains("pub status"));
    }

    #[test]
    fn emit_uses_camel_case_serde() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "User".to_string(),
            description: None,
            fields: vec![FieldDef {
                name: "createdAt".to_string(),
                description: None,
                ty: GqlType::Named("DateTime".to_string()),
                arguments: vec![],
            }],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        assert!(output.contains("rename_all = \"camelCase\""));
        // Field name should be snake_case in Rust
        assert!(output.contains("created_at"));
    }

    #[test]
    fn emit_generated_code_parses() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "Team".to_string(),
            description: None,
            fields: vec![
                FieldDef {
                    name: "id".to_string(),
                    description: None,
                    ty: GqlType::NonNull(Box::new(GqlType::Named("ID".to_string()))),
                    arguments: vec![],
                },
                FieldDef {
                    name: "name".to_string(),
                    description: None,
                    ty: GqlType::Named("String".to_string()),
                    arguments: vec![],
                },
            ],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        syn::parse_file(&output).expect("Generated type code should be valid Rust");
    }

    #[test]
    fn emit_skips_empty_object_names() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "".to_string(),
            description: None,
            fields: vec![],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        assert!(!output.contains("pub struct"));
    }

    #[test]
    fn emit_handles_list_fields() {
        let type_kind_map = make_type_kind_map();
        let objects = vec![ObjectDef {
            name: "User".to_string(),
            description: None,
            fields: vec![FieldDef {
                name: "labelIds".to_string(),
                description: None,
                ty: GqlType::List(Box::new(GqlType::NonNull(Box::new(GqlType::Named(
                    "String".to_string(),
                ))))),
                arguments: vec![],
            }],
        }];
        let output = emit(&objects, &type_kind_map).to_string();
        assert!(output.contains("Vec"));
        assert!(output.contains("label_ids"));
    }
}
