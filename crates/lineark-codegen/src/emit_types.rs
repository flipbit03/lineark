use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{self, GqlType, ObjectDef, TypeKind};
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::HashMap;

pub fn emit(objects: &[ObjectDef], type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let structs: Vec<TokenStream> = objects
        .iter()
        .filter(|o| !o.name.is_empty())
        .map(|o| emit_struct(o, type_kind_map))
        .collect();

    quote! {
        //! GraphQL object types.
        //!
        //! Generated by lineark-codegen â€” do not edit.

        use serde::{Deserialize, Serialize};
        use super::enums::*;

        #(#structs)*
    }
}

fn emit_struct(obj: &ObjectDef, type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let name = quote::format_ident!("{}", obj.name);

    let fields: Vec<TokenStream> = obj
        .fields
        .iter()
        .filter(|f| !f.name.is_empty() && is_scalar_or_enum_field(&f.ty, type_kind_map))
        .map(|f| {
            let field_name_str = f.name.to_snake_case();
            let safe_name = parser::safe_ident(&field_name_str);
            let field_ident = if safe_name.starts_with("r#") {
                // For raw identifiers, we need to use syn to parse them.
                let raw: TokenStream = safe_name.parse().unwrap();
                raw
            } else {
                let ident = quote::format_ident!("{}", safe_name);
                quote! { #ident }
            };
            let rust_type = resolve_type(&f.ty);
            quote! {
                pub #field_ident: #rust_type,
            }
        })
        .collect();

    quote! {
        #[derive(Debug, Clone, Default, Serialize, Deserialize)]
        #[serde(rename_all = "camelCase", default)]
        pub struct #name {
            #(#fields)*
        }
    }
}

/// Check if a field's base type is a scalar or enum (i.e., should be included in the struct).
fn is_scalar_or_enum_field(ty: &GqlType, type_kind_map: &HashMap<String, TypeKind>) -> bool {
    let base = ty.base_name();
    matches!(
        type_kind_map.get(base),
        Some(TypeKind::Scalar) | Some(TypeKind::Enum)
    )
}

/// Resolve a GraphQL type to its Rust type tokens.
/// All output type fields are wrapped in Option<T>.
fn resolve_type(ty: &GqlType) -> TokenStream {
    let inner = resolve_inner_type(ty);
    // Always wrap output type fields in Option since we do partial field selection.
    quote! { Option<#inner> }
}

/// Resolve the inner type (without the outer Option wrapper).
fn resolve_inner_type(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::Named(name) => graphql_type_to_rust(name),
        GqlType::NonNull(inner) => resolve_inner_type(inner),
        GqlType::List(inner) => {
            let elem = resolve_inner_type(inner);
            quote! { Vec<#elem> }
        }
    }
}
