mod emit_enums;
mod emit_inputs;
mod emit_mutations;
mod emit_queries;
mod emit_scalars;
mod emit_types;
mod fetch_schema;
mod parser;

use std::collections::{HashMap, HashSet};
use std::path::Path;

fn main() {
    let fetch = std::env::args().any(|a| a == "--fetch");

    let workspace_root = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap();

    let schema_path = workspace_root.join("schema/schema.graphql");
    let operations_path = workspace_root.join("schema/operations.toml");
    let generated_dir = workspace_root.join("crates/lineark-sdk/src/generated");

    // Optionally fetch the latest schema from Linear's introspection endpoint.
    if fetch {
        let sdl = fetch_schema::fetch_and_convert()
            .unwrap_or_else(|e| panic!("Failed to fetch schema: {}", e));
        std::fs::write(&schema_path, &sdl)
            .unwrap_or_else(|e| panic!("Failed to write {}: {}", schema_path.display(), e));
        println!("Schema written to {}", schema_path.display());
    }

    println!("Reading schema from {}", schema_path.display());
    let schema_text = std::fs::read_to_string(&schema_path).expect("Failed to read schema file");

    println!("Parsing schema...");
    let schema = parser::parse(&schema_text);
    println!(
        "  {} scalars, {} enums, {} objects, {} inputs, {} query fields, {} mutation fields",
        schema.scalars.len(),
        schema.enums.len(),
        schema.objects.len(),
        schema.inputs.len(),
        schema.query_fields.len(),
        schema.mutation_fields.len(),
    );

    // Read operations allowlist.
    println!("Reading operations from {}", operations_path.display());
    let operations_text =
        std::fs::read_to_string(&operations_path).expect("Failed to read operations.toml");
    let operations: toml::Value = operations_text
        .parse()
        .expect("Failed to parse operations.toml");

    let (allowed_queries, query_renames) = parse_operations_section(&operations, "queries");
    let (allowed_mutations, mutation_renames) = parse_operations_section(&operations, "mutations");

    println!(
        "  {} allowed queries, {} allowed mutations",
        allowed_queries.len(),
        allowed_mutations.len()
    );

    // Generate code.
    std::fs::create_dir_all(&generated_dir).expect("Failed to create generated dir");

    // Scalars
    let scalars_tokens = emit_scalars::emit(&schema.scalars);
    write_formatted(&generated_dir.join("scalars.rs"), scalars_tokens);

    // Enums
    let enums_tokens = emit_enums::emit(&schema.enums);
    write_formatted(&generated_dir.join("enums.rs"), enums_tokens);

    // Types
    let types_tokens = emit_types::emit(&schema.objects, &schema.type_kind_map);
    write_formatted(&generated_dir.join("types.rs"), types_tokens);

    // Inputs
    let inputs_tokens = emit_inputs::emit(&schema.inputs, &schema.type_kind_map);
    write_formatted(&generated_dir.join("inputs.rs"), inputs_tokens);

    // Queries
    let queries_tokens = emit_queries::emit(
        &schema.query_fields,
        &allowed_queries,
        &query_renames,
        &schema.objects,
        &schema.type_kind_map,
    );
    write_formatted(&generated_dir.join("queries.rs"), queries_tokens);

    // Mutations
    let mutations_tokens = emit_mutations::emit(
        &schema.mutation_fields,
        &allowed_mutations,
        &mutation_renames,
        &schema.objects,
        &schema.type_kind_map,
    );
    write_formatted(&generated_dir.join("mutations.rs"), mutations_tokens);

    // mod.rs
    let mod_tokens = quote::quote! {
        //! Generated types and operations for the Linear GraphQL API.
        //!
        //! Generated by lineark-codegen â€” do not edit.

        pub mod enums;
        pub mod inputs;
        pub mod mutations;
        pub mod queries;
        pub mod scalars;
        pub mod types;
    };
    write_formatted(&generated_dir.join("mod.rs"), mod_tokens);

    // Run rustfmt on generated code to normalize prettyplease's output.
    let status = std::process::Command::new("cargo")
        .args(["fmt", "-p", "lineark-sdk"])
        .status();
    match status {
        Ok(s) if s.success() => {}
        Ok(s) => eprintln!("Warning: cargo fmt exited with {}", s),
        Err(e) => eprintln!("Warning: could not run cargo fmt: {}", e),
    }

    println!("Code generation complete.");
}

/// Parse an operations section from operations.toml.
///
/// Each entry can be either `name = true` (use default method name) or
/// `name = "rename"` (use a custom Rust method name).
fn parse_operations_section(
    operations: &toml::Value,
    section: &str,
) -> (HashSet<String>, HashMap<String, String>) {
    let mut allowed = HashSet::new();
    let mut renames = HashMap::new();

    if let Some(table) = operations.get(section).and_then(|s| s.as_table()) {
        for (key, value) in table {
            match value {
                toml::Value::Boolean(true) => {
                    allowed.insert(key.clone());
                }
                toml::Value::String(rename) => {
                    allowed.insert(key.clone());
                    renames.insert(key.clone(), rename.clone());
                }
                _ => {}
            }
        }
    }

    (allowed, renames)
}

fn write_formatted(path: &Path, tokens: proc_macro2::TokenStream) {
    let code = tokens.to_string();
    // Parse with syn and format with prettyplease.
    let formatted = match syn::parse_file(&code) {
        Ok(file) => prettyplease::unparse(&file),
        Err(e) => {
            eprintln!(
                "Warning: could not parse generated code for {}: {}",
                path.display(),
                e
            );
            eprintln!("Writing unformatted code.");
            code
        }
    };
    std::fs::write(path, formatted).unwrap_or_else(|e| {
        panic!("Failed to write {}: {}", path.display(), e);
    });
    println!("  Wrote {}", path.display());
}
