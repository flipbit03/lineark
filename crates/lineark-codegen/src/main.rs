mod emit_enums;
mod emit_inputs;
mod emit_mutations;
mod emit_queries;
mod emit_scalars;
mod emit_types;
mod fetch_schema;
mod parser;

use std::collections::{HashMap, HashSet};
use std::path::Path;

fn main() {
    let fetch = std::env::args().any(|a| a == "--fetch");

    let workspace_root = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap();

    let schema_path = workspace_root.join("schema/schema.graphql");
    let operations_path = workspace_root.join("schema/operations.toml");
    let generated_dir = workspace_root.join("crates/lineark-sdk/src/generated");

    // Optionally fetch the latest schema from Linear's introspection endpoint.
    if fetch {
        let sdl = fetch_schema::fetch_and_convert()
            .unwrap_or_else(|e| panic!("Failed to fetch schema: {}", e));
        std::fs::write(&schema_path, &sdl)
            .unwrap_or_else(|e| panic!("Failed to write {}: {}", schema_path.display(), e));
        println!("Schema written to {}", schema_path.display());
    }

    println!("Reading schema from {}", schema_path.display());
    let schema_text = std::fs::read_to_string(&schema_path).expect("Failed to read schema file");

    println!("Parsing schema...");
    let schema = parser::parse(&schema_text);
    println!(
        "  {} scalars, {} enums, {} objects, {} inputs, {} query fields, {} mutation fields",
        schema.scalars.len(),
        schema.enums.len(),
        schema.objects.len(),
        schema.inputs.len(),
        schema.query_fields.len(),
        schema.mutation_fields.len(),
    );

    // Read operations allowlist.
    println!("Reading operations from {}", operations_path.display());
    let operations_text =
        std::fs::read_to_string(&operations_path).expect("Failed to read operations.toml");
    let operations: toml::Value = operations_text
        .parse()
        .expect("Failed to parse operations.toml");

    let (allowed_queries, query_configs) = parse_operations_section(&operations, "queries");
    let (allowed_mutations, mutation_configs) = parse_operations_section(&operations, "mutations");

    println!(
        "  {} allowed queries, {} allowed mutations",
        allowed_queries.len(),
        allowed_mutations.len()
    );

    // Generate code.
    std::fs::create_dir_all(&generated_dir).expect("Failed to create generated dir");

    // Scalars
    let scalars_tokens = emit_scalars::emit(&schema.scalars);
    write_formatted(&generated_dir.join("scalars.rs"), scalars_tokens);

    // Enums
    let enums_tokens = emit_enums::emit(&schema.enums);
    write_formatted(&generated_dir.join("enums.rs"), enums_tokens);

    // Types
    let types_tokens = emit_types::emit(&schema.objects, &schema.type_kind_map);
    write_formatted(&generated_dir.join("types.rs"), types_tokens);

    // Inputs
    let inputs_tokens = emit_inputs::emit(&schema.inputs, &schema.type_kind_map);
    write_formatted(&generated_dir.join("inputs.rs"), inputs_tokens);

    // Queries (returns queries module + client impl)
    let query_renames: HashMap<String, String> = query_configs
        .iter()
        .filter_map(|(k, c)| c.rename.as_ref().map(|r| (k.clone(), r.clone())))
        .collect();
    let query_result = emit_queries::emit(
        &schema.query_fields,
        &allowed_queries,
        &query_renames,
        &schema.objects,
        &schema.type_kind_map,
    );
    write_formatted(
        &generated_dir.join("queries.rs"),
        query_result.queries_tokens,
    );

    // Mutations (returns mutations module + client impl)
    let mutation_renames: HashMap<String, String> = mutation_configs
        .iter()
        .filter_map(|(k, c)| c.rename.as_ref().map(|r| (k.clone(), r.clone())))
        .collect();
    let mutation_result = emit_mutations::emit(
        &schema.mutation_fields,
        &allowed_mutations,
        &mutation_renames,
        &schema.objects,
        &schema.type_kind_map,
    );
    write_formatted(
        &generated_dir.join("mutations.rs"),
        mutation_result.mutations_tokens,
    );

    // Client impl — combines query + mutation delegation into one file.
    let query_client_impl = query_result.client_impl_tokens;
    let mutation_client_impl = mutation_result.client_impl_tokens;
    let client_impl_tokens = quote::quote! {
        //! Generated `impl Client` delegation methods.
        //!
        //! This module provides thin wrapper methods on [`Client`] that
        //! delegate to the standalone functions in [`queries`](super::queries) and
        //! [`mutations`](super::mutations).
        //!
        //! Generated by lineark-codegen — do not edit.

        #![allow(clippy::too_many_arguments)]

        use crate::client::Client;
        use crate::error::LinearError;
        use crate::field_selection::GraphQLFields;
        use serde::de::DeserializeOwned;
        use super::queries::*;
        use super::inputs::*;

        impl Client {
            #query_client_impl
            #mutation_client_impl
        }
    };
    write_formatted(&generated_dir.join("client_impl.rs"), client_impl_tokens);

    // mod.rs
    let mod_tokens = quote::quote! {
        //! Generated types and operations for the Linear GraphQL API.
        //!
        //! Generated by lineark-codegen — do not edit.

        pub mod enums;
        pub mod inputs;
        pub mod mutations;
        pub mod queries;
        pub mod scalars;
        pub mod types;
        mod client_impl;
    };
    write_formatted(&generated_dir.join("mod.rs"), mod_tokens);

    // Run rustfmt on generated code to normalize prettyplease's output.
    let status = std::process::Command::new("cargo")
        .args(["fmt", "-p", "lineark-sdk"])
        .status();
    match status {
        Ok(s) if s.success() => {}
        Ok(s) => eprintln!("Warning: cargo fmt exited with {}", s),
        Err(e) => eprintln!("Warning: could not run cargo fmt: {}", e),
    }

    println!("Code generation complete.");
}

/// Per-operation configuration parsed from operations.toml.
#[derive(Debug, Clone)]
struct OperationConfig {
    rename: Option<String>,
}

/// Parse an operations section from operations.toml.
///
/// Each entry can be:
/// - `name = true` — use default method name
/// - `name = "rename"` — use a custom Rust method name
/// - `name = { rename = "..." }` — table config with rename
fn parse_operations_section(
    operations: &toml::Value,
    section: &str,
) -> (HashSet<String>, HashMap<String, OperationConfig>) {
    let mut allowed = HashSet::new();
    let mut configs = HashMap::new();

    if let Some(table) = operations.get(section).and_then(|s| s.as_table()) {
        for (key, value) in table {
            match value {
                toml::Value::Boolean(true) => {
                    allowed.insert(key.clone());
                }
                toml::Value::String(rename) => {
                    allowed.insert(key.clone());
                    configs.insert(
                        key.clone(),
                        OperationConfig {
                            rename: Some(rename.clone()),
                        },
                    );
                }
                toml::Value::Table(t) => {
                    allowed.insert(key.clone());
                    let rename = t.get("rename").and_then(|v| v.as_str()).map(String::from);
                    configs.insert(key.clone(), OperationConfig { rename });
                }
                _ => {}
            }
        }
    }

    (allowed, configs)
}

fn write_formatted(path: &Path, tokens: proc_macro2::TokenStream) {
    let code = tokens.to_string();
    // Parse with syn and format with prettyplease.
    let formatted = match syn::parse_file(&code) {
        Ok(file) => prettyplease::unparse(&file),
        Err(e) => {
            eprintln!(
                "Warning: could not parse generated code for {}: {}",
                path.display(),
                e
            );
            eprintln!("Writing unformatted code.");
            code
        }
    };
    std::fs::write(path, formatted).unwrap_or_else(|e| {
        panic!("Failed to write {}: {}", path.display(), e);
    });
    println!("  Wrote {}", path.display());
}
