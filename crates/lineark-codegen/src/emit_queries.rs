use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{self, ArgumentDef, FieldDef, GqlType, ObjectDef, TypeKind};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

pub fn emit(
    query_fields: &[FieldDef],
    allowed: &HashSet<String>,
    renames: &HashMap<String, String>,
    objects: &[ObjectDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let object_map: HashMap<&str, &ObjectDef> =
        objects.iter().map(|o| (o.name.as_str(), o)).collect();

    let mut builder_items: Vec<TokenStream> = Vec::new();
    let mut client_methods: Vec<TokenStream> = Vec::new();

    for field in query_fields.iter().filter(|f| allowed.contains(&f.name)) {
        let rename = renames.get(&field.name).map(|s| s.as_str());
        let (builders, method) = emit_query(field, rename, &object_map, type_kind_map);
        builder_items.extend(builders);
        client_methods.push(method);
    }

    quote! {
        //! Generated query methods on Client.
        //!
        //! Generated by lineark-codegen — do not edit.

        use crate::client::Client;
        use crate::error::LinearError;
        use crate::pagination::Connection;
        use super::types::*;

        #(#builder_items)*

        impl Client {
            #(#client_methods)*
        }
    }
}

// ── Argument classification ──────────────────────────────────────────────────

/// Parsed info for a single query argument (after filtering to simple scalars).
struct ArgInfo {
    param_name: proc_macro2::Ident,
    gql_name: String,
    rust_inner_type: TokenStream,
    gql_type_str: String,
    is_required: bool,
    is_string_type: bool,
}

fn classify_args(arguments: &[ArgumentDef]) -> Vec<ArgInfo> {
    arguments
        .iter()
        .filter_map(|arg| {
            let base = arg.ty.base_name();
            if !matches!(base, "String" | "Int" | "Float" | "Boolean" | "ID") {
                return None;
            }
            let is_required = matches!(arg.ty, GqlType::NonNull(_));
            Some(ArgInfo {
                param_name: quote::format_ident!("{}", arg.name.to_snake_case()),
                gql_name: arg.name.clone(),
                rust_inner_type: resolve_arg_inner(&arg.ty),
                gql_type_str: gql_type_string(&arg.ty),
                is_required,
                is_string_type: matches!(base, "String" | "ID"),
            })
        })
        .collect()
}

// ── Main dispatch ────────────────────────────────────────────────────────────

fn emit_query(
    field: &FieldDef,
    rename: Option<&str>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> (Vec<TokenStream>, TokenStream) {
    let args = classify_args(&field.arguments);
    let has_optional = args.iter().any(|a| !a.is_required);
    let return_type_name = field.ty.base_name();
    let is_connection =
        return_type_name.ends_with("Connection") || return_type_name.ends_with("Payload");

    if has_optional {
        emit_builder_query(
            field,
            rename,
            &args,
            is_connection,
            object_map,
            type_kind_map,
        )
    } else {
        let method = emit_direct_method(
            field,
            rename,
            &args,
            is_connection,
            object_map,
            type_kind_map,
        );
        (vec![], method)
    }
}

// ── Direct methods (no optional args) ────────────────────────────────────────

fn emit_direct_method(
    field: &FieldDef,
    rename: Option<&str>,
    args: &[ArgInfo],
    is_connection: bool,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let method_name =
        quote::format_ident!("{}", rename.unwrap_or(field.name.as_str()).to_snake_case());
    let return_type_name = field.ty.base_name();

    let params: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            quote! { #name: #ty }
        })
        .collect();

    let variables_json: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! { #gql_name: #param_name }
        })
        .collect();

    let (gql_args_str, gql_params_str) = build_gql_strings(args);
    let data_path = &field.name;

    let doc = parser::doc_comment_tokens(&field.description);

    if is_connection {
        let (node_type_name, node_type_ident) = connection_node_type(return_type_name);
        let field_selection = build_field_selection(node_type_name, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_connection_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );

        quote! {
            #doc
            pub async fn #method_name(&self, #(#params),*) -> Result<Connection<#node_type_ident>, LinearError> {
                let variables = serde_json::json!({ #(#variables_json),* });
                self.execute_connection::<#node_type_ident>(#query_string, variables, #data_path).await
            }
        }
    } else {
        let return_type_ident = quote::format_ident!("{}", return_type_name);
        let field_selection = build_field_selection(return_type_name, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_single_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );

        quote! {
            #doc
            pub async fn #method_name(&self, #(#params),*) -> Result<#return_type_ident, LinearError> {
                let variables = serde_json::json!({ #(#variables_json),* });
                self.execute::<#return_type_ident>(#query_string, variables, #data_path).await
            }
        }
    }
}

// ── Builder queries (has optional args) ──────────────────────────────────────

fn emit_builder_query(
    field: &FieldDef,
    rename: Option<&str>,
    args: &[ArgInfo],
    is_connection: bool,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> (Vec<TokenStream>, TokenStream) {
    let rust_name = rename.unwrap_or(field.name.as_str());
    let method_name = quote::format_ident!("{}", rust_name.to_snake_case());
    let builder_name = quote::format_ident!("{}QueryBuilder", rust_name.to_upper_camel_case());
    let return_type_name = field.ty.base_name();
    let doc = parser::doc_comment_tokens(&field.description);

    let required_args: Vec<&ArgInfo> = args.iter().filter(|a| a.is_required).collect();
    let optional_args: Vec<&ArgInfo> = args.iter().filter(|a| !a.is_required).collect();

    // ── Builder struct fields ──
    let struct_fields: Vec<TokenStream> = {
        let mut fields = vec![quote! { client: &'a Client }];
        for a in &required_args {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            fields.push(quote! { #name: #ty });
        }
        for a in &optional_args {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            fields.push(quote! { #name: Option<#ty> });
        }
        fields
    };

    // ── Setter methods for optional args ──
    let setters: Vec<TokenStream> = optional_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            if a.is_string_type {
                quote! {
                    pub fn #name(mut self, value: impl Into<#ty>) -> Self {
                        self.#name = Some(value.into());
                        self
                    }
                }
            } else {
                quote! {
                    pub fn #name(mut self, value: #ty) -> Self {
                        self.#name = Some(value);
                        self
                    }
                }
            }
        })
        .collect();

    // ── Variables JSON entries (reference self.field) ──
    let variables_json: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! { #gql_name: self.#param_name }
        })
        .collect();

    let (gql_args_str, gql_params_str) = build_gql_strings(args);
    let data_path = &field.name;

    // ── send() return type and body ──
    let (send_return_type, send_body) = if is_connection {
        let (node_type_name, node_type_ident) = connection_node_type(return_type_name);
        let field_selection = build_field_selection(node_type_name, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_connection_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );
        (
            quote! { Connection<#node_type_ident> },
            quote! {
                let variables = serde_json::json!({ #(#variables_json),* });
                self.client.execute_connection::<#node_type_ident>(#query_string, variables, #data_path).await
            },
        )
    } else {
        let return_type_ident = quote::format_ident!("{}", return_type_name);
        let field_selection = build_field_selection(return_type_name, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_single_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );
        (
            quote! { #return_type_ident },
            quote! {
                let variables = serde_json::json!({ #(#variables_json),* });
                self.client.execute::<#return_type_ident>(#query_string, variables, #data_path).await
            },
        )
    };

    // ── Builder struct + impl ──
    let builder_tokens = quote! {
        #[must_use]
        pub struct #builder_name<'a> {
            #(#struct_fields,)*
        }

        impl<'a> #builder_name<'a> {
            #(#setters)*

            pub async fn send(self) -> Result<#send_return_type, LinearError> {
                #send_body
            }
        }
    };

    // ── Client constructor method ──
    let constructor_params: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            if a.is_string_type {
                quote! { #name: impl Into<#ty> }
            } else {
                quote! { #name: #ty }
            }
        })
        .collect();

    let field_inits: Vec<TokenStream> = {
        let mut inits = vec![quote! { client: self }];
        for a in &required_args {
            let name = &a.param_name;
            if a.is_string_type {
                inits.push(quote! { #name: #name.into() });
            } else {
                inits.push(quote! { #name });
            }
        }
        for a in &optional_args {
            let name = &a.param_name;
            inits.push(quote! { #name: None });
        }
        inits
    };

    let client_method = quote! {
        #doc
        pub fn #method_name(&self, #(#constructor_params),*) -> #builder_name<'_> {
            #builder_name {
                #(#field_inits,)*
            }
        }
    };

    (vec![builder_tokens], client_method)
}

// ── Shared helpers ───────────────────────────────────────────────────────────

fn connection_node_type(connection_type_name: &str) -> (&str, proc_macro2::Ident) {
    let node_type_name = connection_type_name
        .strip_suffix("Connection")
        .or_else(|| connection_type_name.strip_suffix("SearchPayload"))
        .unwrap_or(connection_type_name);
    let node_type_ident = quote::format_ident!("{}", node_type_name);
    (node_type_name, node_type_ident)
}

fn build_gql_strings(args: &[ArgInfo]) -> (String, String) {
    let gql_args: Vec<String> = args
        .iter()
        .map(|a| format!("{}: ${}", a.gql_name, a.gql_name))
        .collect();
    let gql_params: Vec<String> = args
        .iter()
        .map(|a| format!("${}: {}", a.gql_name, a.gql_type_str))
        .collect();
    (gql_args.join(", "), gql_params.join(", "))
}

fn build_connection_query_string(
    query_name: &str,
    field_name: &str,
    field_selection: &str,
    gql_args: &str,
    gql_params: &str,
) -> String {
    if gql_params.is_empty() {
        format!(
            "query {} {{ {} {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            query_name, field_name, field_selection
        )
    } else {
        format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            query_name, gql_params, field_name, gql_args, field_selection
        )
    }
}

fn build_single_query_string(
    query_name: &str,
    field_name: &str,
    field_selection: &str,
    gql_args: &str,
    gql_params: &str,
) -> String {
    if gql_params.is_empty() {
        format!(
            "query {} {{ {} {{ {} }} }}",
            query_name, field_name, field_selection
        )
    } else {
        format!(
            "query {}({}) {{ {}({}) {{ {} }} }}",
            query_name, gql_params, field_name, gql_args, field_selection
        )
    }
}

/// Fields to exclude from query selection (noisy/internal, waste LLM context).
const EXCLUDED_FIELDS: &[&str] = &[
    "descriptionState", // Yjs CRDT binary blob, useless for display
    "featureFlags",     // exposed in introspection but not queryable
];

/// Build the scalar/enum field selection string for a type.
pub fn build_field_selection(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    obj.fields
        .iter()
        .filter(|f| {
            let base = f.ty.base_name();
            !EXCLUDED_FIELDS.contains(&f.name.as_str())
                && matches!(
                    type_kind_map.get(base),
                    Some(TypeKind::Scalar) | Some(TypeKind::Enum)
                )
        })
        .map(|f| f.name.clone())
        .collect::<Vec<_>>()
        .join(" ")
}

/// Convert GqlType back to a GraphQL type string (e.g., `String!`, `[String!]`).
pub fn gql_type_string(ty: &GqlType) -> String {
    match ty {
        GqlType::Named(name) => name.clone(),
        GqlType::NonNull(inner) => format!("{}!", gql_type_string(inner)),
        GqlType::List(inner) => format!("[{}]", gql_type_string(inner)),
    }
}

fn resolve_arg_inner(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::Named(name) => graphql_type_to_rust(name),
        GqlType::NonNull(inner) => resolve_arg_inner(inner),
        GqlType::List(inner) => {
            let elem = resolve_arg_inner(inner);
            quote! { Vec<#elem> }
        }
    }
}
