use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{self, ArgumentDef, FieldDef, GqlType, ObjectDef, TypeKind};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

/// Result of emitting all query code.
pub struct QueryEmitResult {
    /// Builder structs + standalone factory functions for `generated::queries`.
    pub queries_tokens: TokenStream,
    /// `impl Client` block for `generated/client_impl.rs`.
    pub client_impl_tokens: TokenStream,
}

/// Controls how deeply nested fields are selected in generated queries.
#[derive(Debug, Clone, Copy)]
pub enum FieldDepth {
    /// Scalars and enums only — no nested objects or connections.
    Flat,
    /// Scalars + one level of nested object refs (identifying fields). No connections.
    Nested,
    /// Everything: scalars, nested objects, and connections with node sub-fields.
    Detail,
}

pub fn emit(
    query_fields: &[FieldDef],
    allowed: &HashSet<String>,
    renames: &HashMap<String, String>,
    depths: &HashMap<String, FieldDepth>,
    objects: &[ObjectDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> QueryEmitResult {
    let object_map: HashMap<&str, &ObjectDef> =
        objects.iter().map(|o| (o.name.as_str(), o)).collect();

    let mut builder_items: Vec<TokenStream> = Vec::new();
    let mut standalone_fns: Vec<TokenStream> = Vec::new();
    let mut client_methods: Vec<TokenStream> = Vec::new();

    for field in query_fields.iter().filter(|f| allowed.contains(&f.name)) {
        let rename = renames.get(&field.name).map(|s| s.as_str());
        let depth = depths.get(&field.name).copied();
        let result = emit_query(field, rename, depth, &object_map, type_kind_map);
        builder_items.extend(result.builders);
        standalone_fns.extend(result.standalone_fns);
        client_methods.push(result.client_method);
    }

    let queries_tokens = quote! {
        //! Generated query functions and builder types.
        //!
        //! Each query is exposed as a standalone factory function that returns
        //! a builder (for queries with optional parameters) or directly executes
        //! the query. The [`Client`] re-exports these as methods
        //! for convenience.
        //!
        //! Generated by lineark-codegen — do not edit.

        use crate::client::Client;
        use crate::error::LinearError;
        use crate::pagination::Connection;
        use super::types::*;
        use super::enums::*;
        use super::inputs::*;

        #(#builder_items)*

        #(#standalone_fns)*
    };

    let client_impl_tokens = quote! {
        #(#client_methods)*
    };

    QueryEmitResult {
        queries_tokens,
        client_impl_tokens,
    }
}

// ── Argument classification ──────────────────────────────────────────────────

/// Parsed info for a single query argument.
struct ArgInfo {
    param_name: proc_macro2::Ident,
    gql_name: String,
    rust_inner_type: TokenStream,
    gql_type_str: String,
    is_required: bool,
    is_string_type: bool,
}

/// Classify query arguments, supporting scalars, enums, and input objects.
fn classify_args(
    arguments: &[ArgumentDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> Vec<ArgInfo> {
    arguments
        .iter()
        .filter_map(|arg| {
            let base = arg.ty.base_name();
            let is_required = matches!(arg.ty, GqlType::NonNull(_));
            let is_string_type = matches!(base, "String" | "ID");

            // Determine if this argument type is supported.
            let rust_inner_type = match type_kind_map.get(base) {
                Some(TypeKind::Scalar) => resolve_arg_inner(&arg.ty),
                Some(TypeKind::Enum) => {
                    let ident = quote::format_ident!("{}", base);
                    quote! { #ident }
                }
                Some(TypeKind::InputObject) => {
                    let ident = quote::format_ident!("{}", base);
                    quote! { #ident }
                }
                _ => return None,
            };

            Some(ArgInfo {
                param_name: quote::format_ident!("{}", arg.name.to_snake_case()),
                gql_name: arg.name.clone(),
                rust_inner_type,
                gql_type_str: gql_type_string(&arg.ty),
                is_required,
                is_string_type,
            })
        })
        .collect()
}

// ── Per-query emit result ────────────────────────────────────────────────────

struct QueryResult {
    builders: Vec<TokenStream>,
    standalone_fns: Vec<TokenStream>,
    client_method: TokenStream,
}

// ── Main dispatch ────────────────────────────────────────────────────────────

fn emit_query(
    field: &FieldDef,
    rename: Option<&str>,
    depth: Option<FieldDepth>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> QueryResult {
    let args = classify_args(&field.arguments, type_kind_map);
    let has_optional = args.iter().any(|a| !a.is_required);
    let return_type_name = field.ty.base_name();
    let is_connection =
        return_type_name.ends_with("Connection") || return_type_name.ends_with("Payload");

    if has_optional {
        emit_builder_query(
            field,
            rename,
            &args,
            is_connection,
            depth,
            object_map,
            type_kind_map,
        )
    } else {
        emit_direct_query(
            field,
            rename,
            &args,
            is_connection,
            depth,
            object_map,
            type_kind_map,
        )
    }
}

// ── Direct queries (no optional args) ────────────────────────────────────────

fn emit_direct_query(
    field: &FieldDef,
    rename: Option<&str>,
    args: &[ArgInfo],
    is_connection: bool,
    depth: Option<FieldDepth>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> QueryResult {
    let method_name =
        quote::format_ident!("{}", rename.unwrap_or(field.name.as_str()).to_snake_case());
    let return_type_name = field.ty.base_name();

    let params: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            quote! { #name: #ty }
        })
        .collect();

    let variables_json: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! { #gql_name: #param_name }
        })
        .collect();

    let (gql_args_str, gql_params_str) = build_gql_strings(args);
    let data_path = &field.name;
    let doc = parser::doc_comment_tokens(&field.description);

    // Arguments for the client delegation method.
    let call_args: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            quote! { #name }
        })
        .collect();

    if is_connection {
        let (node_type_name, node_type_ident) = connection_node_type(return_type_name);
        let field_selection =
            resolve_field_selection(node_type_name, true, depth, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_connection_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );

        let standalone_fn = quote! {
            #doc
            pub async fn #method_name(client: &Client, #(#params),*) -> Result<Connection<#node_type_ident>, LinearError> {
                let variables = serde_json::json!({ #(#variables_json),* });
                client.execute_connection::<#node_type_ident>(#query_string, variables, #data_path).await
            }
        };

        let client_method = quote! {
            #doc
            pub async fn #method_name(&self, #(#params),*) -> Result<Connection<#node_type_ident>, LinearError> {
                crate::generated::queries::#method_name(self, #(#call_args),*).await
            }
        };

        QueryResult {
            builders: vec![],
            standalone_fns: vec![standalone_fn],
            client_method,
        }
    } else {
        let return_type_ident = quote::format_ident!("{}", return_type_name);
        let field_selection =
            resolve_field_selection(return_type_name, false, depth, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_single_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );

        let standalone_fn = quote! {
            #doc
            pub async fn #method_name(client: &Client, #(#params),*) -> Result<#return_type_ident, LinearError> {
                let variables = serde_json::json!({ #(#variables_json),* });
                client.execute::<#return_type_ident>(#query_string, variables, #data_path).await
            }
        };

        let client_method = quote! {
            #doc
            pub async fn #method_name(&self, #(#params),*) -> Result<#return_type_ident, LinearError> {
                crate::generated::queries::#method_name(self, #(#call_args),*).await
            }
        };

        QueryResult {
            builders: vec![],
            standalone_fns: vec![standalone_fn],
            client_method,
        }
    }
}

// ── Builder queries (has optional args) ──────────────────────────────────────

fn emit_builder_query(
    field: &FieldDef,
    rename: Option<&str>,
    args: &[ArgInfo],
    is_connection: bool,
    depth: Option<FieldDepth>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> QueryResult {
    let rust_name = rename.unwrap_or(field.name.as_str());
    let method_name = quote::format_ident!("{}", rust_name.to_snake_case());
    let builder_name = quote::format_ident!("{}QueryBuilder", rust_name.to_upper_camel_case());
    let return_type_name = field.ty.base_name();
    let doc = parser::doc_comment_tokens(&field.description);

    let required_args: Vec<&ArgInfo> = args.iter().filter(|a| a.is_required).collect();
    let optional_args: Vec<&ArgInfo> = args.iter().filter(|a| !a.is_required).collect();

    // ── Builder struct fields ──
    let struct_fields: Vec<TokenStream> = {
        let mut fields = vec![quote! { client: &'a Client }];
        for a in &required_args {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            fields.push(quote! { #name: #ty });
        }
        for a in &optional_args {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            fields.push(quote! { #name: Option<#ty> });
        }
        fields
    };

    // ── Setter methods for optional args ──
    let setters: Vec<TokenStream> = optional_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            if a.is_string_type {
                quote! {
                    pub fn #name(mut self, value: impl Into<#ty>) -> Self {
                        self.#name = Some(value.into());
                        self
                    }
                }
            } else {
                quote! {
                    pub fn #name(mut self, value: #ty) -> Self {
                        self.#name = Some(value);
                        self
                    }
                }
            }
        })
        .collect();

    // ── Variables JSON building ──
    // Required args are always included; optional args are only included when Some.
    let required_var_inserts: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! { map.insert(#gql_name.to_string(), serde_json::json!(self.#param_name)); }
        })
        .collect();
    let optional_var_inserts: Vec<TokenStream> = optional_args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! {
                if let Some(ref v) = self.#param_name {
                    map.insert(#gql_name.to_string(), serde_json::json!(v));
                }
            }
        })
        .collect();
    let build_variables = quote! {
        let mut map = serde_json::Map::new();
        #(#required_var_inserts)*
        #(#optional_var_inserts)*
        let variables = serde_json::Value::Object(map);
    };

    let (gql_args_str, gql_params_str) = build_gql_strings(args);
    let data_path = &field.name;

    // ── send() return type and body ──
    let (send_return_type, send_body) = if is_connection {
        let (node_type_name, node_type_ident) = connection_node_type(return_type_name);
        let field_selection =
            resolve_field_selection(node_type_name, true, depth, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_connection_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );
        (
            quote! { Connection<#node_type_ident> },
            quote! {
                #build_variables
                self.client.execute_connection::<#node_type_ident>(#query_string, variables, #data_path).await
            },
        )
    } else {
        let return_type_ident = quote::format_ident!("{}", return_type_name);
        let field_selection =
            resolve_field_selection(return_type_name, false, depth, object_map, type_kind_map);
        let query_name = field.name.to_upper_camel_case();
        let query_string = build_single_query_string(
            &query_name,
            &field.name,
            &field_selection,
            &gql_args_str,
            &gql_params_str,
        );
        (
            quote! { #return_type_ident },
            quote! {
                #build_variables
                self.client.execute::<#return_type_ident>(#query_string, variables, #data_path).await
            },
        )
    };

    // ── Builder struct + impl ──
    let builder_doc = match &field.description {
        Some(desc) => {
            let sanitized = crate::parser::sanitize_doc(desc);
            let text = format!(" Query builder: {}", sanitized);
            quote::quote! { #[doc = #text] }
        }
        None => {
            let text = format!(" Query builder for `{}`.", method_name);
            quote::quote! { #[doc = #text] }
        }
    };

    let builder_tokens = quote! {
        #builder_doc
        ///
        /// Use setter methods to configure optional parameters, then call
        /// [`.send()`](Self::send) to execute the query.
        #[must_use]
        pub struct #builder_name<'a> {
            #(#struct_fields,)*
        }

        impl<'a> #builder_name<'a> {
            #(#setters)*

            pub async fn send(self) -> Result<#send_return_type, LinearError> {
                #send_body
            }
        }
    };

    // ── Standalone factory function ──
    let constructor_params: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            if a.is_string_type {
                quote! { #name: impl Into<#ty> }
            } else {
                quote! { #name: #ty }
            }
        })
        .collect();

    let field_inits: Vec<TokenStream> = {
        let mut inits = vec![quote! { client }];
        for a in &required_args {
            let name = &a.param_name;
            if a.is_string_type {
                inits.push(quote! { #name: #name.into() });
            } else {
                inits.push(quote! { #name });
            }
        }
        for a in &optional_args {
            let name = &a.param_name;
            inits.push(quote! { #name: None });
        }
        inits
    };

    let standalone_fn = quote! {
        #doc
        pub fn #method_name<'a>(client: &'a Client, #(#constructor_params),*) -> #builder_name<'a> {
            #builder_name {
                #(#field_inits,)*
            }
        }
    };

    // ── Client delegation method ──
    let client_call_args: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            quote! { #name }
        })
        .collect();

    let client_method = quote! {
        #doc
        pub fn #method_name(&self, #(#constructor_params),*) -> #builder_name<'_> {
            crate::generated::queries::#method_name(self, #(#client_call_args),*)
        }
    };

    QueryResult {
        builders: vec![builder_tokens],
        standalone_fns: vec![standalone_fn],
        client_method,
    }
}

// ── Shared helpers ───────────────────────────────────────────────────────────

/// Resolve field selection for a type based on the requested depth.
/// For connection queries, `depth` overrides the default (nested).
/// For single-object queries, `depth` overrides the default (detail).
fn resolve_field_selection(
    type_name: &str,
    is_connection: bool,
    depth: Option<FieldDepth>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let effective_depth = depth.unwrap_or(if is_connection {
        FieldDepth::Nested
    } else {
        FieldDepth::Detail
    });
    match effective_depth {
        FieldDepth::Flat => build_field_selection(type_name, object_map, type_kind_map),
        FieldDepth::Nested => build_field_selection_nested(type_name, object_map, type_kind_map),
        FieldDepth::Detail => build_field_selection_detail(type_name, object_map, type_kind_map),
    }
}

fn connection_node_type(connection_type_name: &str) -> (&str, proc_macro2::Ident) {
    let node_type_name = connection_type_name
        .strip_suffix("Connection")
        .or_else(|| connection_type_name.strip_suffix("SearchPayload"))
        .unwrap_or(connection_type_name);
    let node_type_ident = quote::format_ident!("{}", node_type_name);
    (node_type_name, node_type_ident)
}

fn build_gql_strings(args: &[ArgInfo]) -> (String, String) {
    let gql_args: Vec<String> = args
        .iter()
        .map(|a| format!("{}: ${}", a.gql_name, a.gql_name))
        .collect();
    let gql_params: Vec<String> = args
        .iter()
        .map(|a| format!("${}: {}", a.gql_name, a.gql_type_str))
        .collect();
    (gql_args.join(", "), gql_params.join(", "))
}

fn build_connection_query_string(
    query_name: &str,
    field_name: &str,
    field_selection: &str,
    gql_args: &str,
    gql_params: &str,
) -> String {
    if gql_params.is_empty() {
        format!(
            "query {} {{ {} {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            query_name, field_name, field_selection
        )
    } else {
        format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            query_name, gql_params, field_name, gql_args, field_selection
        )
    }
}

fn build_single_query_string(
    query_name: &str,
    field_name: &str,
    field_selection: &str,
    gql_args: &str,
    gql_params: &str,
) -> String {
    if gql_params.is_empty() {
        format!(
            "query {} {{ {} {{ {} }} }}",
            query_name, field_name, field_selection
        )
    } else {
        format!(
            "query {}({}) {{ {}({}) {{ {} }} }}",
            query_name, gql_params, field_name, gql_args, field_selection
        )
    }
}

/// Fields to exclude from query selection (noisy/internal, waste LLM context).
const EXCLUDED_FIELDS: &[&str] = &[
    "descriptionState", // Yjs CRDT binary blob, useless for display
    "featureFlags",     // exposed in introspection but not queryable
    "customerNeed",     // causes Internal Server Error on some Linear accounts
];

/// Check if a field has required (non-null) arguments that prevent automatic selection.
fn has_required_arguments(field: &FieldDef) -> bool {
    field
        .arguments
        .iter()
        .any(|a| matches!(a.ty, GqlType::NonNull(_)))
}

/// Build the scalar/enum field selection string for a type (flat, no nesting).
pub fn build_field_selection(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    obj.fields
        .iter()
        .filter(|f| {
            let base = f.ty.base_name();
            !EXCLUDED_FIELDS.contains(&f.name.as_str())
                && !has_required_arguments(f)
                && matches!(
                    type_kind_map.get(base),
                    Some(TypeKind::Scalar) | Some(TypeKind::Enum)
                )
        })
        .map(|f| f.name.clone())
        .collect::<Vec<_>>()
        .join(" ")
}

/// Build field selection with one level of nested objects (for queries).
///
/// Includes: scalar/enum fields + nested Object fields with minimal identifying fields
/// (id, name, key, title, identifier, etc.) to keep query complexity under API limits.
/// Does NOT include nested Connection-type fields (too expensive).
pub fn build_field_selection_nested(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    let mut parts: Vec<String> = Vec::new();

    for field in &obj.fields {
        if EXCLUDED_FIELDS.contains(&field.name.as_str()) || has_required_arguments(field) {
            continue;
        }
        let base = field.ty.base_name();
        match type_kind_map.get(base) {
            Some(TypeKind::Scalar) | Some(TypeKind::Enum) => {
                parts.push(field.name.clone());
            }
            Some(TypeKind::Object) => {
                // Skip Connection types — too expensive.
                if is_connection_type(base, object_map) {
                    continue;
                }
                // Select only key identifying fields from nested objects to keep
                // query complexity under API limits.
                let nested_selection = build_identifying_fields(base, object_map, type_kind_map);
                if !nested_selection.is_empty() {
                    parts.push(format!("{} {{ {} }}", field.name, nested_selection));
                }
            }
            _ => {}
        }
    }

    parts.join(" ")
}

/// Key identifying field names to include in nested object selections.
/// These are the most commonly useful fields for display and linking.
const IDENTIFYING_FIELDS: &[&str] = &[
    "id",
    "name",
    "key",
    "title",
    "identifier",
    "email",
    "number",
    "color",
    "type",
    "url",
    "displayName",
];

/// Select only key identifying fields from a type (id, name, key, title, etc.).
fn build_identifying_fields(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    obj.fields
        .iter()
        .filter(|f| {
            let base = f.ty.base_name();
            IDENTIFYING_FIELDS.contains(&f.name.as_str())
                && !has_required_arguments(f)
                && matches!(
                    type_kind_map.get(base),
                    Some(TypeKind::Scalar) | Some(TypeKind::Enum)
                )
        })
        .map(|f| f.name.clone())
        .collect::<Vec<_>>()
        .join(" ")
}

/// Build node fields for Connection nodes inside detail queries.
/// Includes identifying scalar/enum fields PLUS non-Connection Object fields with `{ id }`.
fn build_node_fields_with_refs(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    let mut parts: Vec<String> = Vec::new();

    for f in &obj.fields {
        if EXCLUDED_FIELDS.contains(&f.name.as_str()) || has_required_arguments(f) {
            continue;
        }
        let base = f.ty.base_name();
        match type_kind_map.get(base) {
            Some(TypeKind::Scalar) | Some(TypeKind::Enum) => {
                if IDENTIFYING_FIELDS.contains(&f.name.as_str()) {
                    parts.push(f.name.clone());
                }
            }
            Some(TypeKind::Object) => {
                // Only include if the target type has an `id` field and isn't a Connection.
                if !is_connection_type(base, object_map) {
                    if let Some(target) = object_map.get(base) {
                        if target.fields.iter().any(|tf| tf.name == "id") {
                            parts.push(format!("{} {{ id }}", f.name));
                        }
                    }
                }
            }
            _ => {}
        }
    }

    parts.join(" ")
}

/// Build field selection for detail (single-object) queries.
///
/// Like `build_field_selection_nested` but also includes Connection-type fields
/// with their nodes' identifying fields. Used for single-item queries where
/// the complexity budget is larger.
fn build_field_selection_detail(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    let mut parts: Vec<String> = Vec::new();

    for field in &obj.fields {
        if EXCLUDED_FIELDS.contains(&field.name.as_str()) || has_required_arguments(field) {
            continue;
        }
        let base = field.ty.base_name();
        match type_kind_map.get(base) {
            Some(TypeKind::Scalar) | Some(TypeKind::Enum) => {
                parts.push(field.name.clone());
            }
            Some(TypeKind::Object) => {
                if is_connection_type(base, object_map) {
                    // Include Connection nodes with identifying fields + object refs.
                    let node_type_name = base.strip_suffix("Connection").unwrap_or(base);
                    let node_selection =
                        build_node_fields_with_refs(node_type_name, object_map, type_kind_map);
                    if !node_selection.is_empty() {
                        parts.push(format!(
                            "{} {{ nodes {{ {} }} }}",
                            field.name, node_selection
                        ));
                    }
                } else {
                    let nested_selection =
                        build_identifying_fields(base, object_map, type_kind_map);
                    if !nested_selection.is_empty() {
                        parts.push(format!("{} {{ {} }}", field.name, nested_selection));
                    }
                }
            }
            _ => {}
        }
    }

    parts.join(" ")
}

/// Check if a type is a Connection type (has a `nodes` field that is a list of Objects).
fn is_connection_type(type_name: &str, object_map: &HashMap<&str, &ObjectDef>) -> bool {
    if let Some(obj) = object_map.get(type_name) {
        obj.fields.iter().any(|f| f.name == "nodes")
    } else {
        // Fallback: check name convention.
        type_name.ends_with("Connection")
    }
}

/// Convert GqlType back to a GraphQL type string (e.g., `String!`, `[String!]`).
pub fn gql_type_string(ty: &GqlType) -> String {
    match ty {
        GqlType::Named(name) => name.clone(),
        GqlType::NonNull(inner) => format!("{}!", gql_type_string(inner)),
        GqlType::List(inner) => format!("[{}]", gql_type_string(inner)),
    }
}

fn resolve_arg_inner(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::Named(name) => graphql_type_to_rust(name),
        GqlType::NonNull(inner) => resolve_arg_inner(inner),
        GqlType::List(inner) => {
            let elem = resolve_arg_inner(inner);
            quote! { Vec<#elem> }
        }
    }
}
