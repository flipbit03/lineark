use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{FieldDef, GqlType, ObjectDef, TypeKind};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

pub fn emit(
    query_fields: &[FieldDef],
    allowed: &HashSet<String>,
    objects: &[ObjectDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let object_map: HashMap<&str, &ObjectDef> =
        objects.iter().map(|o| (o.name.as_str(), o)).collect();

    let methods: Vec<TokenStream> = query_fields
        .iter()
        .filter(|f| allowed.contains(&f.name))
        .map(|f| emit_query_method(f, &object_map, type_kind_map))
        .collect();

    quote! {
        //! Generated query methods on Client.
        //!
        //! Generated by lineark-codegen — do not edit.

        #![allow(clippy::too_many_arguments)]

        use crate::client::Client;
        use crate::error::LinearError;
        use crate::pagination::Connection;
        use super::types::*;

        impl Client {
            #(#methods)*
        }
    }
}

fn emit_query_method(
    field: &FieldDef,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let method_name = quote::format_ident!("{}", field.name.to_snake_case());
    let return_type_name = field.ty.base_name();

    // Determine if this is a connection query or a plain object query.
    let is_connection =
        return_type_name.ends_with("Connection") || return_type_name.ends_with("Payload");

    if is_connection {
        emit_connection_method(field, &method_name, object_map, type_kind_map)
    } else {
        emit_single_method(field, &method_name, object_map, type_kind_map)
    }
}

/// Generate a method that returns a single object (e.g., `viewer`, `issue`, `team`).
fn emit_single_method(
    field: &FieldDef,
    method_name: &proc_macro2::Ident,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let return_type_name = field.ty.base_name();
    let return_type_ident = quote::format_ident!("{}", return_type_name);
    let query_name = field.name.to_upper_camel_case();

    // Build field selection string.
    let field_selection = build_field_selection(return_type_name, object_map, type_kind_map);

    // Build argument handling.
    let (params, variables_json, graphql_args, graphql_params) = build_args(&field.arguments);

    let query_string = if graphql_params.is_empty() {
        format!(
            "query {} {{ {} {{ {} }} }}",
            query_name, field.name, field_selection
        )
    } else {
        format!(
            "query {}({}) {{ {}({}) {{ {} }} }}",
            query_name, graphql_params, field.name, graphql_args, field_selection
        )
    };

    let data_path = &field.name;

    quote! {
        pub async fn #method_name(&self, #(#params),*) -> Result<#return_type_ident, LinearError> {
            let variables = serde_json::json!({ #(#variables_json),* });
            self.execute::<#return_type_ident>(#query_string, variables, #data_path).await
        }
    }
}

/// Generate a method that returns a Connection (e.g., `teams`, `issues`).
fn emit_connection_method(
    field: &FieldDef,
    method_name: &proc_macro2::Ident,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let connection_type_name = field.ty.base_name();
    let query_name = field.name.to_upper_camel_case();

    // Determine the node type from the connection (e.g., TeamConnection -> Team).
    let node_type_name = connection_type_name
        .strip_suffix("Connection")
        .or_else(|| connection_type_name.strip_suffix("SearchPayload"))
        .unwrap_or(connection_type_name);
    let node_type_ident = quote::format_ident!("{}", node_type_name);

    let field_selection = build_field_selection(node_type_name, object_map, type_kind_map);

    // Connection queries always include pagination args.
    let (params, variables_json, graphql_args, graphql_params) = build_args(&field.arguments);

    let nodes_query = if graphql_params.is_empty() {
        format!(
            "query {} {{ {} {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            query_name, field.name, field_selection
        )
    } else {
        format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            query_name, graphql_params, field.name, graphql_args, field_selection
        )
    };

    let data_path = &field.name;

    quote! {
        pub async fn #method_name(&self, #(#params),*) -> Result<Connection<#node_type_ident>, LinearError> {
            let variables = serde_json::json!({ #(#variables_json),* });
            self.execute_connection::<#node_type_ident>(#nodes_query, variables, #data_path).await
        }
    }
}

/// Fields to exclude from query selection (noisy/internal, waste LLM context).
const EXCLUDED_FIELDS: &[&str] = &[
    "descriptionState", // Yjs CRDT binary blob, useless for display
    "featureFlags",     // exposed in introspection but not queryable
];

/// Build the scalar/enum field selection string for a type.
fn build_field_selection(
    type_name: &str,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let Some(obj) = object_map.get(type_name) else {
        return "id".to_string();
    };

    obj.fields
        .iter()
        .filter(|f| {
            let base = f.ty.base_name();
            !EXCLUDED_FIELDS.contains(&f.name.as_str())
                && matches!(
                    type_kind_map.get(base),
                    Some(TypeKind::Scalar) | Some(TypeKind::Enum)
                )
        })
        .map(|f| f.name.clone())
        .collect::<Vec<_>>()
        .join(" ")
}

/// Build parameter tokens, variable JSON entries, GraphQL argument strings,
/// and GraphQL parameter type declarations.
fn build_args(
    arguments: &[crate::parser::ArgumentDef],
) -> (
    Vec<TokenStream>, // Rust fn params
    Vec<TokenStream>, // serde_json entries
    String,           // GraphQL args (e.g., "first: $first, after: $after")
    String,           // GraphQL params (e.g., "$first: Int, $after: String")
) {
    let mut params = Vec::new();
    let mut variables = Vec::new();
    let mut gql_args = Vec::new();
    let mut gql_params = Vec::new();

    for arg in arguments {
        // Skip complex filter/sort arguments for now — they're hard to type and we
        // don't need them for basic queries. Keep only simple scalar args.
        let base = arg.ty.base_name();
        let is_simple = matches!(base, "String" | "Int" | "Float" | "Boolean" | "ID");
        if !is_simple {
            continue;
        }

        let param_name = quote::format_ident!("{}", arg.name.to_snake_case());
        let gql_type_str = gql_type_string(&arg.ty);
        let rust_type = resolve_arg_type(&arg.ty);

        params.push(quote! { #param_name: #rust_type });

        let arg_name_str = &arg.name;
        variables.push(quote! { #arg_name_str: #param_name });

        gql_args.push(format!("{}: ${}", arg.name, arg.name));
        gql_params.push(format!("${}: {}", arg.name, gql_type_str));
    }

    let gql_args_str = gql_args.join(", ");
    let gql_params_str = gql_params.join(", ");

    (params, variables, gql_args_str, gql_params_str)
}

/// Convert GqlType back to a GraphQL type string (e.g., "String!", "[String!]").
fn gql_type_string(ty: &GqlType) -> String {
    match ty {
        GqlType::Named(name) => name.clone(),
        GqlType::NonNull(inner) => format!("{}!", gql_type_string(inner)),
        GqlType::List(inner) => format!("[{}]", gql_type_string(inner)),
    }
}

/// Resolve argument type to Rust tokens. Required args stay non-optional,
/// optional args become Option<T>.
fn resolve_arg_type(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::NonNull(inner) => resolve_arg_inner(inner),
        _ => {
            let rust = resolve_arg_inner(ty);
            quote! { Option<#rust> }
        }
    }
}

fn resolve_arg_inner(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::Named(name) => graphql_type_to_rust(name),
        GqlType::NonNull(inner) => resolve_arg_inner(inner),
        GqlType::List(inner) => {
            let elem = resolve_arg_inner(inner);
            quote! { Vec<#elem> }
        }
    }
}
