use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{self, ArgumentDef, FieldDef, GqlType, ObjectDef, TypeKind};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

/// Result of emitting all query code.
pub struct QueryEmitResult {
    /// Builder structs + standalone factory functions for `generated::queries`.
    pub queries_tokens: TokenStream,
    /// `impl Client` block for `generated/client_impl.rs`.
    pub client_impl_tokens: TokenStream,
}

pub fn emit(
    query_fields: &[FieldDef],
    allowed: &HashSet<String>,
    renames: &HashMap<String, String>,
    objects: &[ObjectDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> QueryEmitResult {
    let object_map: HashMap<&str, &ObjectDef> =
        objects.iter().map(|o| (o.name.as_str(), o)).collect();

    let mut builder_items: Vec<TokenStream> = Vec::new();
    let mut standalone_fns: Vec<TokenStream> = Vec::new();
    let mut client_methods: Vec<TokenStream> = Vec::new();

    for field in query_fields.iter().filter(|f| allowed.contains(&f.name)) {
        let rename = renames.get(&field.name).map(|s| s.as_str());
        let result = emit_query(field, rename, &object_map, type_kind_map);
        builder_items.extend(result.builders);
        standalone_fns.extend(result.standalone_fns);
        client_methods.push(result.client_method);
    }

    let queries_tokens = quote! {
        //! Generated query functions and builder types.
        //!
        //! All query functions are generic over `T: DeserializeOwned + GraphQLFields`.
        //! Pass the generated type for full-schema queries, or define your own
        //! lean struct for zero-overfetch.
        //!
        //! Generated by lineark-codegen — do not edit.

        use crate::client::Client;
        use crate::error::LinearError;
        use crate::field_selection::GraphQLFields;
        use crate::pagination::Connection;
        use serde::de::DeserializeOwned;
        use super::enums::*;
        use super::inputs::*;

        #(#builder_items)*

        #(#standalone_fns)*
    };

    let client_impl_tokens = quote! {
        #(#client_methods)*
    };

    QueryEmitResult {
        queries_tokens,
        client_impl_tokens,
    }
}

// ── Argument classification ──────────────────────────────────────────────────

/// Parsed info for a single query argument.
struct ArgInfo {
    param_name: proc_macro2::Ident,
    gql_name: String,
    rust_inner_type: TokenStream,
    gql_type_str: String,
    is_required: bool,
    is_string_type: bool,
}

/// Classify query arguments, supporting scalars, enums, and input objects.
fn classify_args(
    arguments: &[ArgumentDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> Vec<ArgInfo> {
    arguments
        .iter()
        .filter_map(|arg| {
            let base = arg.ty.base_name();
            let is_required = matches!(arg.ty, GqlType::NonNull(_));
            let is_string_type = matches!(base, "String" | "ID");

            let rust_inner_type = match type_kind_map.get(base) {
                Some(TypeKind::Scalar) => resolve_arg_inner(&arg.ty),
                Some(TypeKind::Enum) => {
                    let ident = quote::format_ident!("{}", base);
                    quote! { #ident }
                }
                Some(TypeKind::InputObject) => {
                    let ident = quote::format_ident!("{}", base);
                    quote! { #ident }
                }
                _ => return None,
            };

            Some(ArgInfo {
                param_name: quote::format_ident!("{}", arg.name.to_snake_case()),
                gql_name: arg.name.clone(),
                rust_inner_type,
                gql_type_str: gql_type_string(&arg.ty),
                is_required,
                is_string_type,
            })
        })
        .collect()
}

// ── Per-query emit result ────────────────────────────────────────────────────

struct QueryResult {
    builders: Vec<TokenStream>,
    standalone_fns: Vec<TokenStream>,
    client_method: TokenStream,
}

// ── Main dispatch ────────────────────────────────────────────────────────────

fn emit_query(
    field: &FieldDef,
    rename: Option<&str>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> QueryResult {
    let args = classify_args(&field.arguments, type_kind_map);
    let has_optional = args.iter().any(|a| !a.is_required);
    let return_type_name = field.ty.base_name();
    let is_connection =
        return_type_name.ends_with("Connection") || return_type_name.ends_with("Payload");

    if has_optional {
        emit_builder_query(
            field,
            rename,
            &args,
            is_connection,
            object_map,
            type_kind_map,
        )
    } else {
        emit_direct_query(
            field,
            rename,
            &args,
            is_connection,
            object_map,
            type_kind_map,
        )
    }
}

// ── Direct queries (no optional args) ────────────────────────────────────────

fn emit_direct_query(
    field: &FieldDef,
    rename: Option<&str>,
    args: &[ArgInfo],
    is_connection: bool,
    object_map: &HashMap<&str, &ObjectDef>,
    _type_kind_map: &HashMap<String, TypeKind>,
) -> QueryResult {
    let method_name =
        quote::format_ident!("{}", rename.unwrap_or(field.name.as_str()).to_snake_case());

    let params: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            quote! { #name: #ty }
        })
        .collect();

    let variables_json: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! { #gql_name: #param_name }
        })
        .collect();

    let (gql_args_str, gql_params_str) = build_gql_strings(args);
    let data_path = &field.name;
    let base_doc = parser::doc_comment_tokens(&field.description);
    let return_type_name = field.ty.base_name();
    let node_type_name = if is_connection {
        object_map
            .get(return_type_name)
            .and_then(|obj| obj.fields.iter().find(|f| f.name == "nodes"))
            .map(|f| f.ty.base_name())
            .unwrap_or(return_type_name)
    } else {
        return_type_name
    };
    let node_type_ident = quote::format_ident!("{}", node_type_name);
    let type_hint = format!(" Full type: [`{node_type_name}`](super::types::{node_type_name})");
    let doc = quote! { #base_doc #[doc = ""] #[doc = #type_hint] };

    let call_args: Vec<TokenStream> = args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            quote! { #name }
        })
        .collect();

    if is_connection {
        let query_name = field.name.to_upper_camel_case();

        let query_build = if gql_params_str.is_empty() {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {} {{ {} {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
                    #query_name, #data_path, selection
                );
            }
        } else {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
                    #query_name, #gql_params_str, #data_path, #gql_args_str, selection
                );
            }
        };

        let standalone_fn = quote! {
            #doc
            pub async fn #method_name<T: DeserializeOwned + GraphQLFields<FullType = super::types::#node_type_ident>>(client: &Client, #(#params),*) -> Result<Connection<T>, LinearError> {
                let variables = serde_json::json!({ #(#variables_json),* });
                #query_build
                client.execute_connection::<T>(&query, variables, #data_path).await
            }
        };

        let client_method = quote! {
            #doc
            pub async fn #method_name<T: DeserializeOwned + GraphQLFields<FullType = super::types::#node_type_ident>>(&self, #(#params),*) -> Result<Connection<T>, LinearError> {
                crate::generated::queries::#method_name::<T>(self, #(#call_args),*).await
            }
        };

        QueryResult {
            builders: vec![],
            standalone_fns: vec![standalone_fn],
            client_method,
        }
    } else {
        let query_name = field.name.to_upper_camel_case();

        let query_build = if gql_params_str.is_empty() {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {} {{ {} {{ {} }} }}",
                    #query_name, #data_path, selection
                );
            }
        } else {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {}({}) {{ {}({}) {{ {} }} }}",
                    #query_name, #gql_params_str, #data_path, #gql_args_str, selection
                );
            }
        };

        let standalone_fn = quote! {
            #doc
            pub async fn #method_name<T: DeserializeOwned + GraphQLFields<FullType = super::types::#node_type_ident>>(client: &Client, #(#params),*) -> Result<T, LinearError> {
                let variables = serde_json::json!({ #(#variables_json),* });
                #query_build
                client.execute::<T>(&query, variables, #data_path).await
            }
        };

        let client_method = quote! {
            #doc
            pub async fn #method_name<T: DeserializeOwned + GraphQLFields<FullType = super::types::#node_type_ident>>(&self, #(#params),*) -> Result<T, LinearError> {
                crate::generated::queries::#method_name::<T>(self, #(#call_args),*).await
            }
        };

        QueryResult {
            builders: vec![],
            standalone_fns: vec![standalone_fn],
            client_method,
        }
    }
}

// ── Builder queries (has optional args) ──────────────────────────────────────

fn emit_builder_query(
    field: &FieldDef,
    rename: Option<&str>,
    args: &[ArgInfo],
    is_connection: bool,
    object_map: &HashMap<&str, &ObjectDef>,
    _type_kind_map: &HashMap<String, TypeKind>,
) -> QueryResult {
    let rust_name = rename.unwrap_or(field.name.as_str());
    let method_name = quote::format_ident!("{}", rust_name.to_snake_case());
    let builder_name = quote::format_ident!("{}QueryBuilder", rust_name.to_upper_camel_case());
    let base_doc = parser::doc_comment_tokens(&field.description);
    let return_type_name = field.ty.base_name();
    let node_type_name = if is_connection {
        object_map
            .get(return_type_name)
            .and_then(|obj| obj.fields.iter().find(|f| f.name == "nodes"))
            .map(|f| f.ty.base_name())
            .unwrap_or(return_type_name)
    } else {
        return_type_name
    };
    let node_type_ident = quote::format_ident!("{}", node_type_name);
    let type_hint = format!(" Full type: [`{node_type_name}`](super::types::{node_type_name})");
    let doc = quote! { #base_doc #[doc = ""] #[doc = #type_hint] };

    let required_args: Vec<&ArgInfo> = args.iter().filter(|a| a.is_required).collect();
    let optional_args: Vec<&ArgInfo> = args.iter().filter(|a| !a.is_required).collect();

    // ── Builder struct fields ──
    let struct_fields: Vec<TokenStream> = {
        let mut fields = vec![quote! { client: &'a Client }];
        for a in &required_args {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            fields.push(quote! { #name: #ty });
        }
        for a in &optional_args {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            fields.push(quote! { #name: Option<#ty> });
        }
        fields.push(quote! { _marker: std::marker::PhantomData<T> });
        fields
    };

    // ── Setter methods for optional args ──
    let setters: Vec<TokenStream> = optional_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            if a.is_string_type {
                quote! {
                    pub fn #name(mut self, value: impl Into<#ty>) -> Self {
                        self.#name = Some(value.into());
                        self
                    }
                }
            } else {
                quote! {
                    pub fn #name(mut self, value: #ty) -> Self {
                        self.#name = Some(value);
                        self
                    }
                }
            }
        })
        .collect();

    // ── Variables JSON building ──
    let required_var_inserts: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! { map.insert(#gql_name.to_string(), serde_json::json!(self.#param_name)); }
        })
        .collect();
    let optional_var_inserts: Vec<TokenStream> = optional_args
        .iter()
        .map(|a| {
            let gql_name = &a.gql_name;
            let param_name = &a.param_name;
            quote! {
                if let Some(ref v) = self.#param_name {
                    map.insert(#gql_name.to_string(), serde_json::json!(v));
                }
            }
        })
        .collect();
    let build_variables = quote! {
        let mut map = serde_json::Map::new();
        #(#required_var_inserts)*
        #(#optional_var_inserts)*
        let variables = serde_json::Value::Object(map);
    };

    let (gql_args_str, gql_params_str) = build_gql_strings(args);
    let data_path = &field.name;

    // ── send() return type and body ──
    let (send_return_type, send_body) = if is_connection {
        let query_name = field.name.to_upper_camel_case();

        let query_build = if gql_params_str.is_empty() {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {} {{ {} {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
                    #query_name, #data_path, selection
                );
            }
        } else {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
                    #query_name, #gql_params_str, #data_path, #gql_args_str, selection
                );
            }
        };

        (
            quote! { Connection<T> },
            quote! {
                #build_variables
                #query_build
                self.client.execute_connection::<T>(&query, variables, #data_path).await
            },
        )
    } else {
        let query_name = field.name.to_upper_camel_case();

        let query_build = if gql_params_str.is_empty() {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {} {{ {} {{ {} }} }}",
                    #query_name, #data_path, selection
                );
            }
        } else {
            quote! {
                let selection = T::selection();
                let query = format!(
                    "query {}({}) {{ {}({}) {{ {} }} }}",
                    #query_name, #gql_params_str, #data_path, #gql_args_str, selection
                );
            }
        };

        (
            quote! { T },
            quote! {
                #build_variables
                #query_build
                self.client.execute::<T>(&query, variables, #data_path).await
            },
        )
    };

    // ── Builder struct + impl ──
    let builder_doc = match &field.description {
        Some(desc) => {
            let sanitized = crate::parser::sanitize_doc(desc);
            let text = format!(" Query builder: {}", sanitized);
            quote::quote! { #[doc = #text] #[doc = ""] #[doc = #type_hint] }
        }
        None => {
            let text = format!(" Query builder for `{}`.", method_name);
            quote::quote! { #[doc = #text] #[doc = ""] #[doc = #type_hint] }
        }
    };

    let builder_tokens = quote! {
        #builder_doc
        ///
        /// Use setter methods to configure optional parameters, then call
        /// [`.send()`](Self::send) to execute the query.
        #[must_use]
        pub struct #builder_name<'a, T> {
            #(#struct_fields,)*
        }

        impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::#node_type_ident>> #builder_name<'a, T> {
            #(#setters)*

            pub async fn send(self) -> Result<#send_return_type, LinearError> {
                #send_body
            }
        }
    };

    // ── Standalone factory function ──
    let constructor_params: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            let ty = &a.rust_inner_type;
            if a.is_string_type {
                quote! { #name: impl Into<#ty> }
            } else {
                quote! { #name: #ty }
            }
        })
        .collect();

    let field_inits: Vec<TokenStream> = {
        let mut inits = vec![quote! { client }];
        for a in &required_args {
            let name = &a.param_name;
            if a.is_string_type {
                inits.push(quote! { #name: #name.into() });
            } else {
                inits.push(quote! { #name });
            }
        }
        for a in &optional_args {
            let name = &a.param_name;
            inits.push(quote! { #name: None });
        }
        inits.push(quote! { _marker: std::marker::PhantomData });
        inits
    };

    let standalone_fn = quote! {
        #doc
        pub fn #method_name<'a, T>(client: &'a Client, #(#constructor_params),*) -> #builder_name<'a, T> {
            #builder_name {
                #(#field_inits,)*
            }
        }
    };

    // ── Client delegation method ──
    let client_call_args: Vec<TokenStream> = required_args
        .iter()
        .map(|a| {
            let name = &a.param_name;
            quote! { #name }
        })
        .collect();

    let client_method = quote! {
        #doc
        pub fn #method_name<T>(&self, #(#constructor_params),*) -> #builder_name<'_, T> {
            crate::generated::queries::#method_name(self, #(#client_call_args),*)
        }
    };

    QueryResult {
        builders: vec![builder_tokens],
        standalone_fns: vec![standalone_fn],
        client_method,
    }
}

// ── Shared helpers ───────────────────────────────────────────────────────────

fn build_gql_strings(args: &[ArgInfo]) -> (String, String) {
    let gql_args: Vec<String> = args
        .iter()
        .map(|a| format!("{}: ${}", a.gql_name, a.gql_name))
        .collect();
    let gql_params: Vec<String> = args
        .iter()
        .map(|a| format!("${}: {}", a.gql_name, a.gql_type_str))
        .collect();
    (gql_args.join(", "), gql_params.join(", "))
}

/// Fields to exclude from query selection (noisy/internal, waste LLM context).
pub const EXCLUDED_FIELDS: &[&str] = &[
    "descriptionState", // Yjs CRDT binary blob, useless for display
    "featureFlags",     // exposed in introspection but not queryable
    "customerNeed",     // causes Internal Server Error on some Linear accounts
];

/// Check if a field has required (non-null) arguments that prevent automatic selection.
pub fn has_required_arguments(field: &FieldDef) -> bool {
    field
        .arguments
        .iter()
        .any(|a| matches!(a.ty, GqlType::NonNull(_)))
}

/// Convert GqlType back to a GraphQL type string (e.g., `String!`, `[String!]`).
pub fn gql_type_string(ty: &GqlType) -> String {
    match ty {
        GqlType::Named(name) => name.clone(),
        GqlType::NonNull(inner) => format!("{}!", gql_type_string(inner)),
        GqlType::List(inner) => format!("[{}]", gql_type_string(inner)),
    }
}

fn resolve_arg_inner(ty: &GqlType) -> TokenStream {
    match ty {
        GqlType::Named(name) => graphql_type_to_rust(name),
        GqlType::NonNull(inner) => resolve_arg_inner(inner),
        GqlType::List(inner) => {
            let elem = resolve_arg_inner(inner);
            quote! { Vec<#elem> }
        }
    }
}
