use crate::emit_queries::{build_field_selection, gql_type_string};
use crate::parser::{self, FieldDef, GqlType, ObjectDef, TypeKind};
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

/// Result of emitting all mutation code.
pub struct MutationEmitResult {
    /// Standalone mutation functions for `generated::mutations`.
    pub mutations_tokens: TokenStream,
    /// `impl Client` block for `generated/client_impl.rs`.
    pub client_impl_tokens: TokenStream,
}

pub fn emit(
    mutation_fields: &[FieldDef],
    allowed: &HashSet<String>,
    renames: &HashMap<String, String>,
    objects: &[ObjectDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> MutationEmitResult {
    let object_map: HashMap<&str, &ObjectDef> =
        objects.iter().map(|o| (o.name.as_str(), o)).collect();

    let mut standalone_fns: Vec<TokenStream> = Vec::new();
    let mut client_methods: Vec<TokenStream> = Vec::new();

    for field in mutation_fields.iter().filter(|f| allowed.contains(&f.name)) {
        let rename = renames.get(&field.name).map(|s| s.as_str());
        if let Some((standalone, delegation)) =
            emit_mutation(field, rename, &object_map, type_kind_map)
        {
            standalone_fns.push(standalone);
            client_methods.push(delegation);
        }
    }

    let mutations_tokens = if standalone_fns.is_empty() {
        quote! {
            //! Generated mutation functions.
            //!
            //! Generated by lineark-codegen — do not edit.
            //! No mutations are enabled in operations.toml for this phase.
        }
    } else {
        quote! {
            //! Generated mutation functions.
            //!
            //! Each mutation is exposed as a standalone async function. The
            //! [`Client`] re-exports these as methods for convenience.
            //!
            //! Generated by lineark-codegen — do not edit.

            #![allow(clippy::too_many_arguments)]

            use crate::client::Client;
            use crate::error::LinearError;
            use super::inputs::*;

            #(#standalone_fns)*
        }
    };

    let client_impl_tokens = quote! {
        #(#client_methods)*
    };

    MutationEmitResult {
        mutations_tokens,
        client_impl_tokens,
    }
}

/// Generate a standalone mutation function + Client delegation method.
fn emit_mutation(
    field: &FieldDef,
    rename: Option<&str>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> Option<(TokenStream, TokenStream)> {
    let method_name =
        quote::format_ident!("{}", rename.unwrap_or(field.name.as_str()).to_snake_case());
    let payload_type_name = field.ty.base_name();
    let payload_obj = object_map.get(payload_type_name)?;

    let response_selection = build_payload_selection(payload_obj, object_map, type_kind_map);

    let (params, variables_json, graphql_args, graphql_params) =
        build_mutation_args(&field.arguments, type_kind_map);

    let mutation_name = &field.name;
    let operation_name = capitalize_first(mutation_name);

    let mutation_string = format!(
        "mutation {}({}) {{ {}({}) {{ {} }} }}",
        operation_name, graphql_params, mutation_name, graphql_args, response_selection
    );

    let data_path = mutation_name.as_str();
    let doc = parser::doc_comment_tokens(&field.description);

    // Build call args for client delegation.
    let call_args: Vec<TokenStream> = field
        .arguments
        .iter()
        .map(|arg| {
            let param_name = quote::format_ident!("{}", arg.name.to_snake_case());
            quote! { #param_name }
        })
        .collect();

    let standalone_fn = quote! {
        #doc
        pub async fn #method_name(client: &Client, #(#params),*) -> Result<serde_json::Value, LinearError> {
            let variables = serde_json::json!({ #(#variables_json),* });
            client.execute::<serde_json::Value>(#mutation_string, variables, #data_path).await
        }
    };

    let client_method = quote! {
        #doc
        pub async fn #method_name(&self, #(#params),*) -> Result<serde_json::Value, LinearError> {
            crate::generated::mutations::#method_name(self, #(#call_args),*).await
        }
    };

    Some((standalone_fn, client_method))
}

/// Build the field selection string for a mutation payload.
/// Selects `success` plus entity fields with their scalar/enum subfields.
fn build_payload_selection(
    payload_obj: &ObjectDef,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let mut parts = vec!["success".to_string()];

    for field in &payload_obj.fields {
        let base = field.ty.base_name();
        match type_kind_map.get(base) {
            Some(TypeKind::Scalar) | Some(TypeKind::Enum) => {
                if field.name != "lastSyncId" && field.name != "success" {
                    parts.push(field.name.clone());
                }
            }
            Some(TypeKind::Object) => {
                let entity_selection = build_field_selection(base, object_map, type_kind_map);
                if !entity_selection.is_empty() {
                    parts.push(format!("{} {{ {} }}", field.name, entity_selection));
                }
            }
            _ => {}
        }
    }

    parts.join(" ")
}

/// Build parameter tokens for mutation arguments.
fn build_mutation_args(
    arguments: &[crate::parser::ArgumentDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> (
    Vec<TokenStream>, // Rust fn params
    Vec<TokenStream>, // serde_json entries
    String,           // GraphQL args
    String,           // GraphQL params
) {
    let mut params = Vec::new();
    let mut variables = Vec::new();
    let mut gql_args = Vec::new();
    let mut gql_params = Vec::new();

    for arg in arguments {
        let param_name = quote::format_ident!("{}", arg.name.to_snake_case());
        let gql_type_str = gql_type_string(&arg.ty);
        let rust_type = resolve_mutation_arg_type(&arg.ty, type_kind_map);

        params.push(quote! { #param_name: #rust_type });

        let arg_name_str = &arg.name;
        variables.push(quote! { #arg_name_str: #param_name });

        gql_args.push(format!("{}: ${}", arg.name, arg.name));
        gql_params.push(format!("${}: {}", arg.name, gql_type_str));
    }

    let gql_args_str = gql_args.join(", ");
    let gql_params_str = gql_params.join(", ");

    (params, variables, gql_args_str, gql_params_str)
}

fn resolve_mutation_arg_type(
    ty: &GqlType,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    match ty {
        GqlType::NonNull(inner) => resolve_mutation_arg_inner(inner, type_kind_map),
        _ => {
            let rust = resolve_mutation_arg_inner(ty, type_kind_map);
            quote! { Option<#rust> }
        }
    }
}

fn resolve_mutation_arg_inner(
    ty: &GqlType,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    match ty {
        GqlType::Named(name) => {
            let base = name.as_str();
            match base {
                "String" | "ID" | "UUID" => quote! { String },
                "Int" => quote! { i64 },
                "Float" => quote! { f64 },
                "Boolean" => quote! { bool },
                _ => {
                    let ident = quote::format_ident!("{}", name);
                    match type_kind_map.get(base) {
                        Some(TypeKind::InputObject) | Some(TypeKind::Enum) => {
                            quote! { #ident }
                        }
                        _ => {
                            quote! { serde_json::Value }
                        }
                    }
                }
            }
        }
        GqlType::NonNull(inner) => resolve_mutation_arg_inner(inner, type_kind_map),
        GqlType::List(inner) => {
            let elem = resolve_mutation_arg_inner(inner, type_kind_map);
            quote! { Vec<#elem> }
        }
    }
}

fn capitalize_first(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().to_string() + c.as_str(),
    }
}
