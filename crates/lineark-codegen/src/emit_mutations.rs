use crate::emit_queries::{build_field_selection, gql_type_string};
use crate::parser::{FieldDef, GqlType, ObjectDef, TypeKind};
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

pub fn emit(
    mutation_fields: &[FieldDef],
    allowed: &HashSet<String>,
    renames: &HashMap<String, String>,
    objects: &[ObjectDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let object_map: HashMap<&str, &ObjectDef> =
        objects.iter().map(|o| (o.name.as_str(), o)).collect();

    let methods: Vec<TokenStream> = mutation_fields
        .iter()
        .filter(|f| allowed.contains(&f.name))
        .filter_map(|f| {
            let rename = renames.get(&f.name).map(|s| s.as_str());
            emit_mutation_method(f, rename, &object_map, type_kind_map)
        })
        .collect();

    if methods.is_empty() {
        return quote! {
            //! Generated mutation methods on Client.
            //!
            //! Generated by lineark-codegen — do not edit.
            //! No mutations are enabled in operations.toml for this phase.
        };
    }

    quote! {
        //! Generated mutation methods on Client.
        //!
        //! Generated by lineark-codegen — do not edit.

        #![allow(clippy::too_many_arguments)]

        use crate::client::Client;
        use crate::error::LinearError;
        use super::inputs::*;

        impl Client {
            #(#methods)*
        }
    }
}

/// Generate a mutation method.
///
/// Linear mutations follow a pattern:
///   mutationName(input: InputType!, id: String!, ...): PayloadType!
///
/// PayloadType contains:
///   - success: Boolean!
///   - lastSyncId: Float!
///   - entityField: EntityType (optional, named after the entity e.g. "issue", "comment")
///
/// We generate a method that takes the input + any extra args, sends the mutation,
/// and returns the payload with the entity's scalar/enum fields selected.
fn emit_mutation_method(
    field: &FieldDef,
    rename: Option<&str>,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> Option<TokenStream> {
    let method_name = quote::format_ident!(
        "{}",
        rename.unwrap_or(field.name.as_str()).to_snake_case()
    );
    let payload_type_name = field.ty.base_name();
    let payload_obj = object_map.get(payload_type_name)?;

    // Build the response field selection from the payload type.
    // We always select `success`, and for each entity field (Object type) in the payload,
    // we select its scalar/enum fields.
    let response_selection = build_payload_selection(payload_obj, object_map, type_kind_map);

    // Build Rust function parameters and GraphQL variable handling.
    let (params, variables_json, graphql_args, graphql_params) =
        build_mutation_args(&field.arguments, type_kind_map);

    let mutation_name = &field.name;
    // Use the GraphQL operation name (PascalCase-ish, but Linear uses camelCase mutation names).
    // For the operation name in the query string, capitalize first letter.
    let operation_name = capitalize_first(mutation_name);

    let mutation_string = format!(
        "mutation {}({}) {{ {}({}) {{ {} }} }}",
        operation_name, graphql_params, mutation_name, graphql_args, response_selection
    );

    let data_path = mutation_name.as_str();

    // Determine the return type: use serde_json::Value for flexibility.
    // The CLI will interpret the payload fields.
    quote! {
        pub async fn #method_name(&self, #(#params),*) -> Result<serde_json::Value, LinearError> {
            let variables = serde_json::json!({ #(#variables_json),* });
            self.execute::<serde_json::Value>(#mutation_string, variables, #data_path).await
        }
    }
    .into()
}

/// Build the field selection string for a mutation payload.
/// Selects `success` plus entity fields with their scalar/enum subfields.
fn build_payload_selection(
    payload_obj: &ObjectDef,
    object_map: &HashMap<&str, &ObjectDef>,
    type_kind_map: &HashMap<String, TypeKind>,
) -> String {
    let mut parts = vec!["success".to_string()];

    for field in &payload_obj.fields {
        let base = field.ty.base_name();
        match type_kind_map.get(base) {
            Some(TypeKind::Scalar) | Some(TypeKind::Enum) => {
                // Include scalar/enum fields directly (e.g., lastSyncId)
                if field.name != "lastSyncId" {
                    parts.push(field.name.clone());
                }
            }
            Some(TypeKind::Object) => {
                // Include entity object with its scalar/enum fields
                let entity_selection = build_field_selection(base, object_map, type_kind_map);
                if !entity_selection.is_empty() {
                    parts.push(format!("{} {{ {} }}", field.name, entity_selection));
                }
            }
            _ => {}
        }
    }

    parts.join(" ")
}

/// Build parameter tokens for mutation arguments.
/// Unlike queries, mutations accept complex input types (InputObject).
fn build_mutation_args(
    arguments: &[crate::parser::ArgumentDef],
    type_kind_map: &HashMap<String, TypeKind>,
) -> (
    Vec<TokenStream>, // Rust fn params
    Vec<TokenStream>, // serde_json entries
    String,           // GraphQL args
    String,           // GraphQL params
) {
    let mut params = Vec::new();
    let mut variables = Vec::new();
    let mut gql_args = Vec::new();
    let mut gql_params = Vec::new();

    for arg in arguments {
        let param_name = quote::format_ident!("{}", arg.name.to_snake_case());
        let gql_type_str = gql_type_string(&arg.ty);
        let rust_type = resolve_mutation_arg_type(&arg.ty, type_kind_map);

        params.push(quote! { #param_name: #rust_type });

        let arg_name_str = &arg.name;
        variables.push(quote! { #arg_name_str: #param_name });

        gql_args.push(format!("{}: ${}", arg.name, arg.name));
        gql_params.push(format!("${}: {}", arg.name, gql_type_str));
    }

    let gql_args_str = gql_args.join(", ");
    let gql_params_str = gql_params.join(", ");

    (params, variables, gql_args_str, gql_params_str)
}

/// Resolve a mutation argument type to Rust tokens.
/// Handles InputObject types (unlike query args which only handle scalars).
fn resolve_mutation_arg_type(
    ty: &GqlType,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    match ty {
        GqlType::NonNull(inner) => resolve_mutation_arg_inner(inner, type_kind_map),
        _ => {
            let rust = resolve_mutation_arg_inner(ty, type_kind_map);
            quote! { Option<#rust> }
        }
    }
}

fn resolve_mutation_arg_inner(
    ty: &GqlType,
    type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    match ty {
        GqlType::Named(name) => {
            let base = name.as_str();
            match base {
                "String" | "ID" | "UUID" => quote! { String },
                "Int" => quote! { i64 },
                "Float" => quote! { f64 },
                "Boolean" => quote! { bool },
                _ => {
                    // For InputObject and other types, use the type name directly
                    let ident = quote::format_ident!("{}", name);
                    match type_kind_map.get(base) {
                        Some(TypeKind::InputObject) | Some(TypeKind::Enum) => {
                            quote! { #ident }
                        }
                        _ => {
                            // Fall back to serde_json::Value for unknown types
                            quote! { serde_json::Value }
                        }
                    }
                }
            }
        }
        GqlType::NonNull(inner) => resolve_mutation_arg_inner(inner, type_kind_map),
        GqlType::List(inner) => {
            let elem = resolve_mutation_arg_inner(inner, type_kind_map);
            quote! { Vec<#elem> }
        }
    }
}

fn capitalize_first(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().to_string() + c.as_str(),
    }
}
