use crate::parser::{FieldDef, ObjectDef, TypeKind};
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::{HashMap, HashSet};

pub fn emit(
    mutation_fields: &[FieldDef],
    allowed: &HashSet<String>,
    _objects: &[ObjectDef],
    _type_kind_map: &HashMap<String, TypeKind>,
) -> TokenStream {
    let methods: Vec<TokenStream> = mutation_fields
        .iter()
        .filter(|f| allowed.contains(&f.name))
        .map(|_f| {
            // Mutation generation will be implemented in Phase 2.
            quote! {}
        })
        .collect();

    if methods.is_empty() || methods.iter().all(|m| m.is_empty()) {
        return quote! {
            //! Generated mutation methods on Client.
            //!
            //! Generated by lineark-codegen — do not edit.
            //! No mutations are enabled in operations.toml for this phase.
        };
    }

    quote! {
        //! Generated mutation methods on Client.
        //!
        //! Generated by lineark-codegen — do not edit.

        use crate::client::Client;
        use crate::error::LinearError;
        use super::types::*;
        use super::inputs::*;

        impl Client {
            #(#methods)*
        }
    }
}
