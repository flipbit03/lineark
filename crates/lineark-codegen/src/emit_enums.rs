use crate::parser::EnumDef;
use heck::ToUpperCamelCase;
use proc_macro2::TokenStream;
use quote::quote;

pub fn emit(enums: &[EnumDef]) -> TokenStream {
    let enum_defs: Vec<TokenStream> = enums
        .iter()
        .filter(|e| !e.name.is_empty())
        .map(emit_enum)
        .collect();

    quote! {
        //! GraphQL enum types.
        //!
        //! Generated by lineark-codegen â€” do not edit.

        use serde::{Deserialize, Serialize};

        #(#enum_defs)*
    }
}

fn emit_enum(e: &EnumDef) -> TokenStream {
    let name = quote::format_ident!("{}", e.name);
    let variants: Vec<TokenStream> = e
        .values
        .iter()
        .filter(|v| !v.name.is_empty())
        .map(|v| {
            let original = &v.name;
            // Convert to PascalCase for Rust convention.
            let rust_name = to_variant_name(original);
            let variant_ident = quote::format_ident!("{}", rust_name);
            if rust_name == *original {
                quote! { #variant_ident, }
            } else {
                quote! {
                    #[serde(rename = #original)]
                    #variant_ident,
                }
            }
        })
        .collect();

    quote! {
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub enum #name {
            #(#variants)*
            /// Catch-all for unknown/new variants added by Linear.
            #[serde(other)]
            Unknown,
        }
    }
}

/// Convert a GraphQL enum value name to a valid Rust PascalCase variant name.
fn to_variant_name(name: &str) -> String {
    // If it's already PascalCase (e.g. "InProgress"), keep it.
    // If it's camelCase (e.g. "createdAt"), convert to PascalCase.
    // If it's SCREAMING_SNAKE (e.g. "IN_PROGRESS"), convert to PascalCase.
    // If it's a number or starts with a number, prefix with underscore.
    let pascal = name.to_upper_camel_case();
    if pascal.is_empty() {
        return format!("_{}", name);
    }
    // If first char is a digit, prefix.
    if pascal.chars().next().is_some_and(|c| c.is_ascii_digit()) {
        format!("_{}", pascal)
    } else {
        pascal
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::{EnumDef, EnumValueDef};

    #[test]
    fn emit_generates_enum_with_variants() {
        let enums = vec![EnumDef {
            name: "Color".to_string(),
            values: vec![
                EnumValueDef {
                    name: "RED".to_string(),
                },
                EnumValueDef {
                    name: "GREEN".to_string(),
                },
                EnumValueDef {
                    name: "BLUE".to_string(),
                },
            ],
        }];
        let output = emit(&enums).to_string();
        assert!(output.contains("Color"));
        assert!(output.contains("Unknown"));
        // SCREAMING_SNAKE values get serde(rename)
        assert!(output.contains("serde"));
    }

    #[test]
    fn emit_includes_unknown_variant() {
        let enums = vec![EnumDef {
            name: "Status".to_string(),
            values: vec![EnumValueDef {
                name: "ACTIVE".to_string(),
            }],
        }];
        let output = emit(&enums).to_string();
        assert!(output.contains("Unknown"));
        assert!(output.contains("other"));
    }

    #[test]
    fn to_variant_name_screaming_snake() {
        assert_eq!(to_variant_name("IN_PROGRESS"), "InProgress");
        assert_eq!(to_variant_name("TODO"), "Todo");
    }

    #[test]
    fn to_variant_name_pascal_case_passthrough() {
        assert_eq!(to_variant_name("Active"), "Active");
    }

    #[test]
    fn to_variant_name_digit_prefix() {
        assert_eq!(to_variant_name("3dModel"), "_3dModel");
    }

    #[test]
    fn emit_skips_empty_names() {
        let enums = vec![EnumDef {
            name: "".to_string(),
            values: vec![],
        }];
        let output = emit(&enums).to_string();
        // Should not contain "pub enum" since the name is empty
        assert!(!output.contains("pub enum"));
    }

    #[test]
    fn emit_generated_code_parses() {
        let enums = vec![EnumDef {
            name: "Priority".to_string(),
            values: vec![
                EnumValueDef {
                    name: "noPriority".to_string(),
                },
                EnumValueDef {
                    name: "urgent".to_string(),
                },
                EnumValueDef {
                    name: "high".to_string(),
                },
            ],
        }];
        let output = emit(&enums).to_string();
        // Verify it parses as valid Rust
        syn::parse_file(&output).expect("Generated enum code should be valid Rust");
    }
}
