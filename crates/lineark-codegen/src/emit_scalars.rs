use crate::parser::ScalarDef;
use proc_macro2::TokenStream;
use quote::quote;

/// Map a GraphQL scalar name to its Rust type tokens.
pub fn scalar_to_rust_type(name: &str) -> Option<TokenStream> {
    match name {
        "DateTime" => Some(quote! { chrono::DateTime<chrono::Utc> }),
        "TimelessDate" => Some(quote! { chrono::NaiveDate }),
        "JSON" => Some(quote! { serde_json::Value }),
        "JSONObject" => Some(quote! { serde_json::Value }),
        "UUID" => Some(quote! { String }),
        "DateTimeOrDuration" | "TimelessDateOrDuration" | "Duration" => {
            Some(quote! { serde_json::Value })
        }
        _ => None,
    }
}

/// Generate scalar type alias definitions.
pub fn emit(scalars: &[ScalarDef]) -> TokenStream {
    let aliases: Vec<TokenStream> = scalars
        .iter()
        .filter_map(|s| {
            let rust_type = scalar_to_rust_type(&s.name)?;
            let name = quote::format_ident!("{}", s.name);
            Some(quote! {
                pub type #name = #rust_type;
            })
        })
        .collect();

    quote! {
        //! Custom scalar type aliases.
        //!
        //! Generated by lineark-codegen â€” do not edit.

        #(#aliases)*
    }
}

/// Map any GraphQL type name to its Rust type tokens.
/// Returns the Rust type for the base named type (no Option/Vec wrapping).
pub fn graphql_type_to_rust(name: &str) -> TokenStream {
    match name {
        "String" | "ID" | "UUID" => quote! { String },
        "Int" => quote! { i64 },
        "Float" => quote! { f64 },
        "Boolean" => quote! { bool },
        "DateTime" => quote! { chrono::DateTime<chrono::Utc> },
        "TimelessDate" => quote! { chrono::NaiveDate },
        "JSON" => quote! { serde_json::Value },
        "JSONObject" => quote! { serde_json::Value },
        // Custom Linear scalars that represent flexible types.
        "DateTimeOrDuration" | "TimelessDateOrDuration" | "Duration" => {
            quote! { serde_json::Value }
        }
        other => {
            // For enum types, use the type name directly (they're defined in enums.rs).
            // For anything else unknown, fall back to serde_json::Value.
            let ident = quote::format_ident!("{}", other);
            quote! { #ident }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::ScalarDef;

    #[test]
    fn graphql_builtins_map_correctly() {
        assert_eq!(graphql_type_to_rust("String").to_string(), "String");
        assert_eq!(graphql_type_to_rust("ID").to_string(), "String");
        assert_eq!(graphql_type_to_rust("UUID").to_string(), "String");
        assert_eq!(graphql_type_to_rust("Int").to_string(), "i64");
        assert_eq!(graphql_type_to_rust("Float").to_string(), "f64");
        assert_eq!(graphql_type_to_rust("Boolean").to_string(), "bool");
    }

    #[test]
    fn graphql_datetime_maps_to_chrono() {
        let ts = graphql_type_to_rust("DateTime").to_string();
        assert!(ts.contains("chrono"));
        assert!(ts.contains("DateTime"));
        assert!(ts.contains("Utc"));
    }

    #[test]
    fn graphql_json_maps_to_serde_value() {
        let ts = graphql_type_to_rust("JSON").to_string();
        assert!(ts.contains("serde_json"));
        assert!(ts.contains("Value"));
    }

    #[test]
    fn graphql_unknown_maps_to_ident() {
        let ts = graphql_type_to_rust("IssueStatus").to_string();
        assert_eq!(ts, "IssueStatus");
    }

    #[test]
    fn scalar_to_rust_known() {
        assert!(scalar_to_rust_type("DateTime").is_some());
        assert!(scalar_to_rust_type("JSON").is_some());
        assert!(scalar_to_rust_type("UUID").is_some());
        assert!(scalar_to_rust_type("TimelessDate").is_some());
    }

    #[test]
    fn scalar_to_rust_unknown() {
        assert!(scalar_to_rust_type("CustomScalar").is_none());
        assert!(scalar_to_rust_type("String").is_none());
    }

    #[test]
    fn emit_generates_type_aliases() {
        let scalars = vec![
            ScalarDef {
                name: "DateTime".to_string(),
            },
            ScalarDef {
                name: "JSON".to_string(),
            },
        ];
        let output = emit(&scalars).to_string();
        assert!(output.contains("DateTime"));
        assert!(output.contains("JSON"));
        assert!(output.contains("pub type"));
    }

    #[test]
    fn emit_skips_unknown_scalars() {
        let scalars = vec![ScalarDef {
            name: "SomeCustomThing".to_string(),
        }];
        let output = emit(&scalars).to_string();
        // Unknown scalars are skipped (no type alias generated)
        assert!(!output.contains("SomeCustomThing"));
    }
}
