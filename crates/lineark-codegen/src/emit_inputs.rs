use crate::emit_scalars::graphql_type_to_rust;
use crate::parser::{self, GqlType, InputDef, TypeKind};
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use quote::quote;
use std::collections::HashMap;

pub fn emit(inputs: &[InputDef], type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let structs: Vec<TokenStream> = inputs
        .iter()
        .filter(|i| !i.name.is_empty())
        .map(|i| emit_input_struct(i, type_kind_map))
        .collect();

    quote! {
        //! GraphQL input types.
        //!
        //! Generated by lineark-codegen — do not edit.

        use serde::{Deserialize, Serialize};
        use super::enums::*;

        #(#structs)*
    }
}

fn emit_input_struct(input: &InputDef, type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let name = quote::format_ident!("{}", input.name);

    let fields: Vec<TokenStream> = input
        .fields
        .iter()
        .filter(|f| {
            if f.name.is_empty() {
                return false;
            }
            // Include all fields — union/interface/object types will be mapped to serde_json::Value.
            let base = f.ty.base_name();
            matches!(
                type_kind_map.get(base),
                Some(TypeKind::Scalar) | Some(TypeKind::Enum) | Some(TypeKind::InputObject)
                    | Some(TypeKind::Union) | Some(TypeKind::Interface) | Some(TypeKind::Object)
                    | None
            )
        })
        .map(|f| {
            let field_name_str = f.name.to_snake_case();
            let original_name = &f.name;
            let safe_name = parser::safe_ident(&field_name_str);
            let field_ident = if safe_name.starts_with("r#") {
                let raw: TokenStream = safe_name.parse().unwrap();
                raw
            } else {
                let ident = quote::format_ident!("{}", safe_name);
                quote! { #ident }
            };
            let rust_type = resolve_input_type(&f.ty, type_kind_map);
            // If the snake_case name differs from the original camelCase, add serde rename.
            // We use rename_all on the struct level, so individual renames are only needed
            // if to_snake_case -> to_camelCase roundtrip doesn't match.
            let needs_rename = {
                let roundtrip = heck::AsLowerCamelCase(&field_name_str).to_string();
                roundtrip != *original_name
            };
            if needs_rename {
                quote! {
                    #[serde(rename = #original_name, default, skip_serializing_if = "Option::is_none")]
                    pub #field_ident: #rust_type,
                }
            } else {
                quote! {
                    #[serde(default, skip_serializing_if = "Option::is_none")]
                    pub #field_ident: #rust_type,
                }
            }
        })
        .collect();

    quote! {
        #[derive(Debug, Clone, Default, Serialize, Deserialize)]
        #[serde(rename_all = "camelCase")]
        pub struct #name {
            #(#fields)*
        }
    }
}

/// All input fields are Option<T> for easy Default derivation and the `..Default::default()` pattern.
fn resolve_input_type(ty: &GqlType, type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    let inner = resolve_inner(ty, type_kind_map);
    quote! { Option<#inner> }
}

fn resolve_inner(ty: &GqlType, type_kind_map: &HashMap<String, TypeKind>) -> TokenStream {
    match ty {
        GqlType::Named(name) => {
            let kind = type_kind_map.get(name.as_str());
            if matches!(kind, Some(TypeKind::InputObject)) {
                let ident = quote::format_ident!("{}", name);
                // Self-reference: input types reference other input types in the same module.
                quote! { Box<#ident> }
            } else if matches!(
                kind,
                Some(TypeKind::Union) | Some(TypeKind::Interface) | Some(TypeKind::Object)
            ) {
                // Union/interface/object types in inputs are serialized as raw JSON.
                quote! { serde_json::Value }
            } else {
                graphql_type_to_rust(name)
            }
        }
        GqlType::NonNull(inner) => resolve_inner(inner, type_kind_map),
        GqlType::List(inner) => {
            let elem = resolve_inner(inner, type_kind_map);
            quote! { Vec<#elem> }
        }
    }
}
