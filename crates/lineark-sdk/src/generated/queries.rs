//! Generated query methods on Client.
//!
//! Generated by lineark-codegen â€” do not edit.
use super::types::*;
use crate::client::Client;
use crate::error::LinearError;
use crate::pagination::Connection;
#[must_use]
pub struct WorkflowStatesQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> WorkflowStatesQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<WorkflowState>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                WorkflowState,
            >(
                "query WorkflowStates($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { workflowStates(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name color description position type } pageInfo { hasNextPage endCursor } } }",
                variables,
                "workflowStates",
            )
            .await
    }
}
#[must_use]
pub struct UsersQueryBuilder<'a> {
    client: &'a Client,
    include_disabled: Option<bool>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> UsersQueryBuilder<'a> {
    pub fn include_disabled(mut self, value: bool) -> Self {
        self.include_disabled = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<User>, LinearError> {
        let variables = serde_json::json!(
            { "includeDisabled" : self.include_disabled, "before" : self.before, "after"
            : self.after, "first" : self.first, "last" : self.last, "includeArchived" :
            self.include_archived }
        );
        self.client
            .execute_connection::<
                User,
            >(
                "query Users($includeDisabled: Boolean, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { users(includeDisabled: $includeDisabled, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } pageInfo { hasNextPage endCursor } } }",
                variables,
                "users",
            )
            .await
    }
}
#[must_use]
pub struct ProjectsQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> ProjectsQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Project>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Project,
            >(
                "query Projects($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { projects(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel } pageInfo { hasNextPage endCursor } } }",
                variables,
                "projects",
            )
            .await
    }
}
#[must_use]
pub struct TeamsQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> TeamsQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Team>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Team,
            >(
                "query Teams($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { teams(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash } pageInfo { hasNextPage endCursor } } }",
                variables,
                "teams",
            )
            .await
    }
}
#[must_use]
pub struct SearchIssuesQueryBuilder<'a> {
    client: &'a Client,
    term: String,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    include_comments: Option<bool>,
    team_id: Option<String>,
}
impl<'a> SearchIssuesQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn include_comments(mut self, value: bool) -> Self {
        self.include_comments = Some(value);
        self
    }
    pub fn team_id(mut self, value: impl Into<String>) -> Self {
        self.team_id = Some(value.into());
        self
    }
    pub async fn send(self) -> Result<Connection<Issue>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived, "term" : self.term,
            "includeComments" : self.include_comments, "teamId" : self.team_id }
        );
        self.client
            .execute_connection::<
                Issue,
            >(
                "query SearchIssues($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $term: String!, $includeComments: Boolean, $teamId: String) { searchIssues(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, term: $term, includeComments: $includeComments, teamId: $teamId) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } pageInfo { hasNextPage endCursor } } }",
                variables,
                "searchIssues",
            )
            .await
    }
}
#[must_use]
pub struct IssuesQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> IssuesQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Issue>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Issue,
            >(
                "query Issues($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issues(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issues",
            )
            .await
    }
}
#[must_use]
pub struct IssueRelationsQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> IssueRelationsQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<IssueRelation>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                IssueRelation,
            >(
                "query IssueRelations($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issueRelations(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt type } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issueRelations",
            )
            .await
    }
}
#[must_use]
pub struct IssueLabelsQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> IssueLabelsQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<IssueLabel>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                IssueLabel,
            >(
                "query IssueLabels($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issueLabels(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name description color isGroup lastAppliedAt retiredAt } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issueLabels",
            )
            .await
    }
}
#[must_use]
pub struct DocumentsQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> DocumentsQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Document>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Document,
            >(
                "query Documents($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { documents(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url } pageInfo { hasNextPage endCursor } } }",
                variables,
                "documents",
            )
            .await
    }
}
#[must_use]
pub struct CyclesQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> CyclesQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Cycle>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Cycle,
            >(
                "query Cycles($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { cycles(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious } pageInfo { hasNextPage endCursor } } }",
                variables,
                "cycles",
            )
            .await
    }
}
impl Client {
    /// All issue workflow states.
    pub fn workflow_states(&self) -> WorkflowStatesQueryBuilder<'_> {
        WorkflowStatesQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// All users for the organization.
    pub fn users(&self) -> UsersQueryBuilder<'_> {
        UsersQueryBuilder {
            client: self,
            include_disabled: None,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// The currently authenticated user.
    pub async fn whoami(&self) -> Result<User, LinearError> {
        let variables = serde_json::json!({});
        self.execute::<
                User,
            >(
                "query Viewer { viewer { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } }",
                variables,
                "viewer",
            )
            .await
    }
    /// All projects.
    pub fn projects(&self) -> ProjectsQueryBuilder<'_> {
        ProjectsQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// One specific project.
    pub async fn project(&self, id: String) -> Result<Project, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Project,
            >(
                "query Project($id: String!) { project(id: $id) { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel } }",
                variables,
                "project",
            )
            .await
    }
    /// All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
    pub fn teams(&self) -> TeamsQueryBuilder<'_> {
        TeamsQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// One specific team.
    pub async fn team(&self, id: String) -> Result<Team, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Team,
            >(
                "query Team($id: String!) { team(id: $id) { id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash } }",
                variables,
                "team",
            )
            .await
    }
    /// Search issues.
    pub fn search_issues(&self, term: impl Into<String>) -> SearchIssuesQueryBuilder<'_> {
        SearchIssuesQueryBuilder {
            client: self,
            term: term.into(),
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
            include_comments: None,
            team_id: None,
        }
    }
    /// All issues.
    pub fn issues(&self) -> IssuesQueryBuilder<'_> {
        IssuesQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// One specific issue.
    pub async fn issue(&self, id: String) -> Result<Issue, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Issue,
            >(
                "query Issue($id: String!) { issue(id: $id) { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } }",
                variables,
                "issue",
            )
            .await
    }
    /// All issue relationships.
    pub fn issue_relations(&self) -> IssueRelationsQueryBuilder<'_> {
        IssueRelationsQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// One specific issue relation.
    pub async fn issue_relation(&self, id: String) -> Result<IssueRelation, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                IssueRelation,
            >(
                "query IssueRelation($id: String!) { issueRelation(id: $id) { id createdAt updatedAt archivedAt type } }",
                variables,
                "issueRelation",
            )
            .await
    }
    /// All issue labels.
    pub fn issue_labels(&self) -> IssueLabelsQueryBuilder<'_> {
        IssueLabelsQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// All documents in the workspace.
    pub fn documents(&self) -> DocumentsQueryBuilder<'_> {
        DocumentsQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// One specific document.
    pub async fn document(&self, id: String) -> Result<Document, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Document,
            >(
                "query Document($id: String!) { document(id: $id) { id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url } }",
                variables,
                "document",
            )
            .await
    }
    /// All cycles.
    pub fn cycles(&self) -> CyclesQueryBuilder<'_> {
        CyclesQueryBuilder {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    /// One specific cycle.
    pub async fn cycle(&self, id: String) -> Result<Cycle, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Cycle,
            >(
                "query Cycle($id: String!) { cycle(id: $id) { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious } }",
                variables,
                "cycle",
            )
            .await
    }
}
