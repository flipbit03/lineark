//! Generated query methods on Client.
//!
//! Generated by lineark-codegen â€” do not edit.
#![allow(clippy::too_many_arguments)]
use super::types::*;
use crate::client::Client;
use crate::error::LinearError;
use crate::pagination::Connection;
impl Client {
    pub async fn workflow_states(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<WorkflowState>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived }
        );
        self.execute_connection::<
                WorkflowState,
            >(
                "query WorkflowStates($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { workflowStates(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name color description position type } pageInfo { hasNextPage endCursor } } }",
                variables,
                "workflowStates",
            )
            .await
    }
    pub async fn users(
        &self,
        include_disabled: Option<bool>,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<User>, LinearError> {
        let variables = serde_json::json!(
            { "includeDisabled" : include_disabled, "before" : before, "after" : after,
            "first" : first, "last" : last, "includeArchived" : include_archived }
        );
        self.execute_connection::<
                User,
            >(
                "query Users($includeDisabled: Boolean, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { users(includeDisabled: $includeDisabled, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } pageInfo { hasNextPage endCursor } } }",
                variables,
                "users",
            )
            .await
    }
    pub async fn viewer(&self) -> Result<User, LinearError> {
        let variables = serde_json::json!({});
        self.execute::<
                User,
            >(
                "query Viewer { viewer { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } }",
                variables,
                "viewer",
            )
            .await
    }
    pub async fn projects(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<Project>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived }
        );
        self.execute_connection::<
                Project,
            >(
                "query Projects($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { projects(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel } pageInfo { hasNextPage endCursor } } }",
                variables,
                "projects",
            )
            .await
    }
    pub async fn project(&self, id: String) -> Result<Project, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Project,
            >(
                "query Project($id: String!) { project(id: $id) { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel } }",
                variables,
                "project",
            )
            .await
    }
    pub async fn teams(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<Team>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived }
        );
        self.execute_connection::<
                Team,
            >(
                "query Teams($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { teams(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash } pageInfo { hasNextPage endCursor } } }",
                variables,
                "teams",
            )
            .await
    }
    pub async fn team(&self, id: String) -> Result<Team, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Team,
            >(
                "query Team($id: String!) { team(id: $id) { id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash } }",
                variables,
                "team",
            )
            .await
    }
    pub async fn search_issues(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
        term: String,
        include_comments: Option<bool>,
        team_id: Option<String>,
    ) -> Result<Connection<Issue>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived, "term" : term, "includeComments" :
            include_comments, "teamId" : team_id }
        );
        self.execute_connection::<
                Issue,
            >(
                "query SearchIssues($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $term: String!, $includeComments: Boolean, $teamId: String) { searchIssues(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, term: $term, includeComments: $includeComments, teamId: $teamId) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } pageInfo { hasNextPage endCursor } } }",
                variables,
                "searchIssues",
            )
            .await
    }
    pub async fn issues(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<Issue>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived }
        );
        self.execute_connection::<
                Issue,
            >(
                "query Issues($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issues(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issues",
            )
            .await
    }
    pub async fn issue(&self, id: String) -> Result<Issue, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Issue,
            >(
                "query Issue($id: String!) { issue(id: $id) { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } }",
                variables,
                "issue",
            )
            .await
    }
    pub async fn issue_labels(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<IssueLabel>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived }
        );
        self.execute_connection::<
                IssueLabel,
            >(
                "query IssueLabels($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issueLabels(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name description color isGroup lastAppliedAt retiredAt } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issueLabels",
            )
            .await
    }
    pub async fn cycles(
        &self,
        before: Option<String>,
        after: Option<String>,
        first: Option<i64>,
        last: Option<i64>,
        include_archived: Option<bool>,
    ) -> Result<Connection<Cycle>, LinearError> {
        let variables = serde_json::json!(
            { "before" : before, "after" : after, "first" : first, "last" : last,
            "includeArchived" : include_archived }
        );
        self.execute_connection::<
                Cycle,
            >(
                "query Cycles($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { cycles(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious } pageInfo { hasNextPage endCursor } } }",
                variables,
                "cycles",
            )
            .await
    }
    pub async fn cycle(&self, id: String) -> Result<Cycle, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Cycle,
            >(
                "query Cycle($id: String!) { cycle(id: $id) { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious } }",
                variables,
                "cycle",
            )
            .await
    }
}
