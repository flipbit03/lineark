//! Generated query methods on Client.
//!
//! Generated by lineark-codegen â€” do not edit.
use super::types::*;
use crate::client::Client;
use crate::error::LinearError;
use crate::pagination::Connection;
#[must_use]
pub struct WorkflowStatesQuery<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> WorkflowStatesQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<WorkflowState>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                WorkflowState,
            >(
                "query WorkflowStates($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { workflowStates(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name color description position type } pageInfo { hasNextPage endCursor } } }",
                variables,
                "workflowStates",
            )
            .await
    }
}
#[must_use]
pub struct UsersQuery<'a> {
    client: &'a Client,
    include_disabled: Option<bool>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> UsersQuery<'a> {
    pub fn include_disabled(mut self, value: bool) -> Self {
        self.include_disabled = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<User>, LinearError> {
        let variables = serde_json::json!(
            { "includeDisabled" : self.include_disabled, "before" : self.before, "after"
            : self.after, "first" : self.first, "last" : self.last, "includeArchived" :
            self.include_archived }
        );
        self.client
            .execute_connection::<
                User,
            >(
                "query Users($includeDisabled: Boolean, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { users(includeDisabled: $includeDisabled, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } pageInfo { hasNextPage endCursor } } }",
                variables,
                "users",
            )
            .await
    }
}
#[must_use]
pub struct ProjectsQuery<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> ProjectsQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Project>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Project,
            >(
                "query Projects($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { projects(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel } pageInfo { hasNextPage endCursor } } }",
                variables,
                "projects",
            )
            .await
    }
}
#[must_use]
pub struct TeamsQuery<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> TeamsQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Team>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Team,
            >(
                "query Teams($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { teams(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash } pageInfo { hasNextPage endCursor } } }",
                variables,
                "teams",
            )
            .await
    }
}
#[must_use]
pub struct SearchIssuesQuery<'a> {
    client: &'a Client,
    term: String,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    include_comments: Option<bool>,
    team_id: Option<String>,
}
impl<'a> SearchIssuesQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn include_comments(mut self, value: bool) -> Self {
        self.include_comments = Some(value);
        self
    }
    pub fn team_id(mut self, value: impl Into<String>) -> Self {
        self.team_id = Some(value.into());
        self
    }
    pub async fn send(self) -> Result<Connection<Issue>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived, "term" : self.term,
            "includeComments" : self.include_comments, "teamId" : self.team_id }
        );
        self.client
            .execute_connection::<
                Issue,
            >(
                "query SearchIssues($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $term: String!, $includeComments: Boolean, $teamId: String) { searchIssues(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, term: $term, includeComments: $includeComments, teamId: $teamId) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } pageInfo { hasNextPage endCursor } } }",
                variables,
                "searchIssues",
            )
            .await
    }
}
#[must_use]
pub struct IssuesQuery<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> IssuesQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Issue>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Issue,
            >(
                "query Issues($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issues(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issues",
            )
            .await
    }
}
#[must_use]
pub struct IssueLabelsQuery<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> IssueLabelsQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<IssueLabel>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                IssueLabel,
            >(
                "query IssueLabels($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { issueLabels(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt name description color isGroup lastAppliedAt retiredAt } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issueLabels",
            )
            .await
    }
}
#[must_use]
pub struct CyclesQuery<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
}
impl<'a> CyclesQuery<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Cycle>, LinearError> {
        let variables = serde_json::json!(
            { "before" : self.before, "after" : self.after, "first" : self.first, "last"
            : self.last, "includeArchived" : self.include_archived }
        );
        self.client
            .execute_connection::<
                Cycle,
            >(
                "query Cycles($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean) { cycles(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived) { nodes { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious } pageInfo { hasNextPage endCursor } } }",
                variables,
                "cycles",
            )
            .await
    }
}
impl Client {
    pub fn workflow_states(&self) -> WorkflowStatesQuery<'_> {
        WorkflowStatesQuery {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub fn users(&self) -> UsersQuery<'_> {
        UsersQuery {
            client: self,
            include_disabled: None,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub async fn viewer(&self) -> Result<User, LinearError> {
        let variables = serde_json::json!({});
        self.execute::<
                User,
            >(
                "query Viewer { viewer { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } }",
                variables,
                "viewer",
            )
            .await
    }
    pub fn projects(&self) -> ProjectsQuery<'_> {
        ProjectsQuery {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub async fn project(&self, id: String) -> Result<Project, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Project,
            >(
                "query Project($id: String!) { project(id: $id) { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel } }",
                variables,
                "project",
            )
            .await
    }
    pub fn teams(&self) -> TeamsQuery<'_> {
        TeamsQuery {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub async fn team(&self, id: String) -> Result<Team, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Team,
            >(
                "query Team($id: String!) { team(id: $id) { id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash } }",
                variables,
                "team",
            )
            .await
    }
    pub fn search_issues(&self, term: impl Into<String>) -> SearchIssuesQuery<'_> {
        SearchIssuesQuery {
            client: self,
            term: term.into(),
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
            include_comments: None,
            team_id: None,
        }
    }
    pub fn issues(&self) -> IssuesQuery<'_> {
        IssuesQuery {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub async fn issue(&self, id: String) -> Result<Issue, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Issue,
            >(
                "query Issue($id: String!) { issue(id: $id) { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } }",
                variables,
                "issue",
            )
            .await
    }
    pub fn issue_labels(&self) -> IssueLabelsQuery<'_> {
        IssueLabelsQuery {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub fn cycles(&self) -> CyclesQuery<'_> {
        CyclesQuery {
            client: self,
            before: None,
            after: None,
            first: None,
            last: None,
            include_archived: None,
        }
    }
    pub async fn cycle(&self, id: String) -> Result<Cycle, LinearError> {
        let variables = serde_json::json!({ "id" : id });
        self.execute::<
                Cycle,
            >(
                "query Cycle($id: String!) { cycle(id: $id) { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious } }",
                variables,
                "cycle",
            )
            .await
    }
}
