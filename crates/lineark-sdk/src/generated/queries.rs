//! Generated query functions and builder types.
//!
//! Each query is exposed as a standalone factory function that returns
//! a builder (for queries with optional parameters) or directly executes
//! the query. The [`Client`] re-exports these as methods
//! for convenience.
//!
//! Generated by lineark-codegen â€” do not edit.
use super::enums::*;
use super::inputs::*;
use super::types::*;
use crate::client::Client;
use crate::error::LinearError;
use crate::pagination::Connection;
/// Query builder: All issue workflow states.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct WorkflowStatesQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<WorkflowStateFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
}
impl<'a> WorkflowStatesQueryBuilder<'a> {
    pub fn filter(mut self, value: WorkflowStateFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<WorkflowState>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                WorkflowState,
            >(
                "query WorkflowStates($filter: WorkflowStateFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy) { workflowStates(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy) { nodes { id createdAt updatedAt archivedAt name color description position type team { id name key color displayName } inheritedFrom { id name color type } } pageInfo { hasNextPage endCursor } } }",
                variables,
                "workflowStates",
            )
            .await
    }
}
/// Query builder: All users for the organization.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct UsersQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<UserFilter>,
    include_disabled: Option<bool>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    sort: Option<UserSortInput>,
}
impl<'a> UsersQueryBuilder<'a> {
    pub fn filter(mut self, value: UserFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn include_disabled(mut self, value: bool) -> Self {
        self.include_disabled = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn sort(mut self, value: UserSortInput) -> Self {
        self.sort = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<User>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_disabled {
            map.insert("includeDisabled".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.sort {
            map.insert("sort".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                User,
            >(
                "query Users($filter: UserFilter, $includeDisabled: Boolean, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $sort: [UserSortInput!]) { users(filter: $filter, includeDisabled: $includeDisabled, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, sort: $sort) { nodes { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone organization { id name } lastSeen identityProvider { id type } initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } pageInfo { hasNextPage endCursor } } }",
                variables,
                "users",
            )
            .await
    }
}
/// Query builder: All projects.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct ProjectsQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<ProjectFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    sort: Option<ProjectSortInput>,
}
impl<'a> ProjectsQueryBuilder<'a> {
    pub fn filter(mut self, value: ProjectFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn sort(mut self, value: ProjectSortInput) -> Self {
        self.sort = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Project>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.sort {
            map.insert("sort".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                Project,
            >(
                "query Projects($filter: ProjectFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $sort: [ProjectSortInput!]) { projects(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, sort: $sort) { nodes { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color status { id name color type } creator { id name displayName email url } lead { id name displayName email url } facets { id } projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder convertedFromIssue { id number title identifier url } lastAppliedTemplate { id type name } priority lastUpdate { id url } health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds favorite { id type url title color } url progress scope integrationsSettings { id } content contentState documentContent { id } state priorityLabel } pageInfo { hasNextPage endCursor } } }",
                variables,
                "projects",
            )
            .await
    }
}
/// Query builder: All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct TeamsQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<TeamFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
}
impl<'a> TeamsQueryBuilder<'a> {
    pub fn filter(mut self, value: TeamFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Team>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                Team,
            >(
                "query Teams($filter: TeamFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy) { teams(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy) { nodes { id createdAt updatedAt archivedAt name key description icon color retiredAt organization { id name } parent { id name key color displayName } children { id name key color displayName } cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultIssueState { id name color type } defaultTemplateForMembers { id type name } defaultTemplateForMembersId defaultTemplateForNonMembers { id type name } defaultTemplateForNonMembersId defaultProjectTemplate { id type name } triageIssueState { id name color type } private allMembersCanJoin securitySettings facets { id } posts { id title type } scimManaged scimGroupName progressHistory currentProgress draftWorkflowState { id name color type } startWorkflowState { id name color type } reviewWorkflowState { id name color type } mergeableWorkflowState { id name color type } mergeWorkflowState { id name color type } groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues markedAsDuplicateWorkflowState { id name color type } joinByDefault cycleCalenderUrl displayName issueCount activeCycle { id number name } triageResponsibility { id } integrationsSettings { id } issueSortOrderDefaultToBottom inviteHash } pageInfo { hasNextPage endCursor } } }",
                variables,
                "teams",
            )
            .await
    }
}
/// Query builder: Search issues.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct SearchIssuesQueryBuilder<'a> {
    client: &'a Client,
    term: String,
    filter: Option<IssueFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    include_comments: Option<bool>,
    team_id: Option<String>,
}
impl<'a> SearchIssuesQueryBuilder<'a> {
    pub fn filter(mut self, value: IssueFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn include_comments(mut self, value: bool) -> Self {
        self.include_comments = Some(value);
        self
    }
    pub fn team_id(mut self, value: impl Into<String>) -> Self {
        self.team_id = Some(value.into());
        self
    }
    pub async fn send(self) -> Result<Connection<Issue>, LinearError> {
        let mut map = serde_json::Map::new();
        map.insert("term".to_string(), serde_json::json!(self.term));
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_comments {
            map.insert("includeComments".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.team_id {
            map.insert("teamId".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                Issue,
            >(
                "query SearchIssues($filter: IssueFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $term: String!, $includeComments: Boolean, $teamId: String) { searchIssues(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, term: $term, includeComments: $includeComments, teamId: $teamId) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary summary { id } labelIds team { id name key color displayName } cycle { id number name } project { id name color url } projectMilestone { id name } lastAppliedTemplate { id type name } recurringIssueTemplate { id type name } previousIdentifiers creator { id name displayName email url } externalUserCreator { id name displayName email } assignee { id name displayName email url } delegate { id name displayName email url } snoozedBy { id name displayName email url } state { id name color type } subIssueSortOrder reactionData priorityLabel sourceComment { id url } integrationSourceType botActor { id type name } favorite { id type url title color } identifier url branchName customerTicketCount parent { id number title identifier url } description documentContent { id } reactions { id } syncedWith { id } asksRequester { id name displayName email url } asksExternalUserRequester { id name displayName email } } pageInfo { hasNextPage endCursor } } }",
                variables,
                "searchIssues",
            )
            .await
    }
}
/// Query builder: All issues.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct IssuesQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<IssueFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    sort: Option<IssueSortInput>,
}
impl<'a> IssuesQueryBuilder<'a> {
    pub fn filter(mut self, value: IssueFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn sort(mut self, value: IssueSortInput) -> Self {
        self.sort = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Issue>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.sort {
            map.insert("sort".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                Issue,
            >(
                "query Issues($filter: IssueFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $sort: [IssueSortInput!]) { issues(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, sort: $sort) { nodes { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary summary { id } labelIds team { id name key color displayName } cycle { id number name } project { id name color url } projectMilestone { id name } lastAppliedTemplate { id type name } recurringIssueTemplate { id type name } previousIdentifiers creator { id name displayName email url } externalUserCreator { id name displayName email } assignee { id name displayName email url } delegate { id name displayName email url } snoozedBy { id name displayName email url } state { id name color type } subIssueSortOrder reactionData priorityLabel sourceComment { id url } integrationSourceType botActor { id type name } favorite { id type url title color } identifier url branchName customerTicketCount parent { id number title identifier url } description documentContent { id } reactions { id } syncedWith { id } asksRequester { id name displayName email url } asksExternalUserRequester { id name displayName email } } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issues",
            )
            .await
    }
}
/// Query builder: All issue relationships.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct IssueRelationsQueryBuilder<'a> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
}
impl<'a> IssueRelationsQueryBuilder<'a> {
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<IssueRelation>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                IssueRelation,
            >(
                "query IssueRelations($before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy) { issueRelations(before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy) { nodes { id createdAt updatedAt archivedAt type issue { id number title identifier url } relatedIssue { id number title identifier url } } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issueRelations",
            )
            .await
    }
}
/// Query builder: All issue labels.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct IssueLabelsQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<IssueLabelFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
}
impl<'a> IssueLabelsQueryBuilder<'a> {
    pub fn filter(mut self, value: IssueLabelFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<IssueLabel>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                IssueLabel,
            >(
                "query IssueLabels($filter: IssueLabelFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy) { issueLabels(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy) { nodes { id createdAt updatedAt archivedAt name description color isGroup lastAppliedAt retiredAt organization { id name } team { id name key color displayName } creator { id name displayName email url } retiredBy { id name displayName email url } parent { id name color } inheritedFrom { id name color } } pageInfo { hasNextPage endCursor } } }",
                variables,
                "issueLabels",
            )
            .await
    }
}
/// Query builder: All documents in the workspace.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct DocumentsQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<DocumentFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
}
impl<'a> DocumentsQueryBuilder<'a> {
    pub fn filter(mut self, value: DocumentFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Document>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                Document,
            >(
                "query Documents($filter: DocumentFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy) { documents(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy) { nodes { id createdAt updatedAt archivedAt title icon color creator { id name displayName email url } updatedBy { id name displayName email url } project { id name color url } initiative { id name color url } team { id name key color displayName } issue { id number title identifier url } release { id name url } cycle { id number name } slugId lastAppliedTemplate { id type name } hiddenAt trashed sortOrder content contentState documentContentId url } pageInfo { hasNextPage endCursor } } }",
                variables,
                "documents",
            )
            .await
    }
}
/// Query builder: All cycles.
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct CyclesQueryBuilder<'a> {
    client: &'a Client,
    filter: Option<CycleFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
}
impl<'a> CyclesQueryBuilder<'a> {
    pub fn filter(mut self, value: CycleFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<Cycle>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        self.client
            .execute_connection::<
                Cycle,
            >(
                "query Cycles($filter: CycleFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy) { cycles(filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy) { nodes { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory team { id name key color displayName } progressHistory currentProgress inheritedFrom { id number name } isActive isFuture isPast progress isNext isPrevious } pageInfo { hasNextPage endCursor } } }",
                variables,
                "cycles",
            )
            .await
    }
}
/// All issue workflow states.
pub fn workflow_states<'a>(client: &'a Client) -> WorkflowStatesQueryBuilder<'a> {
    WorkflowStatesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
    }
}
/// All users for the organization.
pub fn users<'a>(client: &'a Client) -> UsersQueryBuilder<'a> {
    UsersQueryBuilder {
        client,
        filter: None,
        include_disabled: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        sort: None,
    }
}
/// The currently authenticated user.
pub async fn whoami(client: &Client) -> Result<User, LinearError> {
    let variables = serde_json::json!({});
    client
        .execute::<
            User,
        >(
            "query Viewer { viewer { id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId } }",
            variables,
            "viewer",
        )
        .await
}
/// All projects.
pub fn projects<'a>(client: &'a Client) -> ProjectsQueryBuilder<'a> {
    ProjectsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        sort: None,
    }
}
/// One specific project.
pub async fn project(client: &Client, id: String) -> Result<Project, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            Project,
        >(
            "query Project($id: String!) { project(id: $id) { id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color status { id name color type } creator { id name displayName email url } lead { id name displayName email url } facets { id } projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder convertedFromIssue { id number title identifier url } lastAppliedTemplate { id type name } priority lastUpdate { id url } health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds favorite { id type url title color } url initiatives { nodes { id name organization { id } creator { id } owner { id } color facets { id } lastUpdate { id } url integrationsSettings { id } parentInitiative { id } documentContent { id } } } initiativeToProjects { nodes { id project { id } initiative { id } } } teams { nodes { id name key color organization { id } parent { id } children { id } defaultIssueState { id } defaultTemplateForMembers { id } defaultTemplateForNonMembers { id } defaultProjectTemplate { id } triageIssueState { id } facets { id } posts { id } draftWorkflowState { id } startWorkflowState { id } reviewWorkflowState { id } mergeableWorkflowState { id } mergeWorkflowState { id } markedAsDuplicateWorkflowState { id } displayName activeCycle { id } triageResponsibility { id } integrationsSettings { id } } } members { nodes { id name displayName email organization { id } identityProvider { id } url } } projectUpdates { nodes { id project { id } user { id } url reactions { id } } } documents { nodes { id title color creator { id } updatedBy { id } project { id } initiative { id } team { id } issue { id } release { id } cycle { id } lastAppliedTemplate { id } url } } projectMilestones { nodes { id name documentContent { id } project { id } } } issues { nodes { id number title summary { id } team { id } cycle { id } project { id } projectMilestone { id } lastAppliedTemplate { id } recurringIssueTemplate { id } creator { id } externalUserCreator { id } assignee { id } delegate { id } snoozedBy { id } state { id } sourceComment { id } botActor { id } favorite { id } identifier url parent { id } documentContent { id } reactions { id } syncedWith { id } asksRequester { id } asksExternalUserRequester { id } } } externalLinks { nodes { id url creator { id } initiative { id } } } attachments { nodes { id title url creator { id } } } history { nodes { id project { id } } } labels { nodes { id name color organization { id } creator { id } retiredBy { id } parent { id } } } progress scope integrationsSettings { id } content contentState documentContent { id } comments { nodes { id issue { id } documentContent { id } projectUpdate { id } initiativeUpdate { id } post { id } parent { id } resolvingUser { id } resolvingComment { id } user { id } externalUser { id } url agentSession { id } botActor { id } onBehalfOf { id } externalThread { id } reactions { id } syncedWith { id } } } relations { nodes { id type project { id } projectMilestone { id } relatedProject { id } relatedProjectMilestone { id } user { id } } } inverseRelations { nodes { id type project { id } projectMilestone { id } relatedProject { id } relatedProjectMilestone { id } user { id } } } needs { nodes { id customer { id } issue { id } project { id } comment { id } attachment { id } projectAttachment { id } creator { id } originalIssue { id } url } } state priorityLabel } }",
            variables,
            "project",
        )
        .await
}
/// All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
pub fn teams<'a>(client: &'a Client) -> TeamsQueryBuilder<'a> {
    TeamsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
    }
}
/// One specific team.
pub async fn team(client: &Client, id: String) -> Result<Team, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            Team,
        >(
            "query Team($id: String!) { team(id: $id) { id createdAt updatedAt archivedAt name key description icon color retiredAt organization { id name } parent { id name key color displayName } children { id name key color displayName } cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultIssueState { id name color type } defaultTemplateForMembers { id type name } defaultTemplateForMembersId defaultTemplateForNonMembers { id type name } defaultTemplateForNonMembersId defaultProjectTemplate { id type name } triageIssueState { id name color type } private allMembersCanJoin securitySettings facets { id } posts { id title type } scimManaged scimGroupName progressHistory currentProgress draftWorkflowState { id name color type } startWorkflowState { id name color type } reviewWorkflowState { id name color type } mergeableWorkflowState { id name color type } mergeWorkflowState { id name color type } groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues markedAsDuplicateWorkflowState { id name color type } joinByDefault cycleCalenderUrl displayName issues { nodes { id number title summary { id } team { id } cycle { id } project { id } projectMilestone { id } lastAppliedTemplate { id } recurringIssueTemplate { id } creator { id } externalUserCreator { id } assignee { id } delegate { id } snoozedBy { id } state { id } sourceComment { id } botActor { id } favorite { id } identifier url parent { id } documentContent { id } reactions { id } syncedWith { id } asksRequester { id } asksExternalUserRequester { id } } } issueCount cycles { nodes { id number name team { id } inheritedFrom { id } } } activeCycle { id number name } triageResponsibility { id } members { nodes { id name displayName email organization { id } identityProvider { id } url } } memberships { nodes { id user { id } team { id } } } projects { nodes { id name color status { id } creator { id } lead { id } facets { id } convertedFromIssue { id } lastAppliedTemplate { id } lastUpdate { id } favorite { id } url integrationsSettings { id } documentContent { id } } } states { nodes { id name color type team { id } inheritedFrom { id } } } gitAutomationStates { nodes { id state { id } team { id } targetBranch { id } } } templates { nodes { id type name organization { id } team { id } creator { id } lastUpdatedBy { id } inheritedFrom { id } } } labels { nodes { id name color organization { id } team { id } creator { id } retiredBy { id } parent { id } inheritedFrom { id } } } webhooks { nodes { id url team { id } creator { id } failures { id } } } integrationsSettings { id } issueSortOrderDefaultToBottom inviteHash } }",
            variables,
            "team",
        )
        .await
}
/// Search issues.
pub fn search_issues<'a>(
    client: &'a Client,
    term: impl Into<String>,
) -> SearchIssuesQueryBuilder<'a> {
    SearchIssuesQueryBuilder {
        client,
        term: term.into(),
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        include_comments: None,
        team_id: None,
    }
}
/// All issues.
pub fn issues<'a>(client: &'a Client) -> IssuesQueryBuilder<'a> {
    IssuesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        sort: None,
    }
}
/// One specific issue.
pub async fn issue(client: &Client, id: String) -> Result<Issue, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            Issue,
        >(
            "query Issue($id: String!) { issue(id: $id) { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary summary { id } labelIds team { id name key color displayName } cycle { id number name } project { id name color url } projectMilestone { id name } lastAppliedTemplate { id type name } recurringIssueTemplate { id type name } previousIdentifiers creator { id name displayName email url } externalUserCreator { id name displayName email } assignee { id name displayName email url } delegate { id name displayName email url } snoozedBy { id name displayName email url } state { id name color type } subIssueSortOrder reactionData priorityLabel sourceComment { id url } integrationSourceType documents { nodes { id title color creator { id } updatedBy { id } project { id } initiative { id } team { id } issue { id } release { id } cycle { id } lastAppliedTemplate { id } url } } botActor { id type name } favorite { id type url title color } identifier url branchName customerTicketCount subscribers { nodes { id name displayName email organization { id } identityProvider { id } url } } parent { id number title identifier url } children { nodes { id number title summary { id } team { id } cycle { id } project { id } projectMilestone { id } lastAppliedTemplate { id } recurringIssueTemplate { id } creator { id } externalUserCreator { id } assignee { id } delegate { id } snoozedBy { id } state { id } sourceComment { id } botActor { id } favorite { id } identifier url parent { id } documentContent { id } reactions { id } syncedWith { id } asksRequester { id } asksExternalUserRequester { id } } } comments { nodes { id issue { id } documentContent { id } projectUpdate { id } initiativeUpdate { id } post { id } parent { id } resolvingUser { id } resolvingComment { id } user { id } externalUser { id } url agentSession { id } botActor { id } onBehalfOf { id } externalThread { id } reactions { id } syncedWith { id } } } history { nodes { id issue { id } actor { id } actors { id } descriptionUpdatedBy { id } fromAssignee { id } toAssignee { id } fromCycle { id } toCycle { id } toConvertedProject { id } fromDelegate { id } toDelegate { id } fromProject { id } toProject { id } fromState { id } toState { id } fromTeam { id } toTeam { id } fromParent { id } toParent { id } attachment { id } issueImport { id } triageResponsibilityNotifiedUsers { id } triageResponsibilityTeam { id } fromProjectMilestone { id } toProjectMilestone { id } botActor { id } addedLabels { id } removedLabels { id } addedToReleases { id } removedFromReleases { id } } } labels { nodes { id name color organization { id } team { id } creator { id } retiredBy { id } parent { id } inheritedFrom { id } } } relations { nodes { id type issue { id } relatedIssue { id } } } inverseRelations { nodes { id type issue { id } relatedIssue { id } } } attachments { nodes { id title url creator { id } externalUserCreator { id } originalIssue { id } issue { id } } } formerAttachments { nodes { id title url creator { id } externalUserCreator { id } originalIssue { id } issue { id } } } description documentContent { id } reactions { id } needs { nodes { id customer { id } issue { id } project { id } comment { id } attachment { id } projectAttachment { id } creator { id } originalIssue { id } url } } formerNeeds { nodes { id customer { id } issue { id } project { id } comment { id } attachment { id } projectAttachment { id } creator { id } originalIssue { id } url } } syncedWith { id } suggestions { nodes { id issue { id } type suggestedIssue { id } suggestedTeam { id } suggestedProject { id } suggestedUser { id } suggestedLabel { id } } } incomingSuggestions { nodes { id issue { id } type suggestedIssue { id } suggestedTeam { id } suggestedProject { id } suggestedUser { id } suggestedLabel { id } } } asksRequester { id name displayName email url } asksExternalUserRequester { id name displayName email } stateHistory { nodes { id state { id } } } } }",
            variables,
            "issue",
        )
        .await
}
/// All issue relationships.
pub fn issue_relations<'a>(client: &'a Client) -> IssueRelationsQueryBuilder<'a> {
    IssueRelationsQueryBuilder {
        client,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
    }
}
/// One specific issue relation.
pub async fn issue_relation(client: &Client, id: String) -> Result<IssueRelation, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            IssueRelation,
        >(
            "query IssueRelation($id: String!) { issueRelation(id: $id) { id createdAt updatedAt archivedAt type issue { id number title identifier url } relatedIssue { id number title identifier url } } }",
            variables,
            "issueRelation",
        )
        .await
}
/// All issue labels.
pub fn issue_labels<'a>(client: &'a Client) -> IssueLabelsQueryBuilder<'a> {
    IssueLabelsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
    }
}
/// All documents in the workspace.
pub fn documents<'a>(client: &'a Client) -> DocumentsQueryBuilder<'a> {
    DocumentsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
    }
}
/// One specific document.
pub async fn document(client: &Client, id: String) -> Result<Document, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            Document,
        >(
            "query Document($id: String!) { document(id: $id) { id createdAt updatedAt archivedAt title icon color creator { id name displayName email url } updatedBy { id name displayName email url } project { id name color url } initiative { id name color url } team { id name key color displayName } issue { id number title identifier url } release { id name url } cycle { id number name } slugId lastAppliedTemplate { id type name } hiddenAt trashed sortOrder comments { nodes { id issue { id } documentContent { id } projectUpdate { id } initiativeUpdate { id } post { id } parent { id } resolvingUser { id } resolvingComment { id } user { id } externalUser { id } url agentSession { id } botActor { id } onBehalfOf { id } externalThread { id } reactions { id } syncedWith { id } } } content contentState documentContentId url } }",
            variables,
            "document",
        )
        .await
}
/// All cycles.
pub fn cycles<'a>(client: &'a Client) -> CyclesQueryBuilder<'a> {
    CyclesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
    }
}
/// One specific cycle.
pub async fn cycle(client: &Client, id: String) -> Result<Cycle, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            Cycle,
        >(
            "query Cycle($id: String!) { cycle(id: $id) { id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory team { id name key color displayName } progressHistory currentProgress inheritedFrom { id number name } isActive isFuture isPast issues { nodes { id number title summary { id } team { id } cycle { id } project { id } projectMilestone { id } lastAppliedTemplate { id } recurringIssueTemplate { id } creator { id } externalUserCreator { id } assignee { id } delegate { id } snoozedBy { id } state { id } sourceComment { id } botActor { id } favorite { id } identifier url parent { id } documentContent { id } reactions { id } syncedWith { id } asksRequester { id } asksExternalUserRequester { id } } } uncompletedIssuesUponClose { nodes { id number title summary { id } team { id } cycle { id } project { id } projectMilestone { id } lastAppliedTemplate { id } recurringIssueTemplate { id } creator { id } externalUserCreator { id } assignee { id } delegate { id } snoozedBy { id } state { id } sourceComment { id } botActor { id } favorite { id } identifier url parent { id } documentContent { id } reactions { id } syncedWith { id } asksRequester { id } asksExternalUserRequester { id } } } progress isNext isPrevious documents { nodes { id title color creator { id } updatedBy { id } project { id } initiative { id } team { id } issue { id } release { id } cycle { id } lastAppliedTemplate { id } url } } links { nodes { id url creator { id } initiative { id } } } } }",
            variables,
            "cycle",
        )
        .await
}
