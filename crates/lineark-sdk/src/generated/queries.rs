//! Generated query functions and builder types.
//!
//! All query functions are generic over `T: DeserializeOwned + GraphQLFields`.
//! Pass the generated type for full-schema queries, or define your own
//! lean struct for zero-overfetch.
//!
//! Generated by lineark-codegen â€” do not edit.
use super::enums::*;
use super::inputs::*;
use crate::client::Client;
use crate::error::LinearError;
use crate::field_selection::GraphQLFields;
use crate::pagination::Connection;
use serde::de::DeserializeOwned;
/// Query builder: All issue workflow states.
///
/// Full type: [`WorkflowState`](super::types::WorkflowState)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct WorkflowStatesQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<WorkflowStateFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::WorkflowState>>
    WorkflowStatesQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: WorkflowStateFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "WorkflowStates",
            "$filter: WorkflowStateFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "workflowStates",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "workflowStates")
            .await
    }
}
/// Query builder: All users for the organization.
///
/// Full type: [`User`](super::types::User)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct UsersQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<UserFilter>,
    include_disabled: Option<bool>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    sort: Option<UserSortInput>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::User>>
    UsersQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: UserFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn include_disabled(mut self, value: bool) -> Self {
        self.include_disabled = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn sort(mut self, value: UserSortInput) -> Self {
        self.sort = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_disabled {
            map.insert("includeDisabled".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.sort {
            map.insert("sort".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "Users",
            "$filter: UserFilter, $includeDisabled: Boolean, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $sort: [UserSortInput!]",
            "users",
            "filter: $filter, includeDisabled: $includeDisabled, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, sort: $sort",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "users")
            .await
    }
}
/// Query builder: All projects.
///
/// Full type: [`Project`](super::types::Project)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct ProjectsQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<ProjectFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    sort: Option<ProjectSortInput>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::Project>>
    ProjectsQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: ProjectFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn sort(mut self, value: ProjectSortInput) -> Self {
        self.sort = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.sort {
            map.insert("sort".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "Projects",
            "$filter: ProjectFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $sort: [ProjectSortInput!]",
            "projects",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, sort: $sort",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "projects")
            .await
    }
}
/// Query builder: All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
///
/// Full type: [`Team`](super::types::Team)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct TeamsQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<TeamFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::Team>>
    TeamsQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: TeamFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "Teams",
            "$filter: TeamFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "teams",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "teams")
            .await
    }
}
/// Query builder: Search issues.
///
/// Full type: [`IssueSearchResult`](super::types::IssueSearchResult)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct SearchIssuesQueryBuilder<'a, T> {
    client: &'a Client,
    term: String,
    filter: Option<IssueFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    include_comments: Option<bool>,
    team_id: Option<String>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::IssueSearchResult>>
    SearchIssuesQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: IssueFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn include_comments(mut self, value: bool) -> Self {
        self.include_comments = Some(value);
        self
    }
    pub fn team_id(mut self, value: impl Into<String>) -> Self {
        self.team_id = Some(value.into());
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        map.insert("term".to_string(), serde_json::json!(self.term));
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_comments {
            map.insert("includeComments".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.team_id {
            map.insert("teamId".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "SearchIssues",
            "$filter: IssueFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $term: String!, $includeComments: Boolean, $teamId: String",
            "searchIssues",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, term: $term, includeComments: $includeComments, teamId: $teamId",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "searchIssues")
            .await
    }
}
/// Query builder: All milestones for the project.
///
/// Full type: [`ProjectMilestone`](super::types::ProjectMilestone)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct ProjectMilestonesQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<ProjectMilestoneFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::ProjectMilestone>>
    ProjectMilestonesQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: ProjectMilestoneFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "ProjectMilestones",
            "$filter: ProjectMilestoneFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "projectMilestones",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "projectMilestones")
            .await
    }
}
/// Query builder: All issues.
///
/// Full type: [`Issue`](super::types::Issue)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct IssuesQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<IssueFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    sort: Option<IssueSortInput>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::Issue>>
    IssuesQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: IssueFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub fn sort(mut self, value: IssueSortInput) -> Self {
        self.sort = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.sort {
            map.insert("sort".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "Issues",
            "$filter: IssueFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy, $sort: [IssueSortInput!]",
            "issues",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy, sort: $sort",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "issues")
            .await
    }
}
/// Query builder: All issue relationships.
///
/// Full type: [`IssueRelation`](super::types::IssueRelation)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct IssueRelationsQueryBuilder<'a, T> {
    client: &'a Client,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::IssueRelation>>
    IssueRelationsQueryBuilder<'a, T>
{
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "IssueRelations",
            "$before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "issueRelations",
            "before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "issueRelations")
            .await
    }
}
/// Query builder: All issue labels.
///
/// Full type: [`IssueLabel`](super::types::IssueLabel)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct IssueLabelsQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<IssueLabelFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::IssueLabel>>
    IssueLabelsQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: IssueLabelFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "IssueLabels",
            "$filter: IssueLabelFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "issueLabels",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "issueLabels")
            .await
    }
}
/// Query builder: All documents in the workspace.
///
/// Full type: [`Document`](super::types::Document)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct DocumentsQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<DocumentFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::Document>>
    DocumentsQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: DocumentFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "Documents",
            "$filter: DocumentFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "documents",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "documents")
            .await
    }
}
/// Query builder: All cycles.
///
/// Full type: [`Cycle`](super::types::Cycle)
///
/// Use setter methods to configure optional parameters, then call
/// [`.send()`](Self::send) to execute the query.
#[must_use]
pub struct CyclesQueryBuilder<'a, T> {
    client: &'a Client,
    filter: Option<CycleFilter>,
    before: Option<String>,
    after: Option<String>,
    first: Option<i64>,
    last: Option<i64>,
    include_archived: Option<bool>,
    order_by: Option<PaginationOrderBy>,
    _marker: std::marker::PhantomData<T>,
}
impl<'a, T: DeserializeOwned + GraphQLFields<FullType = super::types::Cycle>>
    CyclesQueryBuilder<'a, T>
{
    pub fn filter(mut self, value: CycleFilter) -> Self {
        self.filter = Some(value);
        self
    }
    pub fn before(mut self, value: impl Into<String>) -> Self {
        self.before = Some(value.into());
        self
    }
    pub fn after(mut self, value: impl Into<String>) -> Self {
        self.after = Some(value.into());
        self
    }
    pub fn first(mut self, value: i64) -> Self {
        self.first = Some(value);
        self
    }
    pub fn last(mut self, value: i64) -> Self {
        self.last = Some(value);
        self
    }
    pub fn include_archived(mut self, value: bool) -> Self {
        self.include_archived = Some(value);
        self
    }
    pub fn order_by(mut self, value: PaginationOrderBy) -> Self {
        self.order_by = Some(value);
        self
    }
    pub async fn send(self) -> Result<Connection<T>, LinearError> {
        let mut map = serde_json::Map::new();
        if let Some(ref v) = self.filter {
            map.insert("filter".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.before {
            map.insert("before".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.after {
            map.insert("after".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.first {
            map.insert("first".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.last {
            map.insert("last".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.include_archived {
            map.insert("includeArchived".to_string(), serde_json::json!(v));
        }
        if let Some(ref v) = self.order_by {
            map.insert("orderBy".to_string(), serde_json::json!(v));
        }
        let variables = serde_json::Value::Object(map);
        let selection = T::selection();
        let query = format!(
            "query {}({}) {{ {}({}) {{ nodes {{ {} }} pageInfo {{ hasNextPage endCursor }} }} }}",
            "Cycles",
            "$filter: CycleFilter, $before: String, $after: String, $first: Int, $last: Int, $includeArchived: Boolean, $orderBy: PaginationOrderBy",
            "cycles",
            "filter: $filter, before: $before, after: $after, first: $first, last: $last, includeArchived: $includeArchived, orderBy: $orderBy",
            selection
        );
        self.client
            .execute_connection::<T>(&query, variables, "cycles")
            .await
    }
}
/// All issue workflow states.
///
/// Full type: [`WorkflowState`](super::types::WorkflowState)
pub fn workflow_states<'a, T>(client: &'a Client) -> WorkflowStatesQueryBuilder<'a, T> {
    WorkflowStatesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// All users for the organization.
///
/// Full type: [`User`](super::types::User)
pub fn users<'a, T>(client: &'a Client) -> UsersQueryBuilder<'a, T> {
    UsersQueryBuilder {
        client,
        filter: None,
        include_disabled: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        sort: None,
        _marker: std::marker::PhantomData,
    }
}
/// The currently authenticated user.
///
/// Full type: [`User`](super::types::User)
pub async fn whoami<T: DeserializeOwned + GraphQLFields<FullType = super::types::User>>(
    client: &Client,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({});
    let selection = T::selection();
    let query = format!("query {} {{ {} {{ {} }} }}", "Viewer", "viewer", selection);
    client.execute::<T>(&query, variables, "viewer").await
}
/// All projects.
///
/// Full type: [`Project`](super::types::Project)
pub fn projects<'a, T>(client: &'a Client) -> ProjectsQueryBuilder<'a, T> {
    ProjectsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        sort: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific project.
///
/// Full type: [`Project`](super::types::Project)
pub async fn project<T: DeserializeOwned + GraphQLFields<FullType = super::types::Project>>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "Project", "$id: String!", "project", "id: $id", selection
    );
    client.execute::<T>(&query, variables, "project").await
}
/// All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
///
/// Full type: [`Team`](super::types::Team)
pub fn teams<'a, T>(client: &'a Client) -> TeamsQueryBuilder<'a, T> {
    TeamsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific team.
///
/// Full type: [`Team`](super::types::Team)
pub async fn team<T: DeserializeOwned + GraphQLFields<FullType = super::types::Team>>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "Team", "$id: String!", "team", "id: $id", selection
    );
    client.execute::<T>(&query, variables, "team").await
}
/// Search issues.
///
/// Full type: [`IssueSearchResult`](super::types::IssueSearchResult)
pub fn search_issues<'a, T>(
    client: &'a Client,
    term: impl Into<String>,
) -> SearchIssuesQueryBuilder<'a, T> {
    SearchIssuesQueryBuilder {
        client,
        term: term.into(),
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        include_comments: None,
        team_id: None,
        _marker: std::marker::PhantomData,
    }
}
/// All milestones for the project.
///
/// Full type: [`ProjectMilestone`](super::types::ProjectMilestone)
pub fn project_milestones<'a, T>(client: &'a Client) -> ProjectMilestonesQueryBuilder<'a, T> {
    ProjectMilestonesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific project milestone.
///
/// Full type: [`ProjectMilestone`](super::types::ProjectMilestone)
pub async fn project_milestone<
    T: DeserializeOwned + GraphQLFields<FullType = super::types::ProjectMilestone>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "ProjectMilestone", "$id: String!", "projectMilestone", "id: $id", selection
    );
    client
        .execute::<T>(&query, variables, "projectMilestone")
        .await
}
/// All issues.
///
/// Full type: [`Issue`](super::types::Issue)
pub fn issues<'a, T>(client: &'a Client) -> IssuesQueryBuilder<'a, T> {
    IssuesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        sort: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue<T: DeserializeOwned + GraphQLFields<FullType = super::types::Issue>>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "Issue", "$id: String!", "issue", "id: $id", selection
    );
    client.execute::<T>(&query, variables, "issue").await
}
/// All issue relationships.
///
/// Full type: [`IssueRelation`](super::types::IssueRelation)
pub fn issue_relations<'a, T>(client: &'a Client) -> IssueRelationsQueryBuilder<'a, T> {
    IssueRelationsQueryBuilder {
        client,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific issue relation.
///
/// Full type: [`IssueRelation`](super::types::IssueRelation)
pub async fn issue_relation<
    T: DeserializeOwned + GraphQLFields<FullType = super::types::IssueRelation>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "IssueRelation", "$id: String!", "issueRelation", "id: $id", selection
    );
    client
        .execute::<T>(&query, variables, "issueRelation")
        .await
}
/// All issue labels.
///
/// Full type: [`IssueLabel`](super::types::IssueLabel)
pub fn issue_labels<'a, T>(client: &'a Client) -> IssueLabelsQueryBuilder<'a, T> {
    IssueLabelsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// All documents in the workspace.
///
/// Full type: [`Document`](super::types::Document)
pub fn documents<'a, T>(client: &'a Client) -> DocumentsQueryBuilder<'a, T> {
    DocumentsQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document<T: DeserializeOwned + GraphQLFields<FullType = super::types::Document>>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "Document", "$id: String!", "document", "id: $id", selection
    );
    client.execute::<T>(&query, variables, "document").await
}
/// All cycles.
///
/// Full type: [`Cycle`](super::types::Cycle)
pub fn cycles<'a, T>(client: &'a Client) -> CyclesQueryBuilder<'a, T> {
    CyclesQueryBuilder {
        client,
        filter: None,
        before: None,
        after: None,
        first: None,
        last: None,
        include_archived: None,
        order_by: None,
        _marker: std::marker::PhantomData,
    }
}
/// One specific cycle.
///
/// Full type: [`Cycle`](super::types::Cycle)
pub async fn cycle<T: DeserializeOwned + GraphQLFields<FullType = super::types::Cycle>>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let selection = T::selection();
    let query = format!(
        "query {}({}) {{ {}({}) {{ {} }} }}",
        "Cycle", "$id: String!", "cycle", "id: $id", selection
    );
    client.execute::<T>(&query, variables, "cycle").await
}
