//! Generated `impl Client` delegation methods.
//!
//! This module provides thin wrapper methods on [`Client`] that
//! delegate to the standalone functions in [`queries`](super::queries) and
//! [`mutations`](super::mutations).
//!
//! Generated by lineark-codegen â€” do not edit.
#![allow(clippy::too_many_arguments)]
use super::inputs::*;
use super::queries::*;
use super::types::*;
use crate::client::Client;
use crate::error::LinearError;
impl Client {
    /// All issue workflow states.
    pub fn workflow_states(&self) -> WorkflowStatesQueryBuilder<'_> {
        crate::generated::queries::workflow_states(self)
    }
    /// All users for the organization.
    pub fn users(&self) -> UsersQueryBuilder<'_> {
        crate::generated::queries::users(self)
    }
    /// The currently authenticated user.
    pub async fn whoami(&self) -> Result<User, LinearError> {
        crate::generated::queries::whoami(self).await
    }
    /// All projects.
    pub fn projects(&self) -> ProjectsQueryBuilder<'_> {
        crate::generated::queries::projects(self)
    }
    /// One specific project.
    pub async fn project(&self, id: String) -> Result<Project, LinearError> {
        crate::generated::queries::project(self, id).await
    }
    /// All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
    pub fn teams(&self) -> TeamsQueryBuilder<'_> {
        crate::generated::queries::teams(self)
    }
    /// One specific team.
    pub async fn team(&self, id: String) -> Result<Team, LinearError> {
        crate::generated::queries::team(self, id).await
    }
    /// Search issues.
    pub fn search_issues(&self, term: impl Into<String>) -> SearchIssuesQueryBuilder<'_> {
        crate::generated::queries::search_issues(self, term)
    }
    /// All issues.
    pub fn issues(&self) -> IssuesQueryBuilder<'_> {
        crate::generated::queries::issues(self)
    }
    /// One specific issue.
    pub async fn issue(&self, id: String) -> Result<Issue, LinearError> {
        crate::generated::queries::issue(self, id).await
    }
    /// All issue relationships.
    pub fn issue_relations(&self) -> IssueRelationsQueryBuilder<'_> {
        crate::generated::queries::issue_relations(self)
    }
    /// One specific issue relation.
    pub async fn issue_relation(&self, id: String) -> Result<IssueRelation, LinearError> {
        crate::generated::queries::issue_relation(self, id).await
    }
    /// All issue labels.
    pub fn issue_labels(&self) -> IssueLabelsQueryBuilder<'_> {
        crate::generated::queries::issue_labels(self)
    }
    /// All documents in the workspace.
    pub fn documents(&self) -> DocumentsQueryBuilder<'_> {
        crate::generated::queries::documents(self)
    }
    /// One specific document.
    pub async fn document(&self, id: String) -> Result<Document, LinearError> {
        crate::generated::queries::document(self, id).await
    }
    /// All cycles.
    pub fn cycles(&self) -> CyclesQueryBuilder<'_> {
        crate::generated::queries::cycles(self)
    }
    /// One specific cycle.
    pub async fn cycle(&self, id: String) -> Result<Cycle, LinearError> {
        crate::generated::queries::cycle(self, id).await
    }
    /// XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
    pub async fn file_upload(
        &self,
        meta_data: Option<serde_json::Value>,
        make_public: Option<bool>,
        size: i64,
        content_type: String,
        filename: String,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::file_upload(
            self,
            meta_data,
            make_public,
            size,
            content_type,
            filename,
        )
        .await
    }
    /// Upload an image from an URL to Linear.
    pub async fn image_upload_from_url(
        &self,
        url: String,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::image_upload_from_url(self, url).await
    }
    /// Creates a new issue.
    pub async fn issue_create(
        &self,
        input: IssueCreateInput,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::issue_create(self, input).await
    }
    /// Updates an issue.
    pub async fn issue_update(
        &self,
        input: IssueUpdateInput,
        id: String,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::issue_update(self, input, id).await
    }
    /// Archives an issue.
    pub async fn issue_archive(
        &self,
        trash: Option<bool>,
        id: String,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::issue_archive(self, trash, id).await
    }
    /// Unarchives an issue.
    pub async fn issue_unarchive(&self, id: String) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::issue_unarchive(self, id).await
    }
    /// Deletes (trashes) an issue.
    pub async fn issue_delete(
        &self,
        permanently_delete: Option<bool>,
        id: String,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::issue_delete(self, permanently_delete, id).await
    }
    /// Creates a new issue relation.
    pub async fn issue_relation_create(
        &self,
        override_created_at: Option<serde_json::Value>,
        input: IssueRelationCreateInput,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::issue_relation_create(self, override_created_at, input).await
    }
    /// Creates a new document.
    pub async fn document_create(
        &self,
        input: DocumentCreateInput,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::document_create(self, input).await
    }
    /// Updates a document.
    pub async fn document_update(
        &self,
        input: DocumentUpdateInput,
        id: String,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::document_update(self, input, id).await
    }
    /// Deletes (trashes) a document.
    pub async fn document_delete(&self, id: String) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::document_delete(self, id).await
    }
    /// Creates a new comment.
    pub async fn comment_create(
        &self,
        input: CommentCreateInput,
    ) -> Result<serde_json::Value, LinearError> {
        crate::generated::mutations::comment_create(self, input).await
    }
}
