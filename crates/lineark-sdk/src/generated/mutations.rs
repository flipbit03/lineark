//! Generated mutation functions.
//!
//! Each mutation is exposed as a standalone async function. The
//! [`Client`] re-exports these as methods for convenience.
//!
//! Generated by lineark-codegen â€” do not edit.
#![allow(clippy::too_many_arguments)]
use super::inputs::*;
use crate::client::Client;
use crate::error::LinearError;
/// XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
pub async fn file_upload(
    client: &Client,
    meta_data: Option<serde_json::Value>,
    make_public: Option<bool>,
    size: i64,
    content_type: String,
    filename: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!(
        { "metaData" : meta_data, "makePublic" : make_public, "size" : size,
        "contentType" : content_type, "filename" : filename }
    );
    let mut response_parts: Vec<String> = vec!["success".to_string()];
    response_parts.push(format!(
        "{} {{ {} }}",
        "uploadFile",
        <super::types::UploadFile as crate::field_selection::GraphQLFields>::selection()
    ));
    let query = String::from(
        "mutation FileUpload($metaData: JSON, $makePublic: Boolean, $size: Int!, $contentType: String!, $filename: String!) { fileUpload(metaData: $metaData, makePublic: $makePublic, size: $size, contentType: $contentType, filename: $filename) { ",
    ) + &response_parts.join(" ") + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "fileUpload")
        .await
}
/// Upload an image from an URL to Linear.
pub async fn image_upload_from_url(
    client: &Client,
    url: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "url" : url });
    let response_parts: Vec<String> = vec!["url".to_string(), "success".to_string()];
    let query = String::from(
        "mutation ImageUploadFromUrl($url: String!) { imageUploadFromUrl(url: $url) { ",
    ) + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "imageUploadFromUrl")
        .await
}
/// Creates a new issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    input: IssueCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation IssueCreate($input: IssueCreateInput!) { issueCreate(input: $input) { success issue { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueCreate", "issue")
        .await
}
/// Updates an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    input: IssueUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let query = String::from(
        "mutation IssueUpdate($input: IssueUpdateInput!, $id: String!) { issueUpdate(input: $input, id: $id) { success issue { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueUpdate", "issue")
        .await
}
/// Archives an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_archive<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    trash: Option<bool>,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "trash" : trash, "id" : id });
    let query = String::from(
        "mutation IssueArchive($trash: Boolean, $id: String!) { issueArchive(trash: $trash, id: $id) { success entity { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueArchive", "entity")
        .await
}
/// Unarchives an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_unarchive<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let query = String::from(
        "mutation IssueUnarchive($id: String!) { issueUnarchive(id: $id) { success entity { ",
    ) + &T::selection()
        + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueUnarchive", "entity")
        .await
}
/// Deletes (trashes) an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_delete<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    permanently_delete: Option<bool>,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "permanentlyDelete" : permanently_delete, "id" : id }
    );
    let query = String::from(
        "mutation IssueDelete($permanentlyDelete: Boolean, $id: String!) { issueDelete(permanentlyDelete: $permanentlyDelete, id: $id) { success entity { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueDelete", "entity")
        .await
}
/// Creates a new issue relation.
///
/// Full type: [`IssueRelation`](super::types::IssueRelation)
pub async fn issue_relation_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::IssueRelation>,
>(
    client: &Client,
    override_created_at: Option<serde_json::Value>,
    input: IssueRelationCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "overrideCreatedAt" : override_created_at, "input" : input }
    );
    let query = String::from(
        "mutation IssueRelationCreate($overrideCreatedAt: DateTime, $input: IssueRelationCreateInput!) { issueRelationCreate(overrideCreatedAt: $overrideCreatedAt, input: $input) { success issueRelation { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueRelationCreate", "issueRelation")
        .await
}
/// Creates a new document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Document>,
>(
    client: &Client,
    input: DocumentCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation DocumentCreate($input: DocumentCreateInput!) { documentCreate(input: $input) { success document { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "documentCreate", "document")
        .await
}
/// Updates a document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Document>,
>(
    client: &Client,
    input: DocumentUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let query = String::from(
        "mutation DocumentUpdate($input: DocumentUpdateInput!, $id: String!) { documentUpdate(input: $input, id: $id) { success document { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "documentUpdate", "document")
        .await
}
/// Deletes (trashes) a document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document_delete<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Document>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let query = String::from(
        "mutation DocumentDelete($id: String!) { documentDelete(id: $id) { success entity { ",
    ) + &T::selection()
        + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "documentDelete", "entity")
        .await
}
/// Creates a new comment.
///
/// Full type: [`Comment`](super::types::Comment)
pub async fn comment_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Comment>,
>(
    client: &Client,
    input: CommentCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation CommentCreate($input: CommentCreateInput!) { commentCreate(input: $input) { success comment { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "commentCreate", "comment")
        .await
}
