//! Generated mutation functions.
//!
//! Each mutation is exposed as a standalone async function. The
//! [`Client`] re-exports these as methods for convenience.
//!
//! Generated by lineark-codegen â€” do not edit.
#![allow(clippy::too_many_arguments)]
use super::inputs::*;
use crate::client::Client;
use crate::error::LinearError;
/// XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
pub async fn file_upload(
    client: &Client,
    meta_data: Option<serde_json::Value>,
    make_public: Option<bool>,
    size: i64,
    content_type: String,
    filename: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!(
        { "metaData" : meta_data, "makePublic" : make_public, "size" : size,
        "contentType" : content_type, "filename" : filename }
    );
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation FileUpload($metaData: JSON, $makePublic: Boolean, $size: Int!, $contentType: String!, $filename: String!) { fileUpload(metaData: $metaData, makePublic: $makePublic, size: $size, contentType: $contentType, filename: $filename) { success uploadFile { filename contentType size uploadUrl assetUrl metaData } } }",
            variables,
            "fileUpload",
        )
        .await
}
/// Upload an image from an URL to Linear.
pub async fn image_upload_from_url(
    client: &Client,
    url: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "url" : url });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation ImageUploadFromUrl($url: String!) { imageUploadFromUrl(url: $url) { success url } }",
            variables,
            "imageUploadFromUrl",
        )
        .await
}
/// Creates a new issue.
pub async fn issue_create(
    client: &Client,
    input: IssueCreateInput,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation IssueCreate($input: IssueCreateInput!) { issueCreate(input: $input) { success issue { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } } }",
            variables,
            "issueCreate",
        )
        .await
}
/// Updates an issue.
pub async fn issue_update(
    client: &Client,
    input: IssueUpdateInput,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation IssueUpdate($input: IssueUpdateInput!, $id: String!) { issueUpdate(input: $input, id: $id) { success issue { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } } }",
            variables,
            "issueUpdate",
        )
        .await
}
/// Archives an issue.
pub async fn issue_archive(
    client: &Client,
    trash: Option<bool>,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "trash" : trash, "id" : id });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation IssueArchive($trash: Boolean, $id: String!) { issueArchive(trash: $trash, id: $id) { success entity { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } } }",
            variables,
            "issueArchive",
        )
        .await
}
/// Unarchives an issue.
pub async fn issue_unarchive(
    client: &Client,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation IssueUnarchive($id: String!) { issueUnarchive(id: $id) { success entity { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } } }",
            variables,
            "issueUnarchive",
        )
        .await
}
/// Deletes (trashes) an issue.
pub async fn issue_delete(
    client: &Client,
    permanently_delete: Option<bool>,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!(
        { "permanentlyDelete" : permanently_delete, "id" : id }
    );
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation IssueDelete($permanentlyDelete: Boolean, $id: String!) { issueDelete(permanentlyDelete: $permanentlyDelete, id: $id) { success entity { id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description } } }",
            variables,
            "issueDelete",
        )
        .await
}
/// Creates a new issue relation.
pub async fn issue_relation_create(
    client: &Client,
    override_created_at: Option<serde_json::Value>,
    input: IssueRelationCreateInput,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!(
        { "overrideCreatedAt" : override_created_at, "input" : input }
    );
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation IssueRelationCreate($overrideCreatedAt: DateTime, $input: IssueRelationCreateInput!) { issueRelationCreate(overrideCreatedAt: $overrideCreatedAt, input: $input) { success issueRelation { id createdAt updatedAt archivedAt type } } }",
            variables,
            "issueRelationCreate",
        )
        .await
}
/// Creates a new document.
pub async fn document_create(
    client: &Client,
    input: DocumentCreateInput,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation DocumentCreate($input: DocumentCreateInput!) { documentCreate(input: $input) { success document { id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url } } }",
            variables,
            "documentCreate",
        )
        .await
}
/// Updates a document.
pub async fn document_update(
    client: &Client,
    input: DocumentUpdateInput,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation DocumentUpdate($input: DocumentUpdateInput!, $id: String!) { documentUpdate(input: $input, id: $id) { success document { id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url } } }",
            variables,
            "documentUpdate",
        )
        .await
}
/// Deletes (trashes) a document.
pub async fn document_delete(
    client: &Client,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation DocumentDelete($id: String!) { documentDelete(id: $id) { success entity { id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url } } }",
            variables,
            "documentDelete",
        )
        .await
}
/// Creates a new comment.
pub async fn comment_create(
    client: &Client,
    input: CommentCreateInput,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    client
        .execute::<
            serde_json::Value,
        >(
            "mutation CommentCreate($input: CommentCreateInput!) { commentCreate(input: $input) { success comment { id createdAt updatedAt archivedAt body issueId documentContentId projectUpdateId initiativeUpdateId parentId resolvedAt resolvingCommentId editedAt bodyData quotedText reactionData threadSummary isArtificialAgentSessionRoot url hideInLinear } } }",
            variables,
            "commentCreate",
        )
        .await
}
