//! Generated mutation functions.
//!
//! Each mutation is exposed as a standalone async function. The
//! [`Client`] re-exports these as methods for convenience.
//!
//! Generated by lineark-codegen â€” do not edit.
#![allow(clippy::too_many_arguments)]
use super::inputs::*;
use crate::client::Client;
use crate::error::LinearError;
/// XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
pub async fn file_upload(
    client: &Client,
    meta_data: Option<serde_json::Value>,
    make_public: Option<bool>,
    size: i64,
    content_type: String,
    filename: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!(
        { "metaData" : meta_data, "makePublic" : make_public, "size" : size,
        "contentType" : content_type, "filename" : filename }
    );
    let mut response_parts: Vec<String> = vec!["success".to_string()];
    response_parts.push(format!(
        "{} {{ {} }}",
        "uploadFile",
        <super::types::UploadFile as crate::field_selection::GraphQLFields>::selection()
    ));
    let query = String::from(
        "mutation FileUpload($metaData: JSON, $makePublic: Boolean, $size: Int!, $contentType: String!, $filename: String!) { fileUpload(metaData: $metaData, makePublic: $makePublic, size: $size, contentType: $contentType, filename: $filename) { ",
    ) + &response_parts.join(" ") + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "fileUpload")
        .await
}
/// Upload an image from an URL to Linear.
pub async fn image_upload_from_url(
    client: &Client,
    url: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "url" : url });
    let response_parts: Vec<String> = vec!["url".to_string(), "success".to_string()];
    let query = String::from(
        "mutation ImageUploadFromUrl($url: String!) { imageUploadFromUrl(url: $url) { ",
    ) + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "imageUploadFromUrl")
        .await
}
/// Creates a new comment.
///
/// Full type: [`Comment`](super::types::Comment)
pub async fn comment_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Comment>,
>(
    client: &Client,
    input: CommentCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation CommentCreate($input: CommentCreateInput!) { commentCreate(input: $input) { success comment { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "commentCreate", "comment")
        .await
}
/// Deletes a comment.
pub async fn comment_delete(client: &Client, id: String) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string(), "entityId".to_string()];
    let query = String::from("mutation CommentDelete($id: String!) { commentDelete(id: $id) { ")
        + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "commentDelete")
        .await
}
/// Creates a new project.
///
/// Full type: [`Project`](super::types::Project)
pub async fn project_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Project>,
>(
    client: &Client,
    slack_channel_name: Option<String>,
    input: ProjectCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "slackChannelName" : slack_channel_name, "input" : input }
    );
    let query = String::from(
        "mutation ProjectCreate($slackChannelName: String, $input: ProjectCreateInput!) { projectCreate(slackChannelName: $slackChannelName, input: $input) { success project { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "projectCreate", "project")
        .await
}
/// Updates a project.
///
/// Full type: [`Project`](super::types::Project)
pub async fn project_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Project>,
>(
    client: &Client,
    input: ProjectUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let query = String::from(
        "mutation ProjectUpdate($input: ProjectUpdateInput!, $id: String!) { projectUpdate(input: $input, id: $id) { success project { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "projectUpdate", "project")
        .await
}
/// Deletes (trashes) a project.
///
/// Full type: [`Project`](super::types::Project)
pub async fn project_delete<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Project>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let query = String::from(
        "mutation ProjectDelete($id: String!) { projectDelete(id: $id) { success entity { ",
    ) + &T::selection()
        + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "projectDelete", "entity")
        .await
}
/// Creates a new team. The user who creates the team will automatically be added as a member to the newly created team.
///
/// Full type: [`Team`](super::types::Team)
pub async fn team_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Team>,
>(
    client: &Client,
    copy_settings_from_team_id: Option<String>,
    input: TeamCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "copySettingsFromTeamId" : copy_settings_from_team_id, "input" : input }
    );
    let query = String::from(
        "mutation TeamCreate($copySettingsFromTeamId: String, $input: TeamCreateInput!) { teamCreate(copySettingsFromTeamId: $copySettingsFromTeamId, input: $input) { success team { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "teamCreate", "team")
        .await
}
/// Updates a team.
///
/// Full type: [`Team`](super::types::Team)
pub async fn team_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Team>,
>(
    client: &Client,
    mapping: Option<InheritanceEntityMapping>,
    input: TeamUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "mapping" : mapping, "input" : input, "id" : id }
    );
    let query = String::from(
        "mutation TeamUpdate($mapping: InheritanceEntityMapping, $input: TeamUpdateInput!, $id: String!) { teamUpdate(mapping: $mapping, input: $input, id: $id) { success team { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "teamUpdate", "team")
        .await
}
/// Deletes a team.
pub async fn team_delete(client: &Client, id: String) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string(), "entityId".to_string()];
    let query = String::from("mutation TeamDelete($id: String!) { teamDelete(id: $id) { ")
        + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "teamDelete")
        .await
}
/// Creates a new team membership.
///
/// Full type: [`TeamMembership`](super::types::TeamMembership)
pub async fn team_membership_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::TeamMembership>,
>(
    client: &Client,
    input: TeamMembershipCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation TeamMembershipCreate($input: TeamMembershipCreateInput!) { teamMembershipCreate(input: $input) { success teamMembership { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "teamMembershipCreate", "teamMembership")
        .await
}
/// Deletes a team membership.
pub async fn team_membership_delete(
    client: &Client,
    also_leave_parent_teams: Option<bool>,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!(
        { "alsoLeaveParentTeams" : also_leave_parent_teams, "id" : id }
    );
    let response_parts: Vec<String> = vec!["success".to_string(), "entityId".to_string()];
    let query = String::from(
        "mutation TeamMembershipDelete($alsoLeaveParentTeams: Boolean, $id: String!) { teamMembershipDelete(alsoLeaveParentTeams: $alsoLeaveParentTeams, id: $id) { ",
    ) + &response_parts.join(" ") + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "teamMembershipDelete")
        .await
}
/// Creates a new project milestone.
///
/// Full type: [`ProjectMilestone`](super::types::ProjectMilestone)
pub async fn project_milestone_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::ProjectMilestone>,
>(
    client: &Client,
    input: ProjectMilestoneCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation ProjectMilestoneCreate($input: ProjectMilestoneCreateInput!) { projectMilestoneCreate(input: $input) { success projectMilestone { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(
            &query,
            variables,
            "projectMilestoneCreate",
            "projectMilestone",
        )
        .await
}
/// Updates a project milestone.
///
/// Full type: [`ProjectMilestone`](super::types::ProjectMilestone)
pub async fn project_milestone_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::ProjectMilestone>,
>(
    client: &Client,
    input: ProjectMilestoneUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let query = String::from(
        "mutation ProjectMilestoneUpdate($input: ProjectMilestoneUpdateInput!, $id: String!) { projectMilestoneUpdate(input: $input, id: $id) { success projectMilestone { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(
            &query,
            variables,
            "projectMilestoneUpdate",
            "projectMilestone",
        )
        .await
}
/// Deletes a project milestone.
pub async fn project_milestone_delete(
    client: &Client,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string(), "entityId".to_string()];
    let query = String::from(
        "mutation ProjectMilestoneDelete($id: String!) { projectMilestoneDelete(id: $id) { ",
    ) + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "projectMilestoneDelete")
        .await
}
/// Updates a notification.
pub async fn notification_update(
    client: &Client,
    input: NotificationUpdateInput,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string()];
    let query = String::from(
        "mutation NotificationUpdate($input: NotificationUpdateInput!, $id: String!) { notificationUpdate(input: $input, id: $id) { ",
    ) + &response_parts.join(" ") + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "notificationUpdate")
        .await
}
/// Archives a notification.
pub async fn notification_archive(
    client: &Client,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string()];
    let query = String::from(
        "mutation NotificationArchive($id: String!) { notificationArchive(id: $id) { ",
    ) + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "notificationArchive")
        .await
}
/// Unarchives a notification.
pub async fn notification_unarchive(
    client: &Client,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string()];
    let query = String::from(
        "mutation NotificationUnarchive($id: String!) { notificationUnarchive(id: $id) { ",
    ) + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "notificationUnarchive")
        .await
}
/// Creates a new issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    input: IssueCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation IssueCreate($input: IssueCreateInput!) { issueCreate(input: $input) { success issue { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueCreate", "issue")
        .await
}
/// Updates an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    input: IssueUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let query = String::from(
        "mutation IssueUpdate($input: IssueUpdateInput!, $id: String!) { issueUpdate(input: $input, id: $id) { success issue { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueUpdate", "issue")
        .await
}
/// Archives an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_archive<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    trash: Option<bool>,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "trash" : trash, "id" : id });
    let query = String::from(
        "mutation IssueArchive($trash: Boolean, $id: String!) { issueArchive(trash: $trash, id: $id) { success entity { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueArchive", "entity")
        .await
}
/// Unarchives an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_unarchive<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let query = String::from(
        "mutation IssueUnarchive($id: String!) { issueUnarchive(id: $id) { success entity { ",
    ) + &T::selection()
        + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueUnarchive", "entity")
        .await
}
/// Deletes (trashes) an issue.
///
/// Full type: [`Issue`](super::types::Issue)
pub async fn issue_delete<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Issue>,
>(
    client: &Client,
    permanently_delete: Option<bool>,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "permanentlyDelete" : permanently_delete, "id" : id }
    );
    let query = String::from(
        "mutation IssueDelete($permanentlyDelete: Boolean, $id: String!) { issueDelete(permanentlyDelete: $permanentlyDelete, id: $id) { success entity { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueDelete", "entity")
        .await
}
/// Creates a new issue relation.
///
/// Full type: [`IssueRelation`](super::types::IssueRelation)
pub async fn issue_relation_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::IssueRelation>,
>(
    client: &Client,
    override_created_at: Option<serde_json::Value>,
    input: IssueRelationCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!(
        { "overrideCreatedAt" : override_created_at, "input" : input }
    );
    let query = String::from(
        "mutation IssueRelationCreate($overrideCreatedAt: DateTime, $input: IssueRelationCreateInput!) { issueRelationCreate(overrideCreatedAt: $overrideCreatedAt, input: $input) { success issueRelation { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "issueRelationCreate", "issueRelation")
        .await
}
/// Deletes an issue relation.
pub async fn issue_relation_delete(
    client: &Client,
    id: String,
) -> Result<serde_json::Value, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let response_parts: Vec<String> = vec!["success".to_string(), "entityId".to_string()];
    let query = String::from(
        "mutation IssueRelationDelete($id: String!) { issueRelationDelete(id: $id) { ",
    ) + &response_parts.join(" ")
        + " } }";
    client
        .execute::<serde_json::Value>(&query, variables, "issueRelationDelete")
        .await
}
/// Creates a new document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document_create<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Document>,
>(
    client: &Client,
    input: DocumentCreateInput,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input });
    let query = String::from(
        "mutation DocumentCreate($input: DocumentCreateInput!) { documentCreate(input: $input) { success document { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "documentCreate", "document")
        .await
}
/// Updates a document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document_update<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Document>,
>(
    client: &Client,
    input: DocumentUpdateInput,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "input" : input, "id" : id });
    let query = String::from(
        "mutation DocumentUpdate($input: DocumentUpdateInput!, $id: String!) { documentUpdate(input: $input, id: $id) { success document { ",
    ) + &T::selection() + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "documentUpdate", "document")
        .await
}
/// Deletes (trashes) a document.
///
/// Full type: [`Document`](super::types::Document)
pub async fn document_delete<
    T: serde::de::DeserializeOwned
        + crate::field_selection::GraphQLFields<FullType = super::types::Document>,
>(
    client: &Client,
    id: String,
) -> Result<T, LinearError> {
    let variables = serde_json::json!({ "id" : id });
    let query = String::from(
        "mutation DocumentDelete($id: String!) { documentDelete(id: $id) { success entity { ",
    ) + &T::selection()
        + " } } }";
    client
        .execute_mutation::<T>(&query, variables, "documentDelete", "entity")
        .await
}
