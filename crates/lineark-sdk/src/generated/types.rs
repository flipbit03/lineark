//! GraphQL object types.
//!
//! Generated by lineark-codegen â€” do not edit.
use super::enums::*;
use crate::field_selection::GraphQLFields;
use serde::{Deserialize, Serialize};
/// `Internal` An access key for CI/CD integrations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AccessKey {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Organization the API key belongs to.
    pub organization: Option<Box<Organization>>,
    /// The user who created the access key.
    pub creator: Option<Box<User>>,
    /// When the access key was last used.
    pub last_used_at: Option<chrono::DateTime<chrono::Utc>>,
    /// When the access key was revoked.
    pub revoked_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for AccessKey {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt lastUsedAt revokedAt".into()
    }
}
/// A bot actor is an actor that is not a user, but an application or integration.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ActorBot {
    pub id: Option<String>,
    /// The type of bot.
    pub r#type: Option<String>,
    /// The sub type of the bot.
    pub sub_type: Option<String>,
    /// The display name of the bot.
    pub name: Option<String>,
    /// The display name of the external user on behalf of which the bot acted.
    pub user_display_name: Option<String>,
    /// A url pointing to the avatar representing this bot.
    pub avatar_url: Option<String>,
}
impl GraphQLFields for ActorBot {
    type FullType = Self;
    fn selection() -> String {
        "id type subType name userDisplayName avatarUrl".into()
    }
}
/// An activity within an agent context.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivity {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The agent session this activity belongs to.
    pub agent_session: Option<Box<AgentSession>>,
    /// The comment this activity is linked to.
    pub source_comment: Option<Box<Comment>>,
    /// The user who created this agent activity.
    pub user: Option<Box<User>>,
    /// Metadata about the external source that created this agent activity.
    pub source_metadata: Option<serde_json::Value>,
    /// An optional modifier that provides additional instructions on how the activity should be interpreted.
    pub signal: Option<AgentActivitySignal>,
    /// Metadata about this agent activity's signal.
    pub signal_metadata: Option<serde_json::Value>,
    /// Whether the activity is ephemeral, and should disappear after the next agent activity.
    pub ephemeral: Option<bool>,
    /// `Internal` Metadata about user-provided contextual information for this agent activity.
    pub contextual_metadata: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivity {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt sourceMetadata signal signalMetadata ephemeral contextualMetadata"
            .into()
    }
}
/// Content for an action activity (tool call or action).
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityActionContent {
    /// The type of activity.
    pub r#type: Option<AgentActivityType>,
    /// The action being performed.
    pub action: Option<String>,
    /// The parameters for the action, e.g. a file path, a keyword, etc.
    pub parameter: Option<String>,
    /// The result of the action in Markdown format.
    pub result: Option<String>,
    /// `Internal` The result content as ProseMirror document.
    pub result_data: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivityActionContent {
    type FullType = Self;
    fn selection() -> String {
        "type action parameter result resultData".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityConnection {
    pub edges: Option<Box<Vec<AgentActivityEdge>>>,
    pub nodes: Option<Box<Vec<AgentActivity>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for AgentActivityConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityEdge {
    pub node: Option<Box<AgentActivity>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for AgentActivityEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// Content for an elicitation activity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityElicitationContent {
    /// The type of activity.
    pub r#type: Option<AgentActivityType>,
    /// The elicitation message in Markdown format.
    pub body: Option<String>,
    /// `Internal` The elicitation content as ProseMirror document.
    pub body_data: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivityElicitationContent {
    type FullType = Self;
    fn selection() -> String {
        "type body bodyData".into()
    }
}
/// Content for an error activity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityErrorContent {
    /// The type of activity.
    pub r#type: Option<AgentActivityType>,
    /// The error message in Markdown format.
    pub body: Option<String>,
    /// `Internal` The error content as ProseMirror document.
    pub body_data: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivityErrorContent {
    type FullType = Self;
    fn selection() -> String {
        "type body bodyData".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The agent activity that was created or updated.
    pub agent_activity: Option<Box<AgentActivity>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for AgentActivityPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Content for a prompt activity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityPromptContent {
    /// The type of activity.
    pub r#type: Option<AgentActivityType>,
    /// A message requesting additional information or action from user.
    pub body: Option<String>,
    /// `Internal` The prompt content as ProseMirror document.
    pub body_data: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivityPromptContent {
    type FullType = Self;
    fn selection() -> String {
        "type body bodyData".into()
    }
}
/// Content for a response activity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityResponseContent {
    /// The type of activity.
    pub r#type: Option<AgentActivityType>,
    /// The response content in Markdown format.
    pub body: Option<String>,
    /// `Internal` The response content as ProseMirror document.
    pub body_data: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivityResponseContent {
    type FullType = Self;
    fn selection() -> String {
        "type body bodyData".into()
    }
}
/// Content for a thought activity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentActivityThoughtContent {
    /// The type of activity.
    pub r#type: Option<AgentActivityType>,
    /// The thought content in Markdown format.
    pub body: Option<String>,
    /// `Internal` The thought content as ProseMirror document.
    pub body_data: Option<serde_json::Value>,
}
impl GraphQLFields for AgentActivityThoughtContent {
    type FullType = Self;
    fn selection() -> String {
        "type body bodyData".into()
    }
}
/// A session for agent activities and state management.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSession {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The human user responsible for the agent session. Null if the session was initiated via automation or by an agent user, with no responsible human user.
    pub creator: Option<Box<User>>,
    /// The agent user that is associated with this agent session.
    pub app_user: Option<Box<User>>,
    /// The comment this agent session is associated with.
    pub comment: Option<Box<Comment>>,
    /// The comment that this agent session was spawned from, if from a different thread.
    pub source_comment: Option<Box<Comment>>,
    /// The issue this agent session is associated with.
    pub issue: Option<Box<Issue>>,
    /// The current status of the agent session.
    pub status: Option<AgentSessionStatus>,
    /// The time the agent session started.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time the agent session ended.
    pub ended_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time the agent session was dismissed.
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user who dismissed the agent session.
    pub dismissed_by: Option<Box<User>>,
    /// Activities associated with this agent session.
    pub activities: Option<Box<AgentActivityConnection>>,
    /// The URL of an external agent-hosted page associated with this session.
    pub external_link: Option<String>,
    /// A summary of the activities in this session.
    pub summary: Option<String>,
    /// Metadata about the external source that created this agent session.
    pub source_metadata: Option<serde_json::Value>,
    /// A dynamically updated list of the agent's execution strategy.
    pub plan: Option<serde_json::Value>,
    /// Serialized JSON representing the contexts this session is related to, for direct chat sessions.
    pub context: Option<serde_json::Value>,
    /// `DEPRECATED` The type of the agent session.
    pub r#type: Option<AgentSessionType>,
    /// Agent session URL.
    pub url: Option<String>,
    /// `Internal` Pull requests associated with this agent session.
    pub pull_requests: Option<Box<AgentSessionToPullRequestConnection>>,
    /// External links associated with this session.
    pub external_links: Option<Box<Vec<AgentSessionExternalLink>>>,
    /// URLs of external resources associated with this session.
    pub external_urls: Option<serde_json::Value>,
}
impl GraphQLFields for AgentSession {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt status startedAt endedAt dismissedAt externalLink summary sourceMetadata plan context type url externalUrls"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionConnection {
    pub edges: Option<Box<Vec<AgentSessionEdge>>>,
    pub nodes: Option<Box<Vec<AgentSession>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for AgentSessionConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionEdge {
    pub node: Option<Box<AgentSession>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for AgentSessionEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// An external link associated with an agent session.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionExternalLink {
    /// The URL of the external resource.
    pub url: Option<String>,
    /// Label for the link.
    pub label: Option<String>,
}
impl GraphQLFields for AgentSessionExternalLink {
    type FullType = Self;
    fn selection() -> String {
        "url label".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The agent session that was created or updated.
    pub agent_session: Option<Box<AgentSession>>,
}
impl GraphQLFields for AgentSessionPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Join table between agent sessions and pull requests.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionToPullRequest {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The pull request that the agent session is associated with.
    pub pull_request: Option<Box<PullRequest>>,
    /// The agent session that the pull request is associated with.
    pub agent_session: Option<Box<AgentSession>>,
}
impl GraphQLFields for AgentSessionToPullRequest {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionToPullRequestConnection {
    pub edges: Option<Box<Vec<AgentSessionToPullRequestEdge>>>,
    pub nodes: Option<Box<Vec<AgentSessionToPullRequest>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for AgentSessionToPullRequestConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AgentSessionToPullRequestEdge {
    pub node: Option<Box<AgentSessionToPullRequest>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for AgentSessionToPullRequestEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// AI prompt rules for a team.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AiPromptRules {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user who last updated the AI prompt rules.
    pub updated_by: Option<Box<User>>,
}
impl GraphQLFields for AiPromptRules {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt".into()
    }
}
/// Public information of the OAuth application.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Application {
    /// OAuth application's ID.
    pub id: Option<String>,
    /// OAuth application's client ID.
    pub client_id: Option<String>,
    /// Application name.
    pub name: Option<String>,
    /// Information about the application.
    pub description: Option<String>,
    /// Name of the developer.
    pub developer: Option<String>,
    /// Url of the developer (homepage or docs).
    pub developer_url: Option<String>,
    /// Image of the application.
    pub image_url: Option<String>,
}
impl GraphQLFields for Application {
    type FullType = Self;
    fn selection() -> String {
        "id clientId name description developer developerUrl imageUrl".into()
    }
}
/// Contains requested archived model objects.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ArchiveResponse {
    /// A JSON serialized collection of model objects loaded from the archive
    pub archive: Option<String>,
    /// The total number of entities in the archive.
    pub total_count: Option<f64>,
    /// The version of the remote database. Incremented by 1 for each migration run on the database.
    pub database_version: Option<f64>,
    /// Whether the dependencies for the model objects are included in the archive.
    pub includes_dependencies: Option<Vec<String>>,
}
impl GraphQLFields for ArchiveResponse {
    type FullType = Self;
    fn selection() -> String {
        "archive totalCount databaseVersion includesDependencies".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AsksChannelConnectPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The new Asks Slack channel mapping for the connected channel.
    pub mapping: Option<Box<SlackChannelNameMapping>>,
    /// Whether the bot needs to be manually added to the channel.
    pub add_bot: Option<bool>,
}
impl GraphQLFields for AsksChannelConnectPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success addBot".into()
    }
}
/// A web page for an Asks web form.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AsksWebPage {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The organization that the Asks web page belongs to.
    pub organization: Option<Box<Organization>>,
    /// The Asks web settings this page belongs to.
    pub asks_web_settings: Option<Box<AsksWebSettings>>,
    /// The user who created the Asks web page.
    pub creator: Option<Box<User>>,
    /// The title of the page.
    pub title: Option<String>,
    /// The description of the page.
    pub description: Option<String>,
    /// The page's unique URL slug.
    pub slug_id: Option<String>,
    /// The auto-reply message for issue created. If not set, the default reply will be used.
    pub issue_created_auto_reply: Option<String>,
    /// Whether the auto-reply for issue created is enabled.
    pub issue_created_auto_reply_enabled: Option<bool>,
    /// The auto-reply message for issue completed. If not set, the default reply will be used.
    pub issue_completed_auto_reply: Option<String>,
    /// Whether the auto-reply for issue completed is enabled.
    pub issue_completed_auto_reply_enabled: Option<bool>,
    /// The auto-reply message for issue canceled. If not set, the default reply will be used.
    pub issue_canceled_auto_reply: Option<String>,
    /// Whether the auto-reply for issue canceled is enabled.
    pub issue_canceled_auto_reply_enabled: Option<bool>,
}
impl GraphQLFields for AsksWebPage {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title description slugId issueCreatedAutoReply issueCreatedAutoReplyEnabled issueCompletedAutoReply issueCompletedAutoReplyEnabled issueCanceledAutoReply issueCanceledAutoReplyEnabled"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AsksWebPagePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The Asks web page that was created or updated.
    pub asks_web_page: Option<Box<AsksWebPage>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for AsksWebPagePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Settings for an Asks web form.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AsksWebSettings {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The organization that the Asks web settings are associated with.
    pub organization: Option<Box<Organization>>,
    /// The user who created the Asks web settings.
    pub creator: Option<Box<User>>,
    /// The custom domain for the Asks web form. If null, the default Linear-hosted domain will be used.
    pub domain: Option<String>,
    /// The email intake address associated with these Asks web settings.
    pub email_intake_address: Option<Box<EmailIntakeAddress>>,
    /// The identity provider for SAML authentication on this Asks web form.
    pub identity_provider: Option<Box<IdentityProvider>>,
}
impl GraphQLFields for AsksWebSettings {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt domain".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AsksWebSettingsPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The Asks web settings that were created or updated.
    pub asks_web_settings: Option<Box<AsksWebSettings>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for AsksWebSettingsPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Issue attachment (e.g. support ticket, pull request).
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Attachment {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Content for the title line in the Linear attachment widget.
    pub title: Option<String>,
    /// Content for the subtitle line in the Linear attachment widget.
    pub subtitle: Option<String>,
    /// Location of the attachment which is also used as an identifier.
    pub url: Option<String>,
    /// The creator of the attachment.
    pub creator: Option<Box<User>>,
    /// The non-Linear user who created the attachment.
    pub external_user_creator: Option<Box<ExternalUser>>,
    /// Custom metadata related to the attachment.
    pub metadata: Option<serde_json::Value>,
    /// Information about the source which created the attachment.
    pub source: Option<serde_json::Value>,
    /// An accessor helper to source.type, defines the source type of the attachment.
    pub source_type: Option<String>,
    /// Indicates if attachments for the same source application should be grouped in the Linear UI.
    pub group_by_source: Option<bool>,
    /// The issue this attachment was originally created on. Will be undefined if the attachment hasn't been moved.
    pub original_issue: Option<Box<Issue>>,
    /// The issue this attachment belongs to.
    pub issue: Option<Box<Issue>>,
    /// The body data of the attachment, if any.
    pub body_data: Option<String>,
}
impl GraphQLFields for Attachment {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title subtitle url metadata source sourceType groupBySource bodyData"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AttachmentConnection {
    pub edges: Option<Box<Vec<AttachmentEdge>>>,
    pub nodes: Option<Box<Vec<Attachment>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for AttachmentConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AttachmentEdge {
    pub node: Option<Box<Attachment>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for AttachmentEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AttachmentPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The issue attachment that was created.
    pub attachment: Option<Box<Attachment>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for AttachmentPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AttachmentSourcesPayload {
    /// A unique list of all source types used in this workspace.
    pub sources: Option<serde_json::Value>,
}
impl GraphQLFields for AttachmentSourcesPayload {
    type FullType = Self;
    fn selection() -> String {
        "sources".into()
    }
}
/// Workspace audit log entry object.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuditEntry {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    pub r#type: Option<String>,
    /// The organization the audit log belongs to.
    pub organization: Option<Box<Organization>>,
    /// The user that caused the audit entry to be created.
    pub actor: Option<Box<User>>,
    /// The ID of the user that caused the audit entry to be created.
    pub actor_id: Option<String>,
    /// IP from actor when entry was recorded.
    pub ip: Option<String>,
    /// Country code of request resulting to audit entry.
    pub country_code: Option<String>,
    /// Additional metadata related to the audit entry.
    pub metadata: Option<serde_json::Value>,
    /// Additional information related to the request which performed the action.
    pub request_information: Option<serde_json::Value>,
}
impl GraphQLFields for AuditEntry {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type actorId ip countryCode metadata requestInformation"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuditEntryConnection {
    pub edges: Option<Box<Vec<AuditEntryEdge>>>,
    pub nodes: Option<Box<Vec<AuditEntry>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for AuditEntryConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuditEntryEdge {
    pub node: Option<Box<AuditEntry>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for AuditEntryEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuditEntryType {
    /// The audit entry type.
    pub r#type: Option<String>,
    /// Description of the audit entry type.
    pub description: Option<String>,
}
impl GraphQLFields for AuditEntryType {
    type FullType = Self;
    fn selection() -> String {
        "type description".into()
    }
}
/// An identity provider.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuthIdentityProvider {
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// Whether the identity provider is the default identity provider migrated from organization level settings.
    pub default_migrated: Option<bool>,
    /// The type of identity provider.
    pub r#type: Option<IdentityProviderType>,
    /// Whether SAML authentication is enabled for organization.
    pub saml_enabled: Option<bool>,
    /// Sign in endpoint URL for the identity provider.
    pub sso_endpoint: Option<String>,
    /// Binding method for authentication call. Can be either `post` (default) or `redirect`.
    pub sso_binding: Option<String>,
    /// The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
    pub sso_sign_algo: Option<String>,
    /// The issuer's custom entity ID.
    pub issuer_entity_id: Option<String>,
    /// The service provider (Linear) custom entity ID. Defaults to <https://auth.linear.app/sso>
    pub sp_entity_id: Option<String>,
    /// X.509 Signing Certificate in string form.
    pub sso_signing_cert: Option<String>,
    /// The SAML priority used to pick default workspace in SAML SP initiated flow, when same domain is claimed for SAML by multiple workspaces. Lower priority value means higher preference.
    pub priority: Option<f64>,
    /// Whether SCIM provisioning is enabled for organization.
    pub scim_enabled: Option<bool>,
}
impl GraphQLFields for AuthIdentityProvider {
    type FullType = Self;
    fn selection() -> String {
        "createdAt id defaultMigrated type samlEnabled ssoEndpoint ssoBinding ssoSignAlgo issuerEntityId spEntityId ssoSigningCert priority scimEnabled"
            .into()
    }
}
/// An organization. Organizations are root-level objects that contain users and teams.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuthOrganization {
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The organization's name.
    pub name: Option<String>,
    /// Whether the organization is enabled. Used as a superuser tool to lock down the org.
    pub enabled: Option<bool>,
    /// The organization's unique URL key.
    pub url_key: Option<String>,
    /// Previously used URL keys for the organization (last 3 are kept and redirected).
    pub previous_url_keys: Option<Vec<String>>,
    /// The organization's logo URL.
    pub logo_url: Option<String>,
    /// The time at which deletion of the organization was requested.
    pub deletion_requested_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The feature release channel the organization belongs to.
    pub release_channel: Option<ReleaseChannel>,
    /// Whether SAML authentication is enabled for organization.
    pub saml_enabled: Option<bool>,
    /// `INTERNAL` SAML settings
    pub saml_settings: Option<serde_json::Value>,
    /// Allowed authentication providers, empty array means all are allowed
    pub allowed_auth_services: Option<Vec<String>>,
    /// Whether SCIM provisioning is enabled for organization.
    pub scim_enabled: Option<bool>,
    /// The email domain or URL key for the organization.
    pub service_id: Option<String>,
    /// The region the organization is hosted in.
    pub region: Option<String>,
    /// Whether to hide other organizations for new users signing up with email domains claimed by this organization.
    pub hide_non_primary_organizations: Option<bool>,
    pub user_count: Option<f64>,
}
impl GraphQLFields for AuthOrganization {
    type FullType = Self;
    fn selection() -> String {
        "createdAt id name enabled urlKey previousUrlKeys logoUrl deletionRequestedAt releaseChannel samlEnabled samlSettings allowedAuthServices scimEnabled serviceId region hideNonPrimaryOrganizations userCount"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuthResolverResponse {
    /// User account ID.
    pub id: Option<String>,
    /// Email for the authenticated account.
    pub email: Option<String>,
    /// Should the signup flow allow access for the domain.
    pub allow_domain_access: Option<bool>,
    /// List of active users that belong to the user account.
    pub users: Option<Box<Vec<AuthUser>>>,
    /// List of locked users that are locked by login restrictions
    pub locked_users: Option<Box<Vec<AuthUser>>>,
    /// List of organizations allowing this user account to join automatically.
    pub available_organizations: Option<Box<Vec<AuthOrganization>>>,
    /// List of organization available to this user account but locked due to the current auth method.
    pub locked_organizations: Option<Box<Vec<AuthOrganization>>>,
    /// ID of the organization last accessed by the user.
    pub last_used_organization_id: Option<String>,
    /// The authentication service used for the current session (e.g., google, email, saml).
    pub service: Option<String>,
    /// Application token.
    pub token: Option<String>,
}
impl GraphQLFields for AuthResolverResponse {
    type FullType = Self;
    fn selection() -> String {
        "id email allowDomainAccess lastUsedOrganizationId service token".into()
    }
}
/// A user that has access to the the resources of an organization.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuthUser {
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    /// The user's full name.
    pub name: Option<String>,
    /// The user's display (nick) name. Unique within each organization.
    pub display_name: Option<String>,
    /// The user's email address.
    pub email: Option<String>,
    /// An URL to the user's avatar image.
    pub avatar_url: Option<String>,
    /// Whether the user is an organization admin or guest on a database level.
    pub role: Option<UserRoleType>,
    /// Whether the user is active.
    pub active: Option<bool>,
    /// User account ID the user belongs to.
    pub user_account_id: Option<String>,
    /// Organization the user belongs to.
    pub organization: Option<Box<AuthOrganization>>,
    /// `INTERNAL` Identity provider the user is managed by.
    pub identity_provider: Option<Box<AuthIdentityProvider>>,
}
impl GraphQLFields for AuthUser {
    type FullType = Self;
    fn selection() -> String {
        "createdAt id name displayName email avatarUrl role active userAccountId".into()
    }
}
/// Authentication session information.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct AuthenticationSessionResponse {
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    /// Type of application used to authenticate.
    pub r#type: Option<AuthenticationSessionType>,
    /// IP address.
    pub ip: Option<String>,
    /// Location country name.
    pub location_country: Option<String>,
    /// Location country code.
    pub location_country_code: Option<String>,
    /// Country codes of all seen locations.
    pub country_codes: Option<Vec<String>>,
    /// Location region code.
    pub location_region_code: Option<String>,
    /// Location city name.
    pub location_city: Option<String>,
    /// Session's user-agent.
    pub user_agent: Option<String>,
    /// Used web browser.
    pub browser_type: Option<String>,
    /// Service used for logging in.
    pub service: Option<String>,
    /// When was the session last seen
    pub last_active_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Date when the session was last updated.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Human readable location
    pub location: Option<String>,
    /// Operating system used for the session
    pub operating_system: Option<String>,
    /// Client used for the session
    pub client: Option<String>,
    /// Name of the session, derived from the client and operating system
    pub name: Option<String>,
    /// Identifies the session used to make the request.
    pub is_current_session: Option<bool>,
}
impl GraphQLFields for AuthenticationSessionResponse {
    type FullType = Self;
    fn selection() -> String {
        "createdAt id type ip locationCountry locationCountryCode countryCodes locationRegionCode locationCity userAgent browserType service lastActiveAt updatedAt location operatingSystem client name isCurrentSession"
            .into()
    }
}
/// A comment associated with an issue.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Comment {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The comment content in markdown format.
    pub body: Option<String>,
    /// The issue that the comment is associated with.
    pub issue: Option<Box<Issue>>,
    /// The ID of the issue that the comment is associated with.
    pub issue_id: Option<String>,
    /// The document content that the comment is associated with.
    pub document_content: Option<Box<DocumentContent>>,
    /// The ID of the document content that the comment is associated with.
    pub document_content_id: Option<String>,
    /// The project update that the comment is associated with.
    pub project_update: Option<Box<ProjectUpdate>>,
    /// The ID of the project update that the comment is associated with.
    pub project_update_id: Option<String>,
    /// The initiative update that the comment is associated with.
    pub initiative_update: Option<Box<InitiativeUpdate>>,
    /// The ID of the initiative update that the comment is associated with.
    pub initiative_update_id: Option<String>,
    /// The post that the comment is associated with.
    pub post: Option<Box<Post>>,
    /// The parent comment under which the current comment is nested.
    pub parent: Option<Box<Comment>>,
    /// The ID of the parent comment under which the current comment is nested.
    pub parent_id: Option<String>,
    /// The user that resolved the thread.
    pub resolving_user: Option<Box<User>>,
    /// The time the resolvingUser resolved the thread.
    pub resolved_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The comment that resolved the thread.
    pub resolving_comment: Option<Box<Comment>>,
    /// The ID of the comment that resolved the thread.
    pub resolving_comment_id: Option<String>,
    /// The user who wrote the comment.
    pub user: Option<Box<User>>,
    /// The external user who wrote the comment.
    pub external_user: Option<Box<ExternalUser>>,
    /// The time user edited the comment.
    pub edited_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` The comment content as a Prosemirror document.
    pub body_data: Option<String>,
    /// The text that this comment references. Only defined for inline comments.
    pub quoted_text: Option<String>,
    /// Emoji reaction summary, grouped by emoji type.
    pub reaction_data: Option<serde_json::Value>,
    /// `Internal` A generated summary of the comment thread.
    pub thread_summary: Option<serde_json::Value>,
    /// `Internal` Whether the comment is an artificial placeholder for an agent session thread created without a comment mention.
    pub is_artificial_agent_session_root: Option<bool>,
    /// Comment's URL.
    pub url: Option<String>,
    /// The children of the comment.
    pub children: Option<Box<CommentConnection>>,
    /// Agent session associated with this comment.
    pub agent_session: Option<Box<AgentSession>>,
    /// `Internal` Agent sessions associated with this comment.
    pub agent_sessions: Option<Box<AgentSessionConnection>>,
    /// Issues created from this comment.
    pub created_issues: Option<Box<IssueConnection>>,
    /// The bot that created the comment.
    pub bot_actor: Option<Box<ActorBot>>,
    /// `Internal` The user on whose behalf the comment was created, e.g. when the Linear assistant creates a comment for a user.
    pub on_behalf_of: Option<Box<User>>,
    /// The external thread that the comment is synced with.
    pub external_thread: Option<Box<SyncedExternalThread>>,
    /// `Internal` Whether the comment should be hidden from Linear clients. This is typically used for bot comments that provide redundant information (e.g., Slack Asks confirmation messages).
    pub hide_in_linear: Option<bool>,
    /// Reactions associated with the comment.
    pub reactions: Option<Box<Vec<Reaction>>>,
    /// The external services the comment is synced with.
    pub synced_with: Option<Box<Vec<ExternalEntityInfo>>>,
}
impl GraphQLFields for Comment {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt body issueId documentContentId projectUpdateId initiativeUpdateId parentId resolvedAt resolvingCommentId editedAt bodyData quotedText reactionData threadSummary isArtificialAgentSessionRoot url hideInLinear"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CommentConnection {
    pub edges: Option<Box<Vec<CommentEdge>>>,
    pub nodes: Option<Box<Vec<Comment>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CommentConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CommentEdge {
    pub node: Option<Box<Comment>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CommentEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CommentPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The comment that was created or updated.
    pub comment: Option<Box<Comment>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CommentPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ContactPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ContactPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CreateCsvExportReportPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CreateCsvExportReportPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CreateOrJoinOrganizationResponse {
    pub organization: Option<Box<AuthOrganization>>,
    pub user: Option<Box<AuthUser>>,
}
impl GraphQLFields for CreateOrJoinOrganizationResponse {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// A custom view that has been saved by a user.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomView {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the custom view.
    pub name: Option<String>,
    /// The description of the custom view.
    pub description: Option<String>,
    /// The icon of the custom view.
    pub icon: Option<String>,
    /// The color of the icon of the custom view.
    pub color: Option<String>,
    /// The organization of the custom view.
    pub organization: Option<Box<Organization>>,
    /// The user who created the custom view.
    pub creator: Option<Box<User>>,
    /// The user who owns the custom view.
    pub owner: Option<Box<User>>,
    /// The user who last updated the custom view.
    pub updated_by: Option<Box<User>>,
    /// The filters applied to issues in the custom view.
    pub filters: Option<serde_json::Value>,
    /// The filter applied to issues in the custom view.
    pub filter_data: Option<serde_json::Value>,
    /// The filter applied to projects in the custom view.
    pub project_filter_data: Option<serde_json::Value>,
    /// The filter applied to initiatives in the custom view.
    pub initiative_filter_data: Option<serde_json::Value>,
    /// The filter applied to feed items in the custom view.
    pub feed_item_filter_data: Option<serde_json::Value>,
    /// Whether the custom view is shared with everyone in the organization.
    pub shared: Option<bool>,
    /// The custom view's unique URL slug.
    pub slug_id: Option<String>,
    /// The model name of the custom view.
    pub model_name: Option<String>,
    /// `INTERNAL` The facet associated with the custom view.
    pub facet: Option<Box<Facet>>,
    /// The team associated with the custom view.
    pub team: Option<Box<Team>>,
    /// Projects associated with the custom view.
    pub projects: Option<Box<ProjectConnection>>,
    /// Issues associated with the custom view.
    pub issues: Option<Box<IssueConnection>>,
    /// Feed items associated with the custom view.
    pub updates: Option<Box<FeedItemConnection>>,
    /// The current users view preferences for this custom view.
    pub user_view_preferences: Option<Box<ViewPreferences>>,
    /// The organizations default view preferences for this custom view.
    pub organization_view_preferences: Option<Box<ViewPreferences>>,
    /// The calculated view preferences values for this custom view.
    pub view_preferences_values: Option<Box<ViewPreferencesValues>>,
    /// Initiatives associated with the custom view.
    pub initiatives: Option<Box<InitiativeConnection>>,
}
impl GraphQLFields for CustomView {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name description icon color filters filterData projectFilterData initiativeFilterData feedItemFilterData shared slugId modelName"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomViewConnection {
    pub edges: Option<Box<Vec<CustomViewEdge>>>,
    pub nodes: Option<Box<Vec<CustomView>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CustomViewConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomViewEdge {
    pub node: Option<Box<CustomView>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CustomViewEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomViewHasSubscribersPayload {
    /// Whether the custom view has subscribers.
    pub has_subscribers: Option<bool>,
}
impl GraphQLFields for CustomViewHasSubscribersPayload {
    type FullType = Self;
    fn selection() -> String {
        "hasSubscribers".into()
    }
}
/// A custom view notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomViewNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The custom view subscribed to.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for CustomViewNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomViewPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The custom view that was created or updated.
    pub custom_view: Option<Box<CustomView>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CustomViewPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomViewSuggestionPayload {
    /// The suggested view name.
    pub name: Option<String>,
    /// The suggested view description.
    pub description: Option<String>,
    /// The suggested view icon.
    pub icon: Option<String>,
}
impl GraphQLFields for CustomViewSuggestionPayload {
    type FullType = Self;
    fn selection() -> String {
        "name description icon".into()
    }
}
/// A customer whose needs will be tied to issues or projects.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Customer {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The customer's name.
    pub name: Option<String>,
    /// The customer's logo URL.
    pub logo_url: Option<String>,
    /// The domains associated with this customer.
    pub domains: Option<Vec<String>>,
    /// The ids of the customers in external systems.
    pub external_ids: Option<Vec<String>>,
    /// The ID of the Slack channel used to interact with the customer.
    pub slack_channel_id: Option<String>,
    /// The user who owns the customer.
    pub owner: Option<Box<User>>,
    /// The current status of the customer.
    pub status: Option<Box<CustomerStatus>>,
    /// The annual revenue generated by the customer.
    pub revenue: Option<i64>,
    /// The size of the customer.
    pub size: Option<f64>,
    /// The tier of the customer.
    pub tier: Option<Box<CustomerTier>>,
    /// The approximate number of needs of the customer.
    pub approximate_need_count: Option<f64>,
    /// The customer's unique URL slug.
    pub slug_id: Option<String>,
    /// The ID of the main source, when a customer has multiple sources. Must be one of externalIds.
    pub main_source_id: Option<String>,
    /// The integration that manages the Customer.
    pub integration: Option<Box<Integration>>,
    /// URL of the customer in Linear.
    pub url: Option<String>,
}
impl GraphQLFields for Customer {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name logoUrl domains externalIds slackChannelId revenue size approximateNeedCount slugId mainSourceId url"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerConnection {
    pub edges: Option<Box<Vec<CustomerEdge>>>,
    pub nodes: Option<Box<Vec<Customer>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CustomerConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerEdge {
    pub node: Option<Box<Customer>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CustomerEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A customer need, expressed through a reference to an issue, project, or comment.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeed {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The customer that this need is attached to.
    pub customer: Option<Box<Customer>>,
    /// The issue this need is referencing.
    pub issue: Option<Box<Issue>>,
    /// The project this need is referencing.
    pub project: Option<Box<Project>>,
    /// The comment this need is referencing.
    pub comment: Option<Box<Comment>>,
    /// The attachment this need is referencing.
    pub attachment: Option<Box<Attachment>>,
    /// The project attachment this need is referencing.
    pub project_attachment: Option<Box<ProjectAttachment>>,
    /// Whether the customer need is important or not. 0 = Not important, 1 = Important.
    pub priority: Option<f64>,
    /// The need content in markdown format.
    pub body: Option<String>,
    /// `Internal` The content of the need as a Prosemirror document.
    pub body_data: Option<String>,
    /// The creator of the customer need.
    pub creator: Option<Box<User>>,
    /// The issue this customer need was originally created on. Will be undefined if the customer need hasn't been moved.
    pub original_issue: Option<Box<Issue>>,
    /// The URL of the underlying attachment, if any
    pub url: Option<String>,
}
impl GraphQLFields for CustomerNeed {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt priority body bodyData url".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeedArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<CustomerNeed>>,
}
impl GraphQLFields for CustomerNeedArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeedConnection {
    pub edges: Option<Box<Vec<CustomerNeedEdge>>>,
    pub nodes: Option<Box<Vec<CustomerNeed>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CustomerNeedConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeedEdge {
    pub node: Option<Box<CustomerNeed>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CustomerNeedEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A customer need related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeedNotification {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related customer need.
    pub customer_need_id: Option<String>,
    /// The issue related to the notification.
    pub related_issue: Option<Box<Issue>>,
    /// The project related to the notification.
    pub related_project: Option<Box<Project>>,
    /// The customer need related to the notification.
    pub customer_need: Option<Box<CustomerNeed>>,
}
impl GraphQLFields for CustomerNeedNotification {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority customerNeedId"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeedPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The customer need that was created or updated.
    pub need: Option<Box<CustomerNeed>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CustomerNeedPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNeedUpdatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The customer need that was created or updated.
    pub need: Option<Box<CustomerNeed>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The related customer needs that were updated.
    pub updated_related_needs: Option<Box<Vec<CustomerNeed>>>,
}
impl GraphQLFields for CustomerNeedUpdatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A customer related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNotification {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related customer.
    pub customer_id: Option<String>,
    /// The customer related to the notification.
    pub customer: Option<Box<Customer>>,
}
impl GraphQLFields for CustomerNotification {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority customerId"
            .into()
    }
}
/// A customer notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer subscribed to.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for CustomerNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The customer that was created or updated.
    pub customer: Option<Box<Customer>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CustomerPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A customer status.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerStatus {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the status.
    pub name: Option<String>,
    /// The UI color of the status as a HEX string.
    pub color: Option<String>,
    /// Description of the status.
    pub description: Option<String>,
    /// The position of the status in the workspace's customers flow.
    pub position: Option<f64>,
    /// The display name of the status.
    pub display_name: Option<String>,
    /// The type of the customer status.
    pub r#type: Option<CustomerStatusType>,
}
impl GraphQLFields for CustomerStatus {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name color description position displayName type".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerStatusConnection {
    pub edges: Option<Box<Vec<CustomerStatusEdge>>>,
    pub nodes: Option<Box<Vec<CustomerStatus>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CustomerStatusConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerStatusEdge {
    pub node: Option<Box<CustomerStatus>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CustomerStatusEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerStatusPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The customer status that was created or updated.
    pub status: Option<Box<CustomerStatus>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CustomerStatusPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A customer tier.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerTier {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the tier.
    pub name: Option<String>,
    /// The UI color of the tier as a HEX string.
    pub color: Option<String>,
    /// Description of the tier.
    pub description: Option<String>,
    /// The position of the tier in the workspace's customers flow.
    pub position: Option<f64>,
    /// The display name of the tier.
    pub display_name: Option<String>,
}
impl GraphQLFields for CustomerTier {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name color description position displayName".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerTierConnection {
    pub edges: Option<Box<Vec<CustomerTierEdge>>>,
    pub nodes: Option<Box<Vec<CustomerTier>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CustomerTierConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerTierEdge {
    pub node: Option<Box<CustomerTier>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CustomerTierEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CustomerTierPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The customer tier that was created or updated.
    pub tier: Option<Box<CustomerTier>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CustomerTierPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A set of issues to be resolved in a specified amount of time.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Cycle {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The number of the cycle.
    pub number: Option<f64>,
    /// The custom name of the cycle.
    pub name: Option<String>,
    /// The cycle's description.
    pub description: Option<String>,
    /// The start time of the cycle.
    pub starts_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The end time of the cycle.
    pub ends_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The completion time of the cycle. If null, the cycle hasn't been completed.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the cycle was automatically archived by the auto pruning process.
    pub auto_archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The total number of issues in the cycle after each day.
    pub issue_count_history: Option<Vec<f64>>,
    /// The number of completed issues in the cycle after each day.
    pub completed_issue_count_history: Option<Vec<f64>>,
    /// The total number of estimation points after each day.
    pub scope_history: Option<Vec<f64>>,
    /// The number of completed estimation points after each day.
    pub completed_scope_history: Option<Vec<f64>>,
    /// The number of in progress estimation points after each day.
    pub in_progress_scope_history: Option<Vec<f64>>,
    /// The team that the cycle is associated with.
    pub team: Option<Box<Team>>,
    /// `Internal` The progress history of the cycle.
    pub progress_history: Option<serde_json::Value>,
    /// `Internal` The current progress of the cycle.
    pub current_progress: Option<serde_json::Value>,
    /// The cycle inherited from.
    pub inherited_from: Option<Box<Cycle>>,
    /// Whether the cycle is currently active.
    pub is_active: Option<bool>,
    /// Whether the cycle is in the future.
    pub is_future: Option<bool>,
    /// Whether the cycle is in the past.
    pub is_past: Option<bool>,
    /// Issues associated with the cycle.
    pub issues: Option<Box<IssueConnection>>,
    /// Issues that weren't completed when the cycle was closed.
    pub uncompleted_issues_upon_close: Option<Box<IssueConnection>>,
    /// The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
    pub progress: Option<f64>,
    /// Whether the cycle is the next cycle for the team.
    pub is_next: Option<bool>,
    /// Whether the cycle is the previous cycle for the team.
    pub is_previous: Option<bool>,
    /// `Internal` Documents associated with the cycle.
    pub documents: Option<Box<DocumentConnection>>,
    /// `Internal` Links associated with the cycle.
    pub links: Option<Box<EntityExternalLinkConnection>>,
}
impl GraphQLFields for Cycle {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt number name description startsAt endsAt completedAt autoArchivedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress isActive isFuture isPast progress isNext isPrevious"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CycleArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Cycle>>,
}
impl GraphQLFields for CycleArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CycleConnection {
    pub edges: Option<Box<Vec<CycleEdge>>>,
    pub nodes: Option<Box<Vec<Cycle>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for CycleConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CycleEdge {
    pub node: Option<Box<Cycle>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for CycleEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A cycle notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CycleNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The cycle subscribed to.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for CycleNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct CyclePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The Cycle that was created or updated.
    pub cycle: Option<Box<Cycle>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for CyclePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Internal` A dashboard, usually a collection of widgets to display several insights at once.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Dashboard {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The dashboard's unique URL slug.
    pub slug_id: Option<String>,
    /// The name of the dashboard.
    pub name: Option<String>,
    /// The description of the dashboard.
    pub description: Option<String>,
    /// The icon of the dashboard.
    pub icon: Option<String>,
    /// The color of the icon of the dashboard.
    pub color: Option<String>,
    /// The sort order of the dashboard within the organization or its team.
    pub sort_order: Option<f64>,
    /// Whether the dashboard is shared with everyone in the organization.
    pub shared: Option<bool>,
    /// The organization of the dashboard.
    pub organization: Option<Box<Organization>>,
    /// The user who created the dashboard.
    pub creator: Option<Box<User>>,
    /// The user who last updated the dashboard.
    pub updated_by: Option<Box<User>>,
    /// The owner of the dashboard.
    pub owner: Option<Box<User>>,
    /// The filter applied to all dashboard widgets showing issues data.
    pub issue_filter: Option<serde_json::Value>,
    /// The filter applied to all dashboard widgets showing projects data.
    pub project_filter: Option<serde_json::Value>,
    /// The widgets on the dashboard.
    pub widgets: Option<serde_json::Value>,
    /// The team associated with the dashboard.
    pub team: Option<Box<Team>>,
}
impl GraphQLFields for Dashboard {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt slugId name description icon color sortOrder shared issueFilter projectFilter widgets"
            .into()
    }
}
/// A generic payload return from entity deletion mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DeletePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The identifier of the deleted entity.
    pub entity_id: Option<String>,
}
impl GraphQLFields for DeletePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success entityId".into()
    }
}
/// A document that can be attached to different entities.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Document {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The document title.
    pub title: Option<String>,
    /// The icon of the document.
    pub icon: Option<String>,
    /// The color of the icon.
    pub color: Option<String>,
    /// The user who created the document.
    pub creator: Option<Box<User>>,
    /// The user who last updated the document.
    pub updated_by: Option<Box<User>>,
    /// The project that the document is associated with.
    pub project: Option<Box<Project>>,
    /// The initiative that the document is associated with.
    pub initiative: Option<Box<Initiative>>,
    /// `Internal` The team that the document is associated with.
    pub team: Option<Box<Team>>,
    /// The issue that the document is associated with.
    pub issue: Option<Box<Issue>>,
    /// `Internal` The release that the document is associated with.
    pub release: Option<Box<Release>>,
    /// `Internal` The cycle that the document is associated with.
    pub cycle: Option<Box<Cycle>>,
    /// The document's unique URL slug.
    pub slug_id: Option<String>,
    /// The last template that was applied to this document.
    pub last_applied_template: Option<Box<Template>>,
    /// The time at which the document was hidden. Null if the entity has not been hidden.
    pub hidden_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A flag that indicates whether the document is in the trash bin.
    pub trashed: Option<bool>,
    /// The order of the item in the resources list.
    pub sort_order: Option<f64>,
    /// Comments associated with the document.
    pub comments: Option<Box<CommentConnection>>,
    /// The documents content in markdown format.
    pub content: Option<String>,
    /// `Internal` The documents content as YJS state.
    pub content_state: Option<String>,
    /// The ID of the document content associated with the document.
    pub document_content_id: Option<String>,
    /// The canonical url for the document.
    pub url: Option<String>,
}
impl GraphQLFields for Document {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Document>>,
}
impl GraphQLFields for DocumentArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentConnection {
    pub edges: Option<Box<Vec<DocumentEdge>>>,
    pub nodes: Option<Box<Vec<Document>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for DocumentConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// A document content for a project.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentContent {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The document content in markdown format.
    pub content: Option<String>,
    /// The document content state as a base64 encoded string.
    pub content_state: Option<String>,
    /// The issue that the content is associated with.
    pub issue: Option<Box<Issue>>,
    /// `Internal` The pull request that the content is associated with.
    pub pull_request: Option<Box<PullRequest>>,
    /// The project that the content is associated with.
    pub project: Option<Box<Project>>,
    /// The initiative that the content is associated with.
    pub initiative: Option<Box<Initiative>>,
    /// The project milestone that the content is associated with.
    pub project_milestone: Option<Box<ProjectMilestone>>,
    /// The document that the content is associated with.
    pub document: Option<Box<Document>>,
    /// The AI prompt rules that the content is associated with.
    pub ai_prompt_rules: Option<Box<AiPromptRules>>,
    /// The welcome message that the content is associated with.
    pub welcome_message: Option<Box<WelcomeMessage>>,
    /// The time at which the document content was restored from a previous version.
    pub restored_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Comments associated with the document content.
    pub comments: Option<Box<CommentConnection>>,
    /// `ALPHA` The histories of the document content.
    pub history: Option<Box<DocumentContentHistoryConnection>>,
}
impl GraphQLFields for DocumentContent {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt content contentState restoredAt".into()
    }
}
/// A document content history for a document.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentContentHistory {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The document content that this history item is associated with.
    pub document_content: Option<Box<DocumentContent>>,
    /// `Internal` The document content as a Prosemirror document.
    pub content_data: Option<serde_json::Value>,
    /// IDs of actors whose edits went into this history item.
    pub actor_ids: Option<Vec<String>>,
    /// The timestamp associated with the DocumentContent when it was originally saved.
    pub content_data_snapshot_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for DocumentContentHistory {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contentData actorIds contentDataSnapshotAt".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentContentHistoryConnection {
    pub edges: Option<Box<Vec<DocumentContentHistoryEdge>>>,
    pub nodes: Option<Box<Vec<DocumentContentHistory>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for DocumentContentHistoryConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentContentHistoryEdge {
    pub node: Option<Box<DocumentContentHistory>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for DocumentContentHistoryEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentContentHistoryPayload {
    /// The document content history entries.
    pub history: Option<Box<Vec<DocumentContentHistoryType>>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for DocumentContentHistoryPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentContentHistoryType {
    /// The UUID of the document content history entry.
    pub id: Option<String>,
    /// The date when the document content history entry was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date when the document content history snapshot was taken. This can be different than createdAt since the content is captured from its state at the previously known updatedAt timestamp in the case of an update. On document create, these timestamps can be the same.
    pub content_data_snapshot_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` The document content as Prosemirror document.
    pub content_data: Option<serde_json::Value>,
    /// The ID of the author of the change.
    pub actor_ids: Option<Vec<String>>,
}
impl GraphQLFields for DocumentContentHistoryType {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt contentDataSnapshotAt contentData actorIds".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentEdge {
    pub node: Option<Box<Document>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for DocumentEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A document related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentNotification {
    /// Related comment ID. Null if the notification is not related to a comment.
    pub comment_id: Option<String>,
    /// Related parent comment ID. Null if the notification is not related to a comment.
    pub parent_comment_id: Option<String>,
    /// Name of the reaction emoji related to the notification.
    pub reaction_emoji: Option<String>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related document ID.
    pub document_id: Option<String>,
}
impl GraphQLFields for DocumentNotification {
    type FullType = Self;
    fn selection() -> String {
        "commentId parentCommentId reactionEmoji id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority documentId"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The document that was created or updated.
    pub document: Option<Box<Document>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for DocumentPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentSearchPayload {
    pub edges: Option<Box<Vec<DocumentSearchResultEdge>>>,
    pub nodes: Option<Box<Vec<DocumentSearchResult>>>,
    pub page_info: Option<Box<PageInfo>>,
    /// Archived entities matching the search term along with all their dependencies.
    pub archive_payload: Option<Box<ArchiveResponse>>,
    /// Total number of results for query without filters applied.
    pub total_count: Option<f64>,
}
impl GraphQLFields for DocumentSearchPayload {
    type FullType = Self;
    fn selection() -> String {
        "totalCount".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentSearchResult {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The document title.
    pub title: Option<String>,
    /// The icon of the document.
    pub icon: Option<String>,
    /// The color of the icon.
    pub color: Option<String>,
    /// The user who created the document.
    pub creator: Option<Box<User>>,
    /// The user who last updated the document.
    pub updated_by: Option<Box<User>>,
    /// The project that the document is associated with.
    pub project: Option<Box<Project>>,
    /// The initiative that the document is associated with.
    pub initiative: Option<Box<Initiative>>,
    /// `Internal` The team that the document is associated with.
    pub team: Option<Box<Team>>,
    /// The issue that the document is associated with.
    pub issue: Option<Box<Issue>>,
    /// `Internal` The release that the document is associated with.
    pub release: Option<Box<Release>>,
    /// `Internal` The cycle that the document is associated with.
    pub cycle: Option<Box<Cycle>>,
    /// The document's unique URL slug.
    pub slug_id: Option<String>,
    /// The last template that was applied to this document.
    pub last_applied_template: Option<Box<Template>>,
    /// The time at which the document was hidden. Null if the entity has not been hidden.
    pub hidden_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A flag that indicates whether the document is in the trash bin.
    pub trashed: Option<bool>,
    /// The order of the item in the resources list.
    pub sort_order: Option<f64>,
    /// Comments associated with the document.
    pub comments: Option<Box<CommentConnection>>,
    /// The documents content in markdown format.
    pub content: Option<String>,
    /// `Internal` The documents content as YJS state.
    pub content_state: Option<String>,
    /// The ID of the document content associated with the document.
    pub document_content_id: Option<String>,
    /// The canonical url for the document.
    pub url: Option<String>,
    /// Metadata related to search result.
    pub metadata: Option<serde_json::Value>,
}
impl GraphQLFields for DocumentSearchResult {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title icon color slugId hiddenAt trashed sortOrder content contentState documentContentId url metadata"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DocumentSearchResultEdge {
    pub node: Option<Box<DocumentSearchResult>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for DocumentSearchResultEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A general purpose draft. Used for comments, project updates, etc.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Draft {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The text content as a Prosemirror document.
    pub body_data: Option<serde_json::Value>,
    /// Additional properties for the draft.
    pub data: Option<serde_json::Value>,
    /// Whether the draft was autogenerated for the user.
    pub is_autogenerated: Option<bool>,
    /// `INTERNAL` Whether the draft was ported from a local draft.
    pub was_local_draft: Option<bool>,
    /// The user who created the draft.
    pub user: Option<Box<User>>,
    /// The issue for which this is a draft comment.
    pub issue: Option<Box<Issue>>,
    /// The project for which this is a draft project update.
    pub project: Option<Box<Project>>,
    /// The project update for which this is a draft comment.
    pub project_update: Option<Box<ProjectUpdate>>,
    /// The initiative for which this is a draft initiative update.
    pub initiative: Option<Box<Initiative>>,
    /// The initiative update for which this is a draft comment.
    pub initiative_update: Option<Box<InitiativeUpdate>>,
    /// The post for which this is a draft comment.
    pub post: Option<Box<Post>>,
    /// The comment for which this is a draft comment reply.
    pub parent_comment: Option<Box<Comment>>,
    /// The customer need that this draft is referencing.
    pub customer_need: Option<Box<CustomerNeed>>,
    /// `INTERNAL` Allows for multiple drafts per entity (currently constrained to Pull Requests).
    pub anchor: Option<String>,
    /// The team for which this is a draft post.
    pub team: Option<Box<Team>>,
}
impl GraphQLFields for Draft {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt bodyData data isAutogenerated wasLocalDraft anchor"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DraftConnection {
    pub edges: Option<Box<Vec<DraftEdge>>>,
    pub nodes: Option<Box<Vec<Draft>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for DraftConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct DraftEdge {
    pub node: Option<Box<Draft>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for DraftEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// An email address that can be used for submitting issues.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmailIntakeAddress {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Unique email address user name (before @) used for incoming email.
    pub address: Option<String>,
    /// The type of the email address.
    pub r#type: Option<EmailIntakeAddressType>,
    /// The email address used to forward emails to the intake address.
    pub forwarding_email_address: Option<String>,
    /// The name to be used for outgoing emails.
    pub sender_name: Option<String>,
    /// Whether the email address is enabled.
    pub enabled: Option<bool>,
    /// Whether email replies are enabled.
    pub replies_enabled: Option<bool>,
    /// Whether the commenter's name is included in the email replies.
    pub use_user_names_in_replies: Option<bool>,
    /// The template that the email address is associated with.
    pub template: Option<Box<Template>>,
    /// The team that the email address is associated with.
    pub team: Option<Box<Team>>,
    /// The organization that the email address is associated with.
    pub organization: Option<Box<Organization>>,
    /// The SES domain identity that the email address is associated with.
    pub ses_domain_identity: Option<Box<SesDomainIdentity>>,
    /// The user who created the email intake address.
    pub creator: Option<Box<User>>,
    /// Whether issues created from that email address will be turned into customer requests.
    pub customer_requests_enabled: Option<bool>,
    /// The auto-reply message for issue created. If not set, the default reply will be used.
    pub issue_created_auto_reply: Option<String>,
    /// Whether the auto-reply for issue created is enabled.
    pub issue_created_auto_reply_enabled: Option<bool>,
    /// Whether the auto-reply for issue completed is enabled.
    pub issue_completed_auto_reply_enabled: Option<bool>,
    /// The auto-reply message for issue completed. If not set, the default reply will be used.
    pub issue_completed_auto_reply: Option<String>,
    /// Whether the auto-reply for issue canceled is enabled.
    pub issue_canceled_auto_reply_enabled: Option<bool>,
    /// The auto-reply message for issue canceled. If not set, the default reply will be used.
    pub issue_canceled_auto_reply: Option<String>,
}
impl GraphQLFields for EmailIntakeAddress {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt address type forwardingEmailAddress senderName enabled repliesEnabled useUserNamesInReplies customerRequestsEnabled issueCreatedAutoReply issueCreatedAutoReplyEnabled issueCompletedAutoReplyEnabled issueCompletedAutoReply issueCanceledAutoReplyEnabled issueCanceledAutoReply"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmailIntakeAddressPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The email address that was created or updated.
    pub email_intake_address: Option<Box<EmailIntakeAddress>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for EmailIntakeAddressPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmailUnsubscribePayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for EmailUnsubscribePayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmailUserAccountAuthChallengeResponse {
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// Supported challenge for this user account. Can be either verificationCode or password.
    pub auth_type: Option<String>,
}
impl GraphQLFields for EmailUserAccountAuthChallengeResponse {
    type FullType = Self;
    fn selection() -> String {
        "success authType".into()
    }
}
/// A custom emoji.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Emoji {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The emoji's name.
    pub name: Option<String>,
    /// The emoji image URL.
    pub url: Option<String>,
    /// The source of the emoji.
    pub source: Option<String>,
    /// The user who created the emoji.
    pub creator: Option<Box<User>>,
    /// The organization that the emoji belongs to.
    pub organization: Option<Box<Organization>>,
}
impl GraphQLFields for Emoji {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name url source".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmojiConnection {
    pub edges: Option<Box<Vec<EmojiEdge>>>,
    pub nodes: Option<Box<Vec<Emoji>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for EmojiConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmojiEdge {
    pub node: Option<Box<Emoji>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for EmojiEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EmojiPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The emoji that was created.
    pub emoji: Option<Box<Emoji>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for EmojiPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An external link for an entity like initiative, etc...
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EntityExternalLink {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The link's URL.
    pub url: Option<String>,
    /// The link's label.
    pub label: Option<String>,
    /// The order of the item in the resources list.
    pub sort_order: Option<f64>,
    /// The user who created the link.
    pub creator: Option<Box<User>>,
    /// The initiative that the link is associated with.
    pub initiative: Option<Box<Initiative>>,
}
impl GraphQLFields for EntityExternalLink {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt url label sortOrder".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EntityExternalLinkConnection {
    pub edges: Option<Box<Vec<EntityExternalLinkEdge>>>,
    pub nodes: Option<Box<Vec<EntityExternalLink>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for EntityExternalLinkConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EntityExternalLinkEdge {
    pub node: Option<Box<EntityExternalLink>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for EntityExternalLinkEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct EntityExternalLinkPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The link that was created or updated.
    pub entity_external_link: Option<Box<EntityExternalLink>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for EntityExternalLinkPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Information about an external entity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalEntityInfo {
    /// The id of the external entity.
    pub id: Option<String>,
    /// The name of the service this entity is synced with.
    pub service: Option<ExternalSyncService>,
}
impl GraphQLFields for ExternalEntityInfo {
    type FullType = Self;
    fn selection() -> String {
        "id service".into()
    }
}
/// Metadata about the external GitHub entity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalEntityInfoGithubMetadata {
    /// The repository name.
    pub repo: Option<String>,
    /// The owner of the repository.
    pub owner: Option<String>,
    /// The number of the issue.
    pub number: Option<f64>,
}
impl GraphQLFields for ExternalEntityInfoGithubMetadata {
    type FullType = Self;
    fn selection() -> String {
        "repo owner number".into()
    }
}
/// Metadata about the external Jira entity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalEntityInfoJiraMetadata {
    /// The key of the Jira issue.
    pub issue_key: Option<String>,
    /// The id of the Jira project.
    pub project_id: Option<String>,
    /// The id of the Jira issue type.
    pub issue_type_id: Option<String>,
}
impl GraphQLFields for ExternalEntityInfoJiraMetadata {
    type FullType = Self;
    fn selection() -> String {
        "issueKey projectId issueTypeId".into()
    }
}
/// Metadata about the external Slack entity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalEntitySlackMetadata {
    /// Whether the entity originated from Slack (not Linear).
    pub is_from_slack: Option<bool>,
    /// The id of the Slack channel.
    pub channel_id: Option<String>,
    /// The name of the Slack channel.
    pub channel_name: Option<String>,
    /// The URL of the Slack message.
    pub message_url: Option<String>,
}
impl GraphQLFields for ExternalEntitySlackMetadata {
    type FullType = Self;
    fn selection() -> String {
        "isFromSlack channelId channelName messageUrl".into()
    }
}
/// An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can create and update entities in Linear from the external system that authenticated them.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalUser {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The external user's full name.
    pub name: Option<String>,
    /// The external user's display name. Unique within each organization. Can match the display name of an actual user.
    pub display_name: Option<String>,
    /// The external user's email address.
    pub email: Option<String>,
    /// An URL to the external user's avatar image.
    pub avatar_url: Option<String>,
    /// Organization the external user belongs to.
    pub organization: Option<Box<Organization>>,
    /// The last time the external user was seen interacting with Linear.
    pub last_seen: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for ExternalUser {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name displayName email avatarUrl lastSeen".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalUserConnection {
    pub edges: Option<Box<Vec<ExternalUserEdge>>>,
    pub nodes: Option<Box<Vec<ExternalUser>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ExternalUserConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ExternalUserEdge {
    pub node: Option<Box<ExternalUser>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ExternalUserEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A facet. Facets are joins between entities. A facet can tie a custom view to a project, or a a project to a roadmap for example.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Facet {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The sort order of the facet.
    pub sort_order: Option<f64>,
    /// The owning organization.
    pub source_organization: Option<Box<Organization>>,
    /// The owning team.
    pub source_team: Option<Box<Team>>,
    /// The owning project.
    pub source_project: Option<Box<Project>>,
    /// The owning initiative.
    pub source_initiative: Option<Box<Initiative>>,
    /// The owning feed user.
    pub source_feed_user: Option<Box<User>>,
    /// The owning page.
    pub source_page: Option<FacetPageSource>,
    /// The targeted custom view.
    pub target_custom_view: Option<Box<CustomView>>,
}
impl GraphQLFields for Facet {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt sortOrder sourcePage".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FacetConnection {
    pub edges: Option<Box<Vec<FacetEdge>>>,
    pub nodes: Option<Box<Vec<Facet>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for FacetConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FacetEdge {
    pub node: Option<Box<Facet>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for FacetEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// User favorites presented in the sidebar.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Favorite {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of the favorite.
    pub r#type: Option<String>,
    /// The parent folder of the favorite.
    pub parent: Option<Box<Favorite>>,
    /// The name of the folder. Only applies to favorites of type folder.
    pub folder_name: Option<String>,
    /// The targeted tab of the project.
    pub project_tab: Option<ProjectTab>,
    /// The type of favorited predefined view.
    pub predefined_view_type: Option<String>,
    /// The targeted tab of the initiative.
    pub initiative_tab: Option<InitiativeTab>,
    /// The owner of the favorite.
    pub owner: Option<Box<User>>,
    /// The order of the item in the favorites list.
    pub sort_order: Option<f64>,
    /// Children of the favorite. Only applies to favorites of type folder.
    pub children: Option<Box<FavoriteConnection>>,
    /// The favorited issue.
    pub issue: Option<Box<Issue>>,
    /// The favorited project.
    pub project: Option<Box<Project>>,
    /// `INTERNAL` The favorited facet.
    pub facet: Option<Box<Facet>>,
    /// `DEPRECATED` The favorited team of the project.
    pub project_team: Option<Box<Team>>,
    /// The favorited cycle.
    pub cycle: Option<Box<Cycle>>,
    /// The favorited custom view.
    pub custom_view: Option<Box<CustomView>>,
    /// The team of the favorited predefined view.
    pub predefined_view_team: Option<Box<Team>>,
    /// The favorited document.
    pub document: Option<Box<Document>>,
    /// The favorited initiative.
    pub initiative: Option<Box<Initiative>>,
    /// The favorited label.
    pub label: Option<Box<IssueLabel>>,
    /// The favorited project label.
    pub project_label: Option<Box<ProjectLabel>>,
    /// The favorited user.
    pub user: Option<Box<User>>,
    /// The favorited customer.
    pub customer: Option<Box<Customer>>,
    /// The favorited dashboard.
    pub dashboard: Option<Box<Dashboard>>,
    /// The favorited pull request.
    pub pull_request: Option<Box<PullRequest>>,
    /// `ALPHA` The favorited release.
    pub release: Option<Box<Release>>,
    /// `ALPHA` The favorited release pipeline.
    pub release_pipeline: Option<Box<ReleasePipeline>>,
    /// URL of the favorited entity. Folders return 'null' value.
    pub url: Option<String>,
    /// `Internal` Favorite's title text (name of the favorite'd object or folder).
    pub title: Option<String>,
    /// `Internal` Detail text for favorite's `title` (e.g. team's name for a project).
    pub detail: Option<String>,
    /// `Internal` Returns the color of the favorite's icon. Unavailable for avatars and views with fixed icons (e.g. cycle).
    pub color: Option<String>,
    /// `Internal` Name of the favorite's icon. Unavailable for standard views, issues, and avatars
    pub icon: Option<String>,
}
impl GraphQLFields for Favorite {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type folderName projectTab predefinedViewType initiativeTab sortOrder url title detail color icon"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FavoriteConnection {
    pub edges: Option<Box<Vec<FavoriteEdge>>>,
    pub nodes: Option<Box<Vec<Favorite>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for FavoriteConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FavoriteEdge {
    pub node: Option<Box<Favorite>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for FavoriteEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FavoritePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The object that was added as a favorite.
    pub favorite: Option<Box<Favorite>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for FavoritePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Internal` An item in a users feed.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FeedItem {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The organization that will see this feed item.
    pub organization: Option<Box<Organization>>,
    /// The user that will see this feed item.
    pub user: Option<Box<User>>,
    /// The team that will see this feed item.
    pub team: Option<Box<Team>>,
    /// The project update that is in the feed.
    pub project_update: Option<Box<ProjectUpdate>>,
    /// The initiative update that is in the feed.
    pub initiative_update: Option<Box<InitiativeUpdate>>,
    /// The post that is in the feed.
    pub post: Option<Box<Post>>,
}
impl GraphQLFields for FeedItem {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FeedItemConnection {
    pub edges: Option<Box<Vec<FeedItemEdge>>>,
    pub nodes: Option<Box<Vec<FeedItem>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for FeedItemConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FeedItemEdge {
    pub node: Option<Box<FeedItem>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for FeedItemEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FetchDataPayload {
    /// The fetched data based on the natural language query.
    pub data: Option<serde_json::Value>,
    /// The GraphQL query used to fetch the data.
    pub query: Option<String>,
    /// The filters used to fetch the data.
    pub filters: Option<serde_json::Value>,
    /// Whether the fetch operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for FetchDataPayload {
    type FullType = Self;
    fn selection() -> String {
        "data query filters success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FileUploadDeletePayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for FileUploadDeletePayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct FrontAttachmentPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The issue attachment that was created.
    pub attachment: Option<Box<Attachment>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for FrontAttachmentPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A trigger that updates the issue status according to Git automations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitAutomationState {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The associated workflow state.
    pub state: Option<Box<WorkflowState>>,
    /// The team to which this automation state belongs.
    pub team: Option<Box<Team>>,
    /// The target branch associated to this automation state.
    pub target_branch: Option<Box<GitAutomationTargetBranch>>,
    /// The event that triggers the automation.
    pub event: Option<GitAutomationStates>,
    /// `DEPRECATED` The target branch, if null, the automation will be triggered on any branch.
    pub branch_pattern: Option<String>,
}
impl GraphQLFields for GitAutomationState {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt event branchPattern".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitAutomationStateConnection {
    pub edges: Option<Box<Vec<GitAutomationStateEdge>>>,
    pub nodes: Option<Box<Vec<GitAutomationState>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for GitAutomationStateConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitAutomationStateEdge {
    pub node: Option<Box<GitAutomationState>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for GitAutomationStateEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitAutomationStatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The automation state that was created or updated.
    pub git_automation_state: Option<Box<GitAutomationState>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for GitAutomationStatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A Git target branch for which there are automations (GitAutomationState).
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitAutomationTargetBranch {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The team to which this Git target branch automation belongs.
    pub team: Option<Box<Team>>,
    /// The target branch pattern.
    pub branch_pattern: Option<String>,
    /// Whether the branch pattern is a regular expression.
    pub is_regex: Option<bool>,
    /// Automation states associated with the target branch.
    pub automation_states: Option<Box<GitAutomationStateConnection>>,
}
impl GraphQLFields for GitAutomationTargetBranch {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt branchPattern isRegex".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitAutomationTargetBranchPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The Git target branch automation that was created or updated.
    pub target_branch: Option<Box<GitAutomationTargetBranch>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for GitAutomationTargetBranchPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitHubCommitIntegrationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The webhook secret to provide to GitHub.
    pub webhook_secret: Option<String>,
}
impl GraphQLFields for GitHubCommitIntegrationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success webhookSecret".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitHubEnterpriseServerInstallVerificationPayload {
    /// Has the install been successful.
    pub success: Option<bool>,
}
impl GraphQLFields for GitHubEnterpriseServerInstallVerificationPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitHubEnterpriseServerPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The setup address.
    pub setup_url: Option<String>,
    /// The app install address.
    pub install_url: Option<String>,
    /// The webhook secret to provide to GitHub.
    pub webhook_secret: Option<String>,
}
impl GraphQLFields for GitHubEnterpriseServerPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success setupUrl installUrl webhookSecret".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitLabIntegrationCreatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The webhook secret to provide to GitLab.
    pub webhook_secret: Option<String>,
    /// Error message if the connection failed.
    pub error: Option<String>,
    /// Response body from GitLab for debugging.
    pub error_response_body: Option<String>,
    /// Response headers from GitLab for debugging (JSON stringified).
    pub error_response_headers: Option<String>,
}
impl GraphQLFields for GitLabIntegrationCreatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success webhookSecret error errorResponseBody errorResponseHeaders".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct GitLabTestConnectionPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// Error message if the connection test failed.
    pub error: Option<String>,
    /// Response body from GitLab for debugging.
    pub error_response_body: Option<String>,
    /// Response headers from GitLab for debugging (JSON stringified).
    pub error_response_headers: Option<String>,
}
impl GraphQLFields for GitLabTestConnectionPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success error errorResponseBody errorResponseHeaders".into()
    }
}
/// An identity provider.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IdentityProvider {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the identity provider is the default identity provider migrated from organization level settings.
    pub default_migrated: Option<bool>,
    /// The type of identity provider.
    pub r#type: Option<IdentityProviderType>,
    /// Whether SAML authentication is enabled for organization.
    pub saml_enabled: Option<bool>,
    /// Sign in endpoint URL for the identity provider.
    pub sso_endpoint: Option<String>,
    /// Binding method for authentication call. Can be either `post` (default) or `redirect`.
    pub sso_binding: Option<String>,
    /// The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
    pub sso_sign_algo: Option<String>,
    /// X.509 Signing Certificate in string form.
    pub sso_signing_cert: Option<String>,
    /// The issuer's custom entity ID.
    pub issuer_entity_id: Option<String>,
    /// The service provider (Linear) custom entity ID. Defaults to <https://auth.linear.app/sso>
    pub sp_entity_id: Option<String>,
    /// The SAML priority used to pick default workspace in SAML SP initiated flow, when same domain is claimed for SAML by multiple workspaces. Lower priority value means higher preference.
    pub priority: Option<f64>,
    /// Whether SCIM provisioning is enabled for organization.
    pub scim_enabled: Option<bool>,
    /// `INTERNAL` SCIM owners group push settings.
    pub owners_group_push: Option<serde_json::Value>,
    /// `INTERNAL` SCIM admins group push settings.
    pub admins_group_push: Option<serde_json::Value>,
    /// `INTERNAL` SCIM guests group push settings.
    pub guests_group_push: Option<serde_json::Value>,
    /// Whether users are allowed to change their name and display name even if SCIM is enabled.
    pub allow_name_change: Option<bool>,
}
impl GraphQLFields for IdentityProvider {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt defaultMigrated type samlEnabled ssoEndpoint ssoBinding ssoSignAlgo ssoSigningCert issuerEntityId spEntityId priority scimEnabled ownersGroupPush adminsGroupPush guestsGroupPush allowNameChange"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ImageUploadFromUrlPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The URL containing the image.
    pub url: Option<String>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ImageUploadFromUrlPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId url success".into()
    }
}
/// An initiative to group projects.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Initiative {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
    pub update_reminder_frequency_in_weeks: Option<f64>,
    /// The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
    pub update_reminder_frequency: Option<f64>,
    /// The resolution of the reminder frequency.
    pub frequency_resolution: Option<FrequencyResolutionType>,
    /// The day at which to prompt for updates.
    pub update_reminders_day: Option<Day>,
    /// The hour at which to prompt for updates.
    pub update_reminders_hour: Option<f64>,
    /// The name of the initiative.
    pub name: Option<String>,
    /// The description of the initiative.
    pub description: Option<String>,
    /// The organization of the initiative.
    pub organization: Option<Box<Organization>>,
    /// The user who created the initiative.
    pub creator: Option<Box<User>>,
    /// The user who owns the initiative.
    pub owner: Option<Box<User>>,
    /// The initiative's unique URL slug.
    pub slug_id: Option<String>,
    /// The sort order of the initiative within the organization.
    pub sort_order: Option<f64>,
    /// The initiative's color.
    pub color: Option<String>,
    /// The icon of the initiative.
    pub icon: Option<String>,
    /// A flag that indicates whether the initiative is in the trash bin.
    pub trashed: Option<bool>,
    /// `Internal` Facets associated with the initiative.
    pub facets: Option<Box<Vec<Facet>>>,
    /// The estimated completion date of the initiative.
    pub target_date: Option<chrono::NaiveDate>,
    /// The resolution of the initiative's estimated completion date.
    pub target_date_resolution: Option<DateResolutionType>,
    /// The status of the initiative. One of Planned, Active, Completed
    pub status: Option<InitiativeStatus>,
    /// The last initiative update posted for this initiative.
    pub last_update: Option<Box<InitiativeUpdate>>,
    /// The health of the initiative.
    pub health: Option<InitiativeUpdateHealthType>,
    /// The time at which the initiative health was updated.
    pub health_updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the initiative was moved into active status.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the initiative was moved into completed status.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Initiative URL.
    pub url: Option<String>,
    /// Projects associated with the initiative.
    pub projects: Option<Box<ProjectConnection>>,
    /// Links associated with the initiative.
    pub links: Option<Box<EntityExternalLinkConnection>>,
    /// Settings for all integrations associated with that initiative.
    pub integrations_settings: Option<Box<IntegrationsSettings>>,
    /// History entries associated with the initiative.
    pub history: Option<Box<InitiativeHistoryConnection>>,
    /// Initiative updates associated with the initiative.
    pub initiative_updates: Option<Box<InitiativeUpdateConnection>>,
    /// Sub-initiatives associated with the initiative.
    pub sub_initiatives: Option<Box<InitiativeConnection>>,
    /// Parent initiative associated with the initiative.
    pub parent_initiative: Option<Box<Initiative>>,
    /// `Internal` Parent initiatives associated with the initiative.
    pub parent_initiatives: Option<Box<InitiativeConnection>>,
    /// The initiative's content in markdown format.
    pub content: Option<String>,
    /// The content of the initiative description.
    pub document_content: Option<Box<DocumentContent>>,
    /// Documents associated with the initiative.
    pub documents: Option<Box<DocumentConnection>>,
}
impl GraphQLFields for Initiative {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId sortOrder color icon trashed targetDate targetDateResolution status health healthUpdatedAt startedAt completedAt url content"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Initiative>>,
}
impl GraphQLFields for InitiativeArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeConnection {
    pub edges: Option<Box<Vec<InitiativeEdge>>>,
    pub nodes: Option<Box<Vec<Initiative>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for InitiativeConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeEdge {
    pub node: Option<Box<Initiative>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for InitiativeEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A initiative history containing relevant change events.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeHistory {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The events that happened while recording that history.
    pub entries: Option<serde_json::Value>,
    /// The initiative that the history is associated with.
    pub initiative: Option<Box<Initiative>>,
}
impl GraphQLFields for InitiativeHistory {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt entries".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeHistoryConnection {
    pub edges: Option<Box<Vec<InitiativeHistoryEdge>>>,
    pub nodes: Option<Box<Vec<InitiativeHistory>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for InitiativeHistoryConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeHistoryEdge {
    pub node: Option<Box<InitiativeHistory>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for InitiativeHistoryEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// An initiative related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeNotification {
    /// Related comment ID. Null if the notification is not related to a comment.
    pub comment_id: Option<String>,
    /// Related parent comment ID. Null if the notification is not related to a comment.
    pub parent_comment_id: Option<String>,
    /// Name of the reaction emoji related to the notification.
    pub reaction_emoji: Option<String>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related initiative ID.
    pub initiative_id: Option<String>,
    /// Related initiative update ID.
    pub initiative_update_id: Option<String>,
    /// The initiative related to the notification.
    pub initiative: Option<Box<Initiative>>,
    /// The document related to the notification.
    pub document: Option<Box<Document>>,
    /// The initiative update related to the notification.
    pub initiative_update: Option<Box<InitiativeUpdate>>,
    /// The comment related to the notification.
    pub comment: Option<Box<Comment>>,
    /// The parent comment related to the notification, if a notification is a reply comment notification.
    pub parent_comment: Option<Box<Comment>>,
}
impl GraphQLFields for InitiativeNotification {
    type FullType = Self;
    fn selection() -> String {
        "commentId parentCommentId reactionEmoji id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority initiativeId initiativeUpdateId"
            .into()
    }
}
/// An initiative notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The initiative subscribed to.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for InitiativeNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
/// The payload returned by the initiative mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The initiative that was created or updated.
    pub initiative: Option<Box<Initiative>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for InitiativePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A relation representing the dependency between two initiatives.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeRelation {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The parent initiative.
    pub initiative: Option<Box<Initiative>>,
    /// The child initiative.
    pub related_initiative: Option<Box<Initiative>>,
    /// The last user who created or modified the relation.
    pub user: Option<Box<User>>,
    /// The sort order of the relation within the initiative.
    pub sort_order: Option<f64>,
}
impl GraphQLFields for InitiativeRelation {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt sortOrder".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeRelationConnection {
    pub edges: Option<Box<Vec<InitiativeRelationEdge>>>,
    pub nodes: Option<Box<Vec<InitiativeRelation>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for InitiativeRelationConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeRelationEdge {
    pub node: Option<Box<InitiativeRelation>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for InitiativeRelationEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeRelationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The initiative relation that was created or updated.
    pub initiative_relation: Option<Box<InitiativeRelation>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for InitiativeRelationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Join table between projects and initiatives.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeToProject {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The project that the initiative is associated with.
    pub project: Option<Box<Project>>,
    /// The initiative that the project is associated with.
    pub initiative: Option<Box<Initiative>>,
    /// The sort order of the project within the initiative.
    pub sort_order: Option<String>,
}
impl GraphQLFields for InitiativeToProject {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt sortOrder".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeToProjectConnection {
    pub edges: Option<Box<Vec<InitiativeToProjectEdge>>>,
    pub nodes: Option<Box<Vec<InitiativeToProject>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for InitiativeToProjectConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeToProjectEdge {
    pub node: Option<Box<InitiativeToProject>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for InitiativeToProjectEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// The result of a initiativeToProject mutation.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeToProjectPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The initiativeToProject that was created or updated.
    pub initiative_to_project: Option<Box<InitiativeToProject>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for InitiativeToProjectPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An initiative update.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeUpdate {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The update content in markdown format.
    pub body: Option<String>,
    /// The time the update was edited.
    pub edited_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Emoji reaction summary, grouped by emoji type.
    pub reaction_data: Option<serde_json::Value>,
    /// `Internal` The content of the update as a Prosemirror document.
    pub body_data: Option<String>,
    /// The update's unique URL slug.
    pub slug_id: Option<String>,
    /// The initiative that the update is associated with.
    pub initiative: Option<Box<Initiative>>,
    /// The user who wrote the update.
    pub user: Option<Box<User>>,
    /// The health at the time of the update.
    pub health: Option<InitiativeUpdateHealthType>,
    /// `Internal` Serialized JSON representing current state of the initiative properties when posting the initiative update.
    pub info_snapshot: Option<serde_json::Value>,
    /// Whether initiative update diff should be hidden.
    pub is_diff_hidden: Option<bool>,
    /// The URL to the initiative update.
    pub url: Option<String>,
    /// Whether the initiative update is stale.
    pub is_stale: Option<bool>,
    /// The diff between the current update and the previous one.
    pub diff: Option<serde_json::Value>,
    /// The diff between the current update and the previous one, formatted as markdown.
    pub diff_markdown: Option<String>,
    /// Reactions associated with the initiative update.
    pub reactions: Option<Box<Vec<Reaction>>>,
    /// Comments associated with the initiative update.
    pub comments: Option<Box<CommentConnection>>,
    /// Number of comments associated with the initiative update.
    pub comment_count: Option<i64>,
}
impl GraphQLFields for InitiativeUpdate {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt body editedAt reactionData bodyData slugId health infoSnapshot isDiffHidden url isStale diff diffMarkdown commentCount"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeUpdateArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<InitiativeUpdate>>,
}
impl GraphQLFields for InitiativeUpdateArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeUpdateConnection {
    pub edges: Option<Box<Vec<InitiativeUpdateEdge>>>,
    pub nodes: Option<Box<Vec<InitiativeUpdate>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for InitiativeUpdateConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeUpdateEdge {
    pub node: Option<Box<InitiativeUpdate>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for InitiativeUpdateEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeUpdatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The initiative update that was created.
    pub initiative_update: Option<Box<InitiativeUpdate>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for InitiativeUpdatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct InitiativeUpdateReminderPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for InitiativeUpdateReminderPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An integration with an external service.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Integration {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The integration's type.
    pub service: Option<String>,
    /// The organization that the integration is associated with.
    pub organization: Option<Box<Organization>>,
    /// The team that the integration is associated with.
    pub team: Option<Box<Team>>,
    /// The user that added the integration.
    pub creator: Option<Box<User>>,
}
impl GraphQLFields for Integration {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt service".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationConnection {
    pub edges: Option<Box<Vec<IntegrationEdge>>>,
    pub nodes: Option<Box<Vec<Integration>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IntegrationConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationEdge {
    pub node: Option<Box<Integration>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IntegrationEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationHasScopesPayload {
    /// Whether the integration has the required scopes.
    pub has_all_scopes: Option<bool>,
    /// The missing scopes.
    pub missing_scopes: Option<Vec<String>>,
}
impl GraphQLFields for IntegrationHasScopesPayload {
    type FullType = Self;
    fn selection() -> String {
        "hasAllScopes missingScopes".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IntegrationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationRequestPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IntegrationRequestPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationSlackWorkspaceNamePayload {
    /// The current name of the Slack workspace.
    pub name: Option<String>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IntegrationSlackWorkspaceNamePayload {
    type FullType = Self;
    fn selection() -> String {
        "name success".into()
    }
}
/// Join table between templates and integrations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationTemplate {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The template that the integration is associated with.
    pub template: Option<Box<Template>>,
    /// The integration that the template is associated with.
    pub integration: Option<Box<Integration>>,
    /// ID of the foreign entity in the external integration this template is for, e.g., Slack channel ID.
    pub foreign_entity_id: Option<String>,
}
impl GraphQLFields for IntegrationTemplate {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt foreignEntityId".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationTemplateConnection {
    pub edges: Option<Box<Vec<IntegrationTemplateEdge>>>,
    pub nodes: Option<Box<Vec<IntegrationTemplate>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IntegrationTemplateConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationTemplateEdge {
    pub node: Option<Box<IntegrationTemplate>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IntegrationTemplateEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationTemplatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The IntegrationTemplate that was created or updated.
    pub integration_template: Option<Box<IntegrationTemplate>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IntegrationTemplatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// The configuration of all integrations for different entities.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationsSettings {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of view to which the integration settings context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// Whether to send a Slack message when a new issue is created for the project or the team.
    pub slack_issue_created: Option<bool>,
    /// Whether to send a Slack message when a comment is created on any of the project or team's issues.
    pub slack_issue_new_comment: Option<bool>,
    /// Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
    pub slack_issue_status_changed_done: Option<bool>,
    /// Whether to send a Slack message when an issue is added to the custom view.
    pub slack_issue_added_to_view: Option<bool>,
    /// Whether to send a Slack message when any of the project or team's issues has a change in status.
    pub slack_issue_status_changed_all: Option<bool>,
    /// Whether to send a Slack message when a project update is created.
    pub slack_project_update_created: Option<bool>,
    /// Whether to send a new project update to team Slack channels.
    pub slack_project_update_created_to_team: Option<bool>,
    /// Whether to send a new project update to workspace Slack channel.
    pub slack_project_update_created_to_workspace: Option<bool>,
    /// Whether to send a Slack message when a initiate update is created.
    pub slack_initiative_update_created: Option<bool>,
    /// Whether to send a Slack message when a new issue is added to triage.
    pub slack_issue_added_to_triage: Option<bool>,
    /// Whether to send a Slack message when an SLA is at high risk.
    pub slack_issue_sla_high_risk: Option<bool>,
    /// Whether to send a Slack message when an SLA is breached.
    pub slack_issue_sla_breached: Option<bool>,
    /// Team which those settings apply to.
    pub team: Option<Box<Team>>,
    /// Project which those settings apply to.
    pub project: Option<Box<Project>>,
    /// Initiative which those settings apply to.
    pub initiative: Option<Box<Initiative>>,
}
impl GraphQLFields for IntegrationsSettings {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType slackIssueCreated slackIssueNewComment slackIssueStatusChangedDone slackIssueAddedToView slackIssueStatusChangedAll slackProjectUpdateCreated slackProjectUpdateCreatedToTeam slackProjectUpdateCreatedToWorkspace slackInitiativeUpdateCreated slackIssueAddedToTriage slackIssueSlaHighRisk slackIssueSlaBreached"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IntegrationsSettingsPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The settings that were created or updated.
    pub integrations_settings: Option<Box<IntegrationsSettings>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IntegrationsSettingsPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An issue.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Issue {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The issue's unique number.
    pub number: Option<f64>,
    /// The issue's title.
    pub title: Option<String>,
    /// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
    pub priority: Option<f64>,
    /// The estimate of the complexity of the issue..
    pub estimate: Option<f64>,
    /// The order of the item in its column on the board.
    pub board_order: Option<f64>,
    /// The order of the item in relation to other items in the organization.
    pub sort_order: Option<f64>,
    /// The order of the item in relation to other items in the organization, when ordered by priority.
    pub priority_sort_order: Option<f64>,
    /// The time at which the issue was moved into started state.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was moved into completed state.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue entered triage.
    pub started_triage_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue left triage.
    pub triaged_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was moved into canceled state.
    pub canceled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was automatically closed by the auto pruning process.
    pub auto_closed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was automatically archived by the auto pruning process.
    pub auto_archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date at which the issue is due.
    pub due_date: Option<chrono::NaiveDate>,
    /// The time at which the issue's SLA began.
    pub sla_started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA will enter medium risk state.
    pub sla_medium_risk_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA will enter high risk state.
    pub sla_high_risk_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA will breach.
    pub sla_breaches_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of SLA set on the issue. Calendar days or business days.
    pub sla_type: Option<String>,
    /// The time at which the issue was added to a project.
    pub added_to_project_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was added to a cycle.
    pub added_to_cycle_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was added to a team.
    pub added_to_team_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A flag that indicates whether the issue is in the trash bin.
    pub trashed: Option<bool>,
    /// The time until an issue will be snoozed in Triage view.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` The time at which the most recent suggestions for this issue were generated.
    pub suggestions_generated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` The activity summary information for this issue.
    pub activity_summary: Option<serde_json::Value>,
    /// `Internal` AI-generated activity summary for this issue.
    pub summary: Option<Box<Summary>>,
    /// Id of the labels associated with this issue.
    pub label_ids: Option<Vec<String>>,
    /// The team that the issue is associated with.
    pub team: Option<Box<Team>>,
    /// The cycle that the issue is associated with.
    pub cycle: Option<Box<Cycle>>,
    /// The project that the issue is associated with.
    pub project: Option<Box<Project>>,
    /// The projectMilestone that the issue is associated with.
    pub project_milestone: Option<Box<ProjectMilestone>>,
    /// The last template that was applied to this issue.
    pub last_applied_template: Option<Box<Template>>,
    /// The recurring issue template that created this issue.
    pub recurring_issue_template: Option<Box<Template>>,
    /// Previous identifiers of the issue if it has been moved between teams.
    pub previous_identifiers: Option<Vec<String>>,
    /// The user who created the issue.
    pub creator: Option<Box<User>>,
    /// The external user who created the issue.
    pub external_user_creator: Option<Box<ExternalUser>>,
    /// The user to whom the issue is assigned to.
    pub assignee: Option<Box<User>>,
    /// The agent user that is delegated to work on this issue.
    pub delegate: Option<Box<User>>,
    /// The user who snoozed the issue.
    pub snoozed_by: Option<Box<User>>,
    /// The workflow state that the issue is associated with.
    pub state: Option<Box<WorkflowState>>,
    /// The order of the item in the sub-issue list. Only set if the issue has a parent.
    pub sub_issue_sort_order: Option<f64>,
    /// Emoji reaction summary, grouped by emoji type.
    pub reaction_data: Option<serde_json::Value>,
    /// Label for the priority.
    pub priority_label: Option<String>,
    /// The comment that this issue was created from.
    pub source_comment: Option<Box<Comment>>,
    /// Integration type that created this issue, if applicable.
    pub integration_source_type: Option<IntegrationService>,
    /// Documents associated with the issue.
    pub documents: Option<Box<DocumentConnection>>,
    /// The bot that created the issue, if applicable.
    pub bot_actor: Option<Box<ActorBot>>,
    /// The users favorite associated with this issue.
    pub favorite: Option<Box<Favorite>>,
    /// Issue's human readable identifier (e.g. ENG-123).
    pub identifier: Option<String>,
    /// Issue URL.
    pub url: Option<String>,
    /// Suggested branch name for the issue.
    pub branch_name: Option<String>,
    /// Shared access metadata for this issue.
    pub shared_access: Option<Box<IssueSharedAccess>>,
    /// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
    pub customer_ticket_count: Option<i64>,
    /// Users who are subscribed to the issue.
    pub subscribers: Option<Box<UserConnection>>,
    /// The parent of the issue.
    pub parent: Option<Box<Issue>>,
    /// Children of the issue.
    pub children: Option<Box<IssueConnection>>,
    /// Comments associated with the issue.
    pub comments: Option<Box<CommentConnection>>,
    /// History entries associated with the issue.
    pub history: Option<Box<IssueHistoryConnection>>,
    /// Labels associated with this issue.
    pub labels: Option<Box<IssueLabelConnection>>,
    /// Relations associated with this issue.
    pub relations: Option<Box<IssueRelationConnection>>,
    /// Inverse relations associated with this issue.
    pub inverse_relations: Option<Box<IssueRelationConnection>>,
    /// Attachments associated with the issue.
    pub attachments: Option<Box<AttachmentConnection>>,
    /// Attachments previously associated with the issue before being moved to another issue.
    pub former_attachments: Option<Box<AttachmentConnection>>,
    /// The issue's description in markdown format.
    pub description: Option<String>,
    /// `Internal` The issue's description content as YJS state.
    pub description_state: Option<String>,
    /// `ALPHA` The document content representing this issue description.
    pub document_content: Option<Box<DocumentContent>>,
    /// Reactions associated with the issue.
    pub reactions: Option<Box<Vec<Reaction>>>,
    /// Customer needs associated with the issue.
    pub needs: Option<Box<CustomerNeedConnection>>,
    /// Customer needs previously associated with the issue before being moved to another issue.
    pub former_needs: Option<Box<CustomerNeedConnection>>,
    /// The external services the issue is synced with.
    pub synced_with: Option<Box<Vec<ExternalEntityInfo>>>,
    /// `Internal` Product Intelligence suggestions for the issue.
    pub suggestions: Option<Box<IssueSuggestionConnection>>,
    /// `Internal` Incoming product intelligence relation suggestions for the issue.
    pub incoming_suggestions: Option<Box<IssueSuggestionConnection>>,
    /// The internal user who requested creation of the Asks issue on behalf of the creator.
    pub asks_requester: Option<Box<User>>,
    /// The external user who requested creation of the Asks issue on behalf of the creator.
    pub asks_external_user_requester: Option<Box<ExternalUser>>,
    /// The issue's workflow states over time.
    pub state_history: Option<Box<IssueStateSpanConnection>>,
}
impl GraphQLFields for Issue {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Issue>>,
}
impl GraphQLFields for IssueArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueBatchPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The issues that were updated.
    pub issues: Option<Box<Vec<Issue>>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueBatchPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueConnection {
    pub edges: Option<Box<Vec<IssueEdge>>>,
    pub nodes: Option<Box<Vec<Issue>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// `Internal` A draft issue.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueDraft {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The draft's title.
    pub title: Option<String>,
    /// The draft's description in markdown format.
    pub description: Option<String>,
    /// The priority of the draft.
    pub priority: Option<f64>,
    /// The estimate of the complexity of the draft.
    pub estimate: Option<f64>,
    /// The date at which the issue would be due.
    pub due_date: Option<chrono::NaiveDate>,
    /// The IDs of labels added to the draft.
    pub label_ids: Option<Vec<String>>,
    /// The team associated with the draft.
    pub team_id: Option<String>,
    /// The cycle associated with the draft.
    pub cycle_id: Option<String>,
    /// The project associated with the draft.
    pub project_id: Option<String>,
    /// The project milestone associated with the draft.
    pub project_milestone_id: Option<String>,
    /// The user who created the draft.
    pub creator: Option<Box<User>>,
    /// The user assigned to the draft.
    pub assignee_id: Option<String>,
    /// The agent user delegated to work on the issue being drafted.
    pub delegate_id: Option<String>,
    /// The workflow state associated with the draft.
    pub state_id: Option<String>,
    /// The parent draft of the draft.
    pub parent: Option<Box<IssueDraft>>,
    /// The ID of the parent issue draft, if any.
    pub parent_id: Option<String>,
    /// The ID of the comment that the draft was created from.
    pub source_comment_id: Option<String>,
    /// The parent issue of the draft.
    pub parent_issue: Option<Box<Issue>>,
    /// The ID of the parent issue, if any.
    pub parent_issue_id: Option<String>,
    /// The order of items in the sub-draft list. Only set if the draft has `parent` set.
    pub sub_issue_sort_order: Option<f64>,
    /// Label for the priority.
    pub priority_label: Option<String>,
    /// `Internal` The draft's description as a Prosemirror document.
    pub description_data: Option<serde_json::Value>,
    /// Serialized array of JSONs representing attachments.
    pub attachments: Option<serde_json::Value>,
    /// Serialized array of JSONs representing customer needs.
    pub needs: Option<serde_json::Value>,
    /// Serialized array of JSONs representing the recurring issue's schedule.
    pub schedule: Option<serde_json::Value>,
    pub labels: Option<Box<IssueLabelConnection>>,
}
impl GraphQLFields for IssueDraft {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title description priority estimate dueDate labelIds teamId cycleId projectId projectMilestoneId assigneeId delegateId stateId parentId sourceCommentId parentIssueId subIssueSortOrder priorityLabel descriptionData attachments needs schedule"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueDraftConnection {
    pub edges: Option<Box<Vec<IssueDraftEdge>>>,
    pub nodes: Option<Box<Vec<IssueDraft>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueDraftConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueDraftEdge {
    pub node: Option<Box<IssueDraft>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueDraftEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueEdge {
    pub node: Option<Box<Issue>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueFilterSuggestionPayload {
    /// The json filter that is suggested.
    pub filter: Option<serde_json::Value>,
    /// The log id of the prompt, that created this filter.
    pub log_id: Option<String>,
}
impl GraphQLFields for IssueFilterSuggestionPayload {
    type FullType = Self;
    fn selection() -> String {
        "filter logId".into()
    }
}
/// A record of changes to an issue.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueHistory {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The issue that was changed.
    pub issue: Option<Box<Issue>>,
    /// The id of user who made these changes. If null, possibly means that the change made by an integration.
    pub actor_id: Option<String>,
    /// Whether the issue's description was updated.
    pub updated_description: Option<bool>,
    /// What the title was changed from.
    pub from_title: Option<String>,
    /// What the title was changed to.
    pub to_title: Option<String>,
    /// The id of user from whom the issue was re-assigned from.
    pub from_assignee_id: Option<String>,
    /// The id of user to whom the issue was assigned to.
    pub to_assignee_id: Option<String>,
    /// What the priority was changed from.
    pub from_priority: Option<f64>,
    /// What the priority was changed to.
    pub to_priority: Option<f64>,
    /// The id of team from which the issue was moved from.
    pub from_team_id: Option<String>,
    /// The id of team to which the issue was moved to.
    pub to_team_id: Option<String>,
    /// The id of previous parent of the issue.
    pub from_parent_id: Option<String>,
    /// The id of new parent of the issue.
    pub to_parent_id: Option<String>,
    /// The id of previous workflow state of the issue.
    pub from_state_id: Option<String>,
    /// The id of new workflow state of the issue.
    pub to_state_id: Option<String>,
    /// The id of previous cycle of the issue.
    pub from_cycle_id: Option<String>,
    /// The id of new cycle of the issue.
    pub to_cycle_id: Option<String>,
    /// The id of new project created from the issue.
    pub to_converted_project_id: Option<String>,
    /// The id of previous project of the issue.
    pub from_project_id: Option<String>,
    /// The id of new project of the issue.
    pub to_project_id: Option<String>,
    /// What the estimate was changed from.
    pub from_estimate: Option<f64>,
    /// What the estimate was changed to.
    pub to_estimate: Option<f64>,
    /// Whether the issue is archived at the time of this history entry.
    pub archived: Option<bool>,
    /// Whether the issue was trashed or un-trashed.
    pub trashed: Option<bool>,
    /// The id of linked attachment.
    pub attachment_id: Option<String>,
    /// ID's of labels that were added.
    pub added_label_ids: Option<Vec<String>>,
    /// ID's of labels that were removed.
    pub removed_label_ids: Option<Vec<String>>,
    /// `ALPHA` ID's of releases that the issue was added to.
    pub added_to_release_ids: Option<Vec<String>>,
    /// `ALPHA` ID's of releases that the issue was removed from.
    pub removed_from_release_ids: Option<Vec<String>>,
    /// Changed issue relationships.
    pub relation_changes: Option<Box<Vec<IssueRelationHistoryPayload>>>,
    /// Whether the issue was auto-closed.
    pub auto_closed: Option<bool>,
    /// Whether the issue was auto-archived.
    pub auto_archived: Option<bool>,
    /// What the due date was changed from.
    pub from_due_date: Option<chrono::NaiveDate>,
    /// What the due date was changed to.
    pub to_due_date: Option<chrono::NaiveDate>,
    /// The id of linked customer need.
    pub customer_need_id: Option<String>,
    /// `Internal` Serialized JSON representing changes for certain non-relational properties.
    pub changes: Option<serde_json::Value>,
    /// The actor that performed the actions. This field may be empty in the case of integrations or automations.
    pub actor: Option<Box<User>>,
    /// The actors that performed the actions. This field may be empty in the case of integrations or automations.
    pub actors: Option<Box<Vec<User>>>,
    /// The actors that edited the description of the issue, if any.
    pub description_updated_by: Option<Box<Vec<User>>>,
    /// The user that was unassigned from the issue.
    pub from_assignee: Option<Box<User>>,
    /// The user that was assigned to the issue.
    pub to_assignee: Option<Box<User>>,
    /// The cycle that the issue was moved from.
    pub from_cycle: Option<Box<Cycle>>,
    /// The cycle that the issue was moved to.
    pub to_cycle: Option<Box<Cycle>>,
    /// The new project created from the issue.
    pub to_converted_project: Option<Box<Project>>,
    /// The app user from whom the issue delegation was transferred.
    pub from_delegate: Option<Box<User>>,
    /// The app user to whom the issue delegation was transferred.
    pub to_delegate: Option<Box<User>>,
    /// The project that the issue was moved from.
    pub from_project: Option<Box<Project>>,
    /// The project that the issue was moved to.
    pub to_project: Option<Box<Project>>,
    /// The state that the issue was moved from.
    pub from_state: Option<Box<WorkflowState>>,
    /// The state that the issue was moved to.
    pub to_state: Option<Box<WorkflowState>>,
    /// The team that the issue was moved from.
    pub from_team: Option<Box<Team>>,
    /// The team that the issue was moved to.
    pub to_team: Option<Box<Team>>,
    /// The parent issue that the issue was moved from.
    pub from_parent: Option<Box<Issue>>,
    /// The parent issue that the issue was moved to.
    pub to_parent: Option<Box<Issue>>,
    /// The linked attachment.
    pub attachment: Option<Box<Attachment>>,
    /// The import record.
    pub issue_import: Option<Box<IssueImport>>,
    /// The users that were notified of the issue.
    pub triage_responsibility_notified_users: Option<Box<Vec<User>>>,
    /// Boolean indicating if the issue was auto-assigned using the triage responsibility feature.
    pub triage_responsibility_auto_assigned: Option<bool>,
    /// The team that triggered the triage responsibility action.
    pub triage_responsibility_team: Option<Box<Team>>,
    /// The project milestone that the issue was moved from.
    pub from_project_milestone: Option<Box<ProjectMilestone>>,
    /// The project milestone that the issue was moved to.
    pub to_project_milestone: Option<Box<ProjectMilestone>>,
    /// The time at which the issue's SLA was previously started.
    pub from_sla_started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA is now started.
    pub to_sla_started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The SLA breach time that was previously set on the issue.
    pub from_sla_breaches_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The SLA breach time that is now set on the issue.
    pub to_sla_breaches_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the issue had previously breached its SLA.
    pub from_sla_breached: Option<bool>,
    /// Whether the issue has now breached its SLA.
    pub to_sla_breached: Option<bool>,
    /// The type of SLA that was previously set on the issue.
    pub from_sla_type: Option<String>,
    /// The type of SLA that is now set on the issue.
    pub to_sla_type: Option<String>,
    /// The bot that performed the action.
    pub bot_actor: Option<Box<ActorBot>>,
    /// The labels that were added to the issue.
    pub added_labels: Option<Box<Vec<IssueLabel>>>,
    /// The labels that were removed from the issue.
    pub removed_labels: Option<Box<Vec<IssueLabel>>>,
    /// The releases that the issue was added to.
    pub added_to_releases: Option<Box<Vec<Release>>>,
    /// The releases that the issue was removed from.
    pub removed_from_releases: Option<Box<Vec<Release>>>,
    /// `INTERNAL` Metadata about the triage rule that made changes to the issue.
    pub triage_rule_metadata: Option<Box<IssueHistoryTriageRuleMetadata>>,
}
impl GraphQLFields for IssueHistory {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt actorId updatedDescription fromTitle toTitle fromAssigneeId toAssigneeId fromPriority toPriority fromTeamId toTeamId fromParentId toParentId fromStateId toStateId fromCycleId toCycleId toConvertedProjectId fromProjectId toProjectId fromEstimate toEstimate archived trashed attachmentId addedLabelIds removedLabelIds addedToReleaseIds removedFromReleaseIds autoClosed autoArchived fromDueDate toDueDate customerNeedId changes triageResponsibilityAutoAssigned fromSlaStartedAt toSlaStartedAt fromSlaBreachesAt toSlaBreachesAt fromSlaBreached toSlaBreached fromSlaType toSlaType"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueHistoryConnection {
    pub edges: Option<Box<Vec<IssueHistoryEdge>>>,
    pub nodes: Option<Box<Vec<IssueHistory>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueHistoryConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueHistoryEdge {
    pub node: Option<Box<IssueHistory>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueHistoryEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// An error that occurred during triage rule execution.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueHistoryTriageRuleError {
    /// The type of error that occurred.
    pub r#type: Option<TriageRuleErrorType>,
    /// The property that caused the error.
    pub property: Option<String>,
    /// Whether the conflict was for the same child label.
    pub conflict_for_same_child_label: Option<bool>,
    /// The team the issue was being moved from.
    pub from_team: Option<Box<Team>>,
    /// The team the issue was being moved to.
    pub to_team: Option<Box<Team>>,
    /// The conflicting labels.
    pub conflicting_labels: Option<Box<Vec<IssueLabel>>>,
}
impl GraphQLFields for IssueHistoryTriageRuleError {
    type FullType = Self;
    fn selection() -> String {
        "type property conflictForSameChildLabel".into()
    }
}
/// Metadata about a triage rule that made changes to an issue.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueHistoryTriageRuleMetadata {
    /// The error that occurred, if any.
    pub triage_rule_error: Option<Box<IssueHistoryTriageRuleError>>,
    /// The triage rule that triggered the issue update.
    pub updated_by_triage_rule: Option<Box<WorkflowDefinition>>,
}
impl GraphQLFields for IssueHistoryTriageRuleMetadata {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// An import job for data from an external service.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueImport {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// New team's name in cases when teamId not set.
    pub team_name: Option<String>,
    /// The id for the user that started the job.
    pub creator_id: Option<String>,
    /// The service from which data will be imported.
    pub service: Option<String>,
    /// The status for the import job.
    pub status: Option<String>,
    /// The data mapping configuration for the import job.
    pub mapping: Option<serde_json::Value>,
    /// User readable error message, if one has occurred during the import.
    pub error: Option<String>,
    /// Current step progress in % (0-100).
    pub progress: Option<f64>,
    /// File URL for the uploaded CSV for the import, if there is one.
    pub csv_file_url: Option<String>,
    /// Error code and metadata, if one has occurred during the import.
    pub error_metadata: Option<serde_json::Value>,
    /// Metadata related to import service.
    pub service_metadata: Option<serde_json::Value>,
    /// The display name of the import service.
    pub display_name: Option<String>,
}
impl GraphQLFields for IssueImport {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt teamName creatorId service status mapping error progress csvFileUrl errorMetadata serviceMetadata displayName"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueImportCheckPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueImportCheckPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueImportDeletePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The import job that was deleted.
    pub issue_import: Option<Box<IssueImport>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueImportDeletePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Whether a custom JQL query is valid or not
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueImportJqlCheckPayload {
    /// Returns true if the JQL query has been validated successfully, false otherwise
    pub success: Option<bool>,
    /// Returns an approximate number of issues matching the JQL query, if available
    pub count: Option<f64>,
    /// An error message returned by Jira when validating the JQL query.
    pub error: Option<String>,
}
impl GraphQLFields for IssueImportJqlCheckPayload {
    type FullType = Self;
    fn selection() -> String {
        "success count error".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueImportPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The import job that was created or updated.
    pub issue_import: Option<Box<IssueImport>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueImportPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Whether an issue import can be synced at the end of an import or not
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueImportSyncCheckPayload {
    /// Returns true if the import can be synced, false otherwise
    pub can_sync: Option<bool>,
    /// An error message with a root cause of why the import cannot be synced
    pub error: Option<String>,
}
impl GraphQLFields for IssueImportSyncCheckPayload {
    type FullType = Self;
    fn selection() -> String {
        "canSync error".into()
    }
}
/// Labels that can be associated with issues.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueLabel {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The label's name.
    pub name: Option<String>,
    /// The label's description.
    pub description: Option<String>,
    /// The label's color as a HEX string.
    pub color: Option<String>,
    /// Whether the label is a group.
    pub is_group: Option<bool>,
    /// The date when the label was last applied to an issue or project.
    pub last_applied_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` When the label was retired.
    pub retired_at: Option<chrono::DateTime<chrono::Utc>>,
    pub organization: Option<Box<Organization>>,
    /// The team that the label is associated with. If null, the label is associated with the global workspace.
    pub team: Option<Box<Team>>,
    /// The user who created the label.
    pub creator: Option<Box<User>>,
    /// The user who retired the label.
    pub retired_by: Option<Box<User>>,
    /// The parent label.
    pub parent: Option<Box<IssueLabel>>,
    /// The original label inherited from.
    pub inherited_from: Option<Box<IssueLabel>>,
    /// Issues associated with the label.
    pub issues: Option<Box<IssueConnection>>,
    /// Children of the label.
    pub children: Option<Box<IssueLabelConnection>>,
}
impl GraphQLFields for IssueLabel {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name description color isGroup lastAppliedAt retiredAt"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueLabelConnection {
    pub edges: Option<Box<Vec<IssueLabelEdge>>>,
    pub nodes: Option<Box<Vec<IssueLabel>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueLabelConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueLabelEdge {
    pub node: Option<Box<IssueLabel>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueLabelEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueLabelPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The label that was created or updated.
    pub issue_label: Option<Box<IssueLabel>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueLabelPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An issue related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueNotification {
    /// Related comment ID. Null if the notification is not related to a comment.
    pub comment_id: Option<String>,
    /// Related parent comment ID. Null if the notification is not related to a comment.
    pub parent_comment_id: Option<String>,
    /// Name of the reaction emoji related to the notification.
    pub reaction_emoji: Option<String>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related issue ID.
    pub issue_id: Option<String>,
    /// The issue related to the notification.
    pub issue: Option<Box<Issue>>,
    /// The comment related to the notification.
    pub comment: Option<Box<Comment>>,
    /// The parent comment related to the notification, if a notification is a reply comment notification.
    pub parent_comment: Option<Box<Comment>>,
    /// The team related to the issue notification.
    pub team: Option<Box<Team>>,
}
impl GraphQLFields for IssueNotification {
    type FullType = Self;
    fn selection() -> String {
        "commentId parentCommentId reactionEmoji id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority issueId"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssuePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The issue that was created or updated.
    pub issue: Option<Box<Issue>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssuePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssuePriorityValue {
    /// Priority's number value.
    pub priority: Option<i64>,
    /// Priority's label.
    pub label: Option<String>,
}
impl GraphQLFields for IssuePriorityValue {
    type FullType = Self;
    fn selection() -> String {
        "priority label".into()
    }
}
/// A relation between two issues.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueRelation {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The relationship of the issue with the related issue.
    pub r#type: Option<String>,
    /// The issue whose relationship is being described.
    pub issue: Option<Box<Issue>>,
    /// The related issue.
    pub related_issue: Option<Box<Issue>>,
}
impl GraphQLFields for IssueRelation {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueRelationConnection {
    pub edges: Option<Box<Vec<IssueRelationEdge>>>,
    pub nodes: Option<Box<Vec<IssueRelation>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueRelationConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueRelationEdge {
    pub node: Option<Box<IssueRelation>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueRelationEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// Issue relation history's payload.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueRelationHistoryPayload {
    /// The identifier of the related issue.
    pub identifier: Option<String>,
    /// The type of the change.
    pub r#type: Option<String>,
}
impl GraphQLFields for IssueRelationHistoryPayload {
    type FullType = Self;
    fn selection() -> String {
        "identifier type".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueRelationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The issue relation that was created or updated.
    pub issue_relation: Option<Box<IssueRelation>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueRelationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSearchPayload {
    pub edges: Option<Box<Vec<IssueSearchResultEdge>>>,
    pub nodes: Option<Box<Vec<IssueSearchResult>>>,
    pub page_info: Option<Box<PageInfo>>,
    /// Archived entities matching the search term along with all their dependencies.
    pub archive_payload: Option<Box<ArchiveResponse>>,
    /// Total number of results for query without filters applied.
    pub total_count: Option<f64>,
}
impl GraphQLFields for IssueSearchPayload {
    type FullType = Self;
    fn selection() -> String {
        "totalCount".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSearchResult {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The issue's unique number.
    pub number: Option<f64>,
    /// The issue's title.
    pub title: Option<String>,
    /// The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
    pub priority: Option<f64>,
    /// The estimate of the complexity of the issue..
    pub estimate: Option<f64>,
    /// The order of the item in its column on the board.
    pub board_order: Option<f64>,
    /// The order of the item in relation to other items in the organization.
    pub sort_order: Option<f64>,
    /// The order of the item in relation to other items in the organization, when ordered by priority.
    pub priority_sort_order: Option<f64>,
    /// The time at which the issue was moved into started state.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was moved into completed state.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue entered triage.
    pub started_triage_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue left triage.
    pub triaged_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was moved into canceled state.
    pub canceled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was automatically closed by the auto pruning process.
    pub auto_closed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was automatically archived by the auto pruning process.
    pub auto_archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date at which the issue is due.
    pub due_date: Option<chrono::NaiveDate>,
    /// The time at which the issue's SLA began.
    pub sla_started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA will enter medium risk state.
    pub sla_medium_risk_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA will enter high risk state.
    pub sla_high_risk_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue's SLA will breach.
    pub sla_breaches_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of SLA set on the issue. Calendar days or business days.
    pub sla_type: Option<String>,
    /// The time at which the issue was added to a project.
    pub added_to_project_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was added to a cycle.
    pub added_to_cycle_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the issue was added to a team.
    pub added_to_team_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A flag that indicates whether the issue is in the trash bin.
    pub trashed: Option<bool>,
    /// The time until an issue will be snoozed in Triage view.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` The time at which the most recent suggestions for this issue were generated.
    pub suggestions_generated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` The activity summary information for this issue.
    pub activity_summary: Option<serde_json::Value>,
    /// `Internal` AI-generated activity summary for this issue.
    pub summary: Option<Box<Summary>>,
    /// Id of the labels associated with this issue.
    pub label_ids: Option<Vec<String>>,
    /// The team that the issue is associated with.
    pub team: Option<Box<Team>>,
    /// The cycle that the issue is associated with.
    pub cycle: Option<Box<Cycle>>,
    /// The project that the issue is associated with.
    pub project: Option<Box<Project>>,
    /// The projectMilestone that the issue is associated with.
    pub project_milestone: Option<Box<ProjectMilestone>>,
    /// The last template that was applied to this issue.
    pub last_applied_template: Option<Box<Template>>,
    /// The recurring issue template that created this issue.
    pub recurring_issue_template: Option<Box<Template>>,
    /// Previous identifiers of the issue if it has been moved between teams.
    pub previous_identifiers: Option<Vec<String>>,
    /// The user who created the issue.
    pub creator: Option<Box<User>>,
    /// The external user who created the issue.
    pub external_user_creator: Option<Box<ExternalUser>>,
    /// The user to whom the issue is assigned to.
    pub assignee: Option<Box<User>>,
    /// The agent user that is delegated to work on this issue.
    pub delegate: Option<Box<User>>,
    /// The user who snoozed the issue.
    pub snoozed_by: Option<Box<User>>,
    /// The workflow state that the issue is associated with.
    pub state: Option<Box<WorkflowState>>,
    /// The order of the item in the sub-issue list. Only set if the issue has a parent.
    pub sub_issue_sort_order: Option<f64>,
    /// Emoji reaction summary, grouped by emoji type.
    pub reaction_data: Option<serde_json::Value>,
    /// Label for the priority.
    pub priority_label: Option<String>,
    /// The comment that this issue was created from.
    pub source_comment: Option<Box<Comment>>,
    /// Integration type that created this issue, if applicable.
    pub integration_source_type: Option<IntegrationService>,
    /// Documents associated with the issue.
    pub documents: Option<Box<DocumentConnection>>,
    /// The bot that created the issue, if applicable.
    pub bot_actor: Option<Box<ActorBot>>,
    /// The users favorite associated with this issue.
    pub favorite: Option<Box<Favorite>>,
    /// Issue's human readable identifier (e.g. ENG-123).
    pub identifier: Option<String>,
    /// Issue URL.
    pub url: Option<String>,
    /// Suggested branch name for the issue.
    pub branch_name: Option<String>,
    /// Shared access metadata for this issue.
    pub shared_access: Option<Box<IssueSharedAccess>>,
    /// Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
    pub customer_ticket_count: Option<i64>,
    /// Users who are subscribed to the issue.
    pub subscribers: Option<Box<UserConnection>>,
    /// The parent of the issue.
    pub parent: Option<Box<Issue>>,
    /// Children of the issue.
    pub children: Option<Box<IssueConnection>>,
    /// Comments associated with the issue.
    pub comments: Option<Box<CommentConnection>>,
    /// History entries associated with the issue.
    pub history: Option<Box<IssueHistoryConnection>>,
    /// Labels associated with this issue.
    pub labels: Option<Box<IssueLabelConnection>>,
    /// Relations associated with this issue.
    pub relations: Option<Box<IssueRelationConnection>>,
    /// Inverse relations associated with this issue.
    pub inverse_relations: Option<Box<IssueRelationConnection>>,
    /// Attachments associated with the issue.
    pub attachments: Option<Box<AttachmentConnection>>,
    /// Attachments previously associated with the issue before being moved to another issue.
    pub former_attachments: Option<Box<AttachmentConnection>>,
    /// The issue's description in markdown format.
    pub description: Option<String>,
    /// `Internal` The issue's description content as YJS state.
    pub description_state: Option<String>,
    /// `ALPHA` The document content representing this issue description.
    pub document_content: Option<Box<DocumentContent>>,
    /// Reactions associated with the issue.
    pub reactions: Option<Box<Vec<Reaction>>>,
    /// Customer needs associated with the issue.
    pub needs: Option<Box<CustomerNeedConnection>>,
    /// Customer needs previously associated with the issue before being moved to another issue.
    pub former_needs: Option<Box<CustomerNeedConnection>>,
    /// The external services the issue is synced with.
    pub synced_with: Option<Box<Vec<ExternalEntityInfo>>>,
    /// `Internal` Product Intelligence suggestions for the issue.
    pub suggestions: Option<Box<IssueSuggestionConnection>>,
    /// `Internal` Incoming product intelligence relation suggestions for the issue.
    pub incoming_suggestions: Option<Box<IssueSuggestionConnection>>,
    /// The internal user who requested creation of the Asks issue on behalf of the creator.
    pub asks_requester: Option<Box<User>>,
    /// The external user who requested creation of the Asks issue on behalf of the creator.
    pub asks_external_user_requester: Option<Box<ExternalUser>>,
    /// The issue's workflow states over time.
    pub state_history: Option<Box<IssueStateSpanConnection>>,
    /// Metadata related to search result.
    pub metadata: Option<serde_json::Value>,
}
impl GraphQLFields for IssueSearchResult {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt number title priority estimate boardOrder sortOrder prioritySortOrder startedAt completedAt startedTriageAt triagedAt canceledAt autoClosedAt autoArchivedAt dueDate slaStartedAt slaMediumRiskAt slaHighRiskAt slaBreachesAt slaType addedToProjectAt addedToCycleAt addedToTeamAt trashed snoozedUntilAt suggestionsGeneratedAt activitySummary labelIds previousIdentifiers subIssueSortOrder reactionData priorityLabel integrationSourceType identifier url branchName customerTicketCount description metadata"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSearchResultEdge {
    pub node: Option<Box<IssueSearchResult>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueSearchResultEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSharedAccess {
    /// Whether this issue has been shared with users outside the team.
    pub is_shared: Option<bool>,
    /// Whether the viewer can access this issue only through issue sharing.
    pub viewer_has_only_shared_access: Option<bool>,
    /// The number of users this issue is shared with.
    pub shared_with_count: Option<i64>,
    /// Users this issue is shared with.
    pub shared_with_users: Option<Box<Vec<User>>>,
}
impl GraphQLFields for IssueSharedAccess {
    type FullType = Self;
    fn selection() -> String {
        "isShared viewerHasOnlySharedAccess sharedWithCount".into()
    }
}
/// A continuous period of time during which an issue remained in a specific workflow state.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueStateSpan {
    /// The unique identifier of the state span.
    pub id: Option<String>,
    /// The workflow state identifier for this span.
    pub state_id: Option<String>,
    /// The timestamp when the issue entered this state.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The timestamp when the issue left this state. Null if the issue is currently in this state.
    pub ended_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The workflow state for this span.
    pub state: Option<Box<WorkflowState>>,
}
impl GraphQLFields for IssueStateSpan {
    type FullType = Self;
    fn selection() -> String {
        "id stateId startedAt endedAt".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueStateSpanConnection {
    pub edges: Option<Box<Vec<IssueStateSpanEdge>>>,
    pub nodes: Option<Box<Vec<IssueStateSpan>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueStateSpanConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueStateSpanEdge {
    pub node: Option<Box<IssueStateSpan>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueStateSpanEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSuggestion {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    pub issue: Option<Box<Issue>>,
    pub issue_id: Option<String>,
    pub r#type: Option<IssueSuggestionType>,
    pub state: Option<IssueSuggestionState>,
    pub state_changed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub dismissal_reason: Option<String>,
    pub metadata: Option<Box<IssueSuggestionMetadata>>,
    pub suggested_issue: Option<Box<Issue>>,
    pub suggested_issue_id: Option<String>,
    pub suggested_team: Option<Box<Team>>,
    pub suggested_project: Option<Box<Project>>,
    pub suggested_user: Option<Box<User>>,
    pub suggested_user_id: Option<String>,
    pub suggested_label: Option<Box<IssueLabel>>,
    pub suggested_label_id: Option<String>,
    /// The reasons for the suggestion.
    pub reasons: Option<Vec<String>>,
    /// Whether the suggestion should be visible.
    pub is_visible: Option<bool>,
}
impl GraphQLFields for IssueSuggestion {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt issueId type state stateChangedAt dismissalReason suggestedIssueId suggestedUserId suggestedLabelId reasons isVisible"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSuggestionConnection {
    pub edges: Option<Box<Vec<IssueSuggestionEdge>>>,
    pub nodes: Option<Box<Vec<IssueSuggestion>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueSuggestionConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSuggestionEdge {
    pub node: Option<Box<IssueSuggestion>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueSuggestionEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueSuggestionMetadata {
    pub score: Option<f64>,
    pub classification: Option<String>,
    pub reasons: Option<Vec<String>>,
    pub eval_log_id: Option<String>,
    pub rank: Option<f64>,
    pub variant: Option<String>,
    pub applied_automation_rule_id: Option<String>,
}
impl GraphQLFields for IssueSuggestionMetadata {
    type FullType = Self;
    fn selection() -> String {
        "score classification reasons evalLogId rank variant appliedAutomationRuleId".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueTitleSuggestionFromCustomerRequestPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The suggested issue title.
    pub title: Option<String>,
    /// `Internal` The log id of the ai response.
    pub log_id: Option<String>,
}
impl GraphQLFields for IssueTitleSuggestionFromCustomerRequestPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId title logId".into()
    }
}
/// `Internal` Join table between issues and releases.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueToRelease {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The issue associated with the release.
    pub issue: Option<Box<Issue>>,
    /// The release associated with the issue.
    pub release: Option<Box<Release>>,
    /// The pull request that linked this issue to the release.
    pub pull_request: Option<Box<PullRequest>>,
}
impl GraphQLFields for IssueToRelease {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueToReleaseConnection {
    pub edges: Option<Box<Vec<IssueToReleaseEdge>>>,
    pub nodes: Option<Box<Vec<IssueToRelease>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for IssueToReleaseConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueToReleaseEdge {
    pub node: Option<Box<IssueToRelease>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for IssueToReleaseEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// `ALPHA` The result of an issueToRelease mutation.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct IssueToReleasePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The issueToRelease that was created or updated.
    pub issue_to_release: Option<Box<IssueToRelease>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for IssueToReleasePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A label notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct LabelNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The label subscribed to.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for LabelNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct LogoutResponse {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for LogoutResponse {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for NotificationArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationBatchActionPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for NotificationBatchActionPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A user's notification category preferences.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationCategoryPreferences {
    /// The preferences for notifications about assignments.
    pub assignments: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about status changes.
    pub status_changes: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about comments and replies.
    pub comments_and_replies: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about mentions.
    pub mentions: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about reactions.
    pub reactions: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about subscriptions.
    pub subscriptions: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about document changes.
    pub document_changes: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about posts and updates.
    pub posts_and_updates: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about reminders.
    pub reminders: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about reviews.
    pub reviews: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for notifications about apps and integrations.
    pub apps_and_integrations: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for system notifications.
    pub system: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for triage notifications.
    pub triage: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for customer notifications.
    pub customers: Option<Box<NotificationChannelPreferences>>,
    /// The preferences for feed summary notifications.
    pub feed: Option<Box<NotificationChannelPreferences>>,
}
impl GraphQLFields for NotificationCategoryPreferences {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// A user's notification channel preferences, indicating if a channel is enabled or not
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationChannelPreferences {
    /// Whether notifications are currently enabled for mobile.
    pub mobile: Option<bool>,
    /// Whether notifications are currently enabled for desktop.
    pub desktop: Option<bool>,
    /// Whether notifications are currently enabled for email.
    pub email: Option<bool>,
    /// Whether notifications are currently enabled for Slack.
    pub slack: Option<bool>,
}
impl GraphQLFields for NotificationChannelPreferences {
    type FullType = Self;
    fn selection() -> String {
        "mobile desktop email slack".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationConnection {
    pub edges: Option<Box<Vec<NotificationEdge>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for NotificationConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// A user's notification delivery preferences.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationDeliveryPreferences {
    /// The delivery preferences for the mobile channel.
    pub mobile: Option<Box<NotificationDeliveryPreferencesChannel>>,
}
impl GraphQLFields for NotificationDeliveryPreferences {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// A user's notification delivery preferences.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationDeliveryPreferencesChannel {
    /// `DEPRECATED` Whether notifications are enabled for this channel. Use notificationChannelPreferences instead.
    pub notifications_disabled: Option<bool>,
    /// The schedule for notifications on this channel.
    pub schedule: Option<Box<NotificationDeliveryPreferencesSchedule>>,
}
impl GraphQLFields for NotificationDeliveryPreferencesChannel {
    type FullType = Self;
    fn selection() -> String {
        "notificationsDisabled".into()
    }
}
/// A user's notification delivery schedule for a particular day.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationDeliveryPreferencesDay {
    /// The time notifications start.
    pub start: Option<String>,
    /// The time notifications end.
    pub end: Option<String>,
}
impl GraphQLFields for NotificationDeliveryPreferencesDay {
    type FullType = Self;
    fn selection() -> String {
        "start end".into()
    }
}
/// A user's notification delivery schedule for a particular day.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationDeliveryPreferencesSchedule {
    /// Whether the schedule is disabled.
    pub disabled: Option<bool>,
    /// Delivery preferences for Sunday.
    pub sunday: Option<Box<NotificationDeliveryPreferencesDay>>,
    /// Delivery preferences for Monday.
    pub monday: Option<Box<NotificationDeliveryPreferencesDay>>,
    /// Delivery preferences for Tuesday.
    pub tuesday: Option<Box<NotificationDeliveryPreferencesDay>>,
    /// Delivery preferences for Wednesday.
    pub wednesday: Option<Box<NotificationDeliveryPreferencesDay>>,
    /// Delivery preferences for Thursday.
    pub thursday: Option<Box<NotificationDeliveryPreferencesDay>>,
    /// Delivery preferences for Friday.
    pub friday: Option<Box<NotificationDeliveryPreferencesDay>>,
    /// Delivery preferences for Saturday.
    pub saturday: Option<Box<NotificationDeliveryPreferencesDay>>,
}
impl GraphQLFields for NotificationDeliveryPreferencesSchedule {
    type FullType = Self;
    fn selection() -> String {
        "disabled".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationEdge {
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for NotificationEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for NotificationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationSubscriptionConnection {
    pub edges: Option<Box<Vec<NotificationSubscriptionEdge>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for NotificationSubscriptionConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationSubscriptionEdge {
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for NotificationSubscriptionEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct NotificationSubscriptionPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for NotificationSubscriptionPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Request to install OAuth clients on organizations and the response to the request.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OauthClientApproval {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The uuid of the OAuth client being requested for installation.
    pub oauth_client_id: Option<String>,
    /// The person who requested installing the OAuth client.
    pub requester_id: Option<String>,
    /// The person who responded to the request to install the OAuth client.
    pub responder_id: Option<String>,
    /// The status for the OAuth client approval request.
    pub status: Option<OAuthClientApprovalStatus>,
    /// The scopes the app has been approved for.
    pub scopes: Option<Vec<String>>,
    /// The reason the person wants to install this OAuth client.
    pub request_reason: Option<String>,
    /// The reason the request for the OAuth client approval was denied.
    pub deny_reason: Option<String>,
    /// New scopes that were requested for approval after the initial request.
    pub newly_requested_scopes: Option<Vec<String>>,
}
impl GraphQLFields for OauthClientApproval {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt oauthClientId requesterId responderId status scopes requestReason denyReason newlyRequestedScopes"
            .into()
    }
}
/// An oauth client approval related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OauthClientApprovalNotification {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related OAuth client approval request ID.
    pub oauth_client_approval_id: Option<String>,
    /// The OAuth client approval request related to the notification.
    pub oauth_client_approval: Option<Box<OauthClientApproval>>,
}
impl GraphQLFields for OauthClientApprovalNotification {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority oauthClientApprovalId"
            .into()
    }
}
/// An organization. Organizations are root-level objects that contain user accounts and teams.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Organization {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The organization's name.
    pub name: Option<String>,
    /// The organization's unique URL key.
    pub url_key: Option<String>,
    /// The organization's logo URL.
    pub logo_url: Option<String>,
    /// Rolling 30-day total upload volume for the organization, in megabytes.
    pub period_upload_volume: Option<f64>,
    /// `Internal` Facets associated with the organization.
    pub facets: Option<Box<Vec<Facet>>>,
    /// How git branches are formatted. If null, default formatting will be used.
    pub git_branch_format: Option<String>,
    /// Whether the Git integration linkback messages should be sent to private repositories.
    pub git_linkback_messages_enabled: Option<bool>,
    /// Whether the Git integration linkback messages should be sent to public repositories.
    pub git_public_linkback_messages_enabled: Option<bool>,
    /// Whether issue descriptions should be included in Git integration linkback messages.
    pub git_linkback_descriptions_enabled: Option<bool>,
    /// Whether the organization is using a roadmap.
    pub roadmap_enabled: Option<bool>,
    /// The n-weekly frequency at which to prompt for project updates. When not set, reminders are off.
    pub project_update_reminder_frequency_in_weeks: Option<f64>,
    /// The day at which to prompt for project updates.
    pub project_update_reminders_day: Option<Day>,
    /// The hour at which to prompt for project updates.
    pub project_update_reminders_hour: Option<f64>,
    /// The n-weekly frequency at which to prompt for initiative updates. When not set, reminders are off.
    pub initiative_update_reminder_frequency_in_weeks: Option<f64>,
    /// The day at which to prompt for initiative updates.
    pub initiative_update_reminders_day: Option<Day>,
    /// The hour at which to prompt for initiative updates.
    pub initiative_update_reminders_hour: Option<f64>,
    /// The month at which the fiscal year starts. Defaults to January (0).
    pub fiscal_year_start_month: Option<f64>,
    /// `Internal` The list of working days. Sunday is 0, Monday is 1, etc.
    pub working_days: Option<Vec<f64>>,
    /// Whether SAML authentication is enabled for organization.
    pub saml_enabled: Option<bool>,
    /// `INTERNAL` SAML settings.
    pub saml_settings: Option<serde_json::Value>,
    /// Whether SCIM provisioning is enabled for organization.
    pub scim_enabled: Option<bool>,
    /// `INTERNAL` SCIM settings.
    pub scim_settings: Option<serde_json::Value>,
    /// Security settings for the organization.
    pub security_settings: Option<serde_json::Value>,
    /// Allowed authentication providers, empty array means all are allowed.
    pub allowed_auth_services: Option<Vec<String>>,
    /// Allowed file upload content types
    pub allowed_file_upload_content_types: Option<Vec<String>>,
    /// IP restriction configurations.
    pub ip_restrictions: Option<Box<Vec<OrganizationIpRestriction>>>,
    /// The time at which deletion of the organization was requested.
    pub deletion_requested_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the trial will end.
    pub trial_ends_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the trial started.
    pub trial_starts_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Previously used URL keys for the organization (last 3 are kept and redirected).
    pub previous_url_keys: Option<Vec<String>>,
    /// Whether HIPAA compliance is enabled for organization.
    pub hipaa_compliance_enabled: Option<bool>,
    /// `ALPHA` Theme settings for the organization.
    pub theme_settings: Option<serde_json::Value>,
    /// The feature release channel the organization belongs to.
    pub release_channel: Option<ReleaseChannel>,
    /// Configuration settings for the Customers feature.
    pub customers_configuration: Option<serde_json::Value>,
    /// `INTERNAL` Whether code intelligence is enabled for the organization.
    pub code_intelligence_enabled: Option<bool>,
    /// `INTERNAL` GitHub repository in owner/repo format for code intelligence.
    pub code_intelligence_repository: Option<String>,
    /// Default schedule for how often feed summaries are generated.
    pub default_feed_summary_schedule: Option<FeedSummarySchedule>,
    /// Whether the organization has enabled the feed feature.
    pub feed_enabled: Option<bool>,
    /// Whether to hide other organizations for new users signing up with email domains claimed by this organization.
    pub hide_non_primary_organizations: Option<bool>,
    /// `INTERNAL` Whether the organization has enabled the AI add-on (which at this point only includes triage suggestions).
    pub ai_addon_enabled: Option<bool>,
    /// `INTERNAL` Whether the organization has enabled generated updates.
    pub generated_updates_enabled: Option<bool>,
    /// Whether the organization has enabled resolved thread AI summaries.
    pub ai_thread_summaries_enabled: Option<bool>,
    /// Whether the organization has enabled AI discussion summaries for issues.
    pub ai_discussion_summaries_enabled: Option<bool>,
    /// `INTERNAL` Configure per-modality AI host providers and model families.
    pub ai_provider_configuration: Option<serde_json::Value>,
    /// `Internal` Whether the organization has enabled Linear Agent.
    pub linear_agent_enabled: Option<bool>,
    /// `DEPRECATED` Which day count to use for SLA calculations.
    pub sla_day_count: Option<SLADayCountType>,
    /// `DEPRECATED` The frequency at which to prompt for project updates.
    pub project_updates_reminder_frequency: Option<ProjectUpdateReminderFrequency>,
    /// `INTERNAL` Permitted AI providers.
    pub allowed_ai_providers: Option<Vec<String>>,
    /// Users associated with the organization.
    pub users: Option<Box<UserConnection>>,
    /// Teams associated with the organization.
    pub teams: Option<Box<TeamConnection>>,
    /// The organization's project statuses.
    pub project_statuses: Option<Box<Vec<ProjectStatus>>>,
    /// Integrations associated with the organization.
    pub integrations: Option<Box<IntegrationConnection>>,
    /// The Slack integration used for auto-creating project channels.
    pub slack_project_channel_integration: Option<Box<Integration>>,
    /// The prefix used for auto-created Slack project channels.
    pub slack_project_channel_prefix: Option<String>,
    /// The organization's subscription to a paid plan.
    pub subscription: Option<Box<PaidSubscription>>,
    /// Number of active users in the organization.
    pub user_count: Option<i64>,
    /// Aproximate number of issues in the organization, including archived ones.
    pub created_issue_count: Option<i64>,
    /// Templates associated with the organization.
    pub templates: Option<Box<TemplateConnection>>,
    /// Labels associated with the organization.
    pub labels: Option<Box<IssueLabelConnection>>,
    /// Project labels associated with the organization.
    pub project_labels: Option<Box<ProjectLabelConnection>>,
    /// Number of customers in the organization.
    pub customer_count: Option<i64>,
    /// Whether the organization is using Customers.
    pub customers_enabled: Option<bool>,
    /// `DEPRECATED` Whether member users are allowed to send invites.
    pub allow_members_to_invite: Option<bool>,
    /// `DEPRECATED` Whether team creation is restricted to admins.
    pub restrict_team_creation_to_admins: Option<bool>,
    /// `DEPRECATED` Whether workspace label creation, update, and deletion is restricted to admins.
    pub restrict_label_management_to_admins: Option<bool>,
}
impl GraphQLFields for Organization {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name urlKey logoUrl periodUploadVolume gitBranchFormat gitLinkbackMessagesEnabled gitPublicLinkbackMessagesEnabled gitLinkbackDescriptionsEnabled roadmapEnabled projectUpdateReminderFrequencyInWeeks projectUpdateRemindersDay projectUpdateRemindersHour initiativeUpdateReminderFrequencyInWeeks initiativeUpdateRemindersDay initiativeUpdateRemindersHour fiscalYearStartMonth workingDays samlEnabled samlSettings scimEnabled scimSettings securitySettings allowedAuthServices allowedFileUploadContentTypes deletionRequestedAt trialEndsAt trialStartsAt previousUrlKeys hipaaComplianceEnabled themeSettings releaseChannel customersConfiguration codeIntelligenceEnabled codeIntelligenceRepository defaultFeedSummarySchedule feedEnabled hideNonPrimaryOrganizations aiAddonEnabled generatedUpdatesEnabled aiThreadSummariesEnabled aiDiscussionSummariesEnabled aiProviderConfiguration linearAgentEnabled slaDayCount projectUpdatesReminderFrequency allowedAiProviders slackProjectChannelPrefix userCount createdIssueCount customerCount customersEnabled allowMembersToInvite restrictTeamCreationToAdmins restrictLabelManagementToAdmins"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationAcceptedOrExpiredInviteDetailsPayload {
    /// The status of the invite.
    pub status: Option<OrganizationInviteStatus>,
}
impl GraphQLFields for OrganizationAcceptedOrExpiredInviteDetailsPayload {
    type FullType = Self;
    fn selection() -> String {
        "status".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationCancelDeletePayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationCancelDeletePayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationDeletePayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationDeletePayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
/// Defines the use of a domain by an organization.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationDomain {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The identity provider the domain belongs to.
    pub identity_provider: Option<Box<IdentityProvider>>,
    /// Domain name.
    pub name: Option<String>,
    /// Is this domain verified.
    pub verified: Option<bool>,
    /// E-mail used to verify this domain.
    pub verification_email: Option<String>,
    /// The user who added the domain.
    pub creator: Option<Box<User>>,
    /// What type of auth is the domain used for.
    pub auth_type: Option<OrganizationDomainAuthType>,
    /// Whether the domains was claimed by the organization through DNS verification.
    pub claimed: Option<bool>,
    /// Prevent users with this domain to create new workspaces.
    pub disable_organization_creation: Option<bool>,
}
impl GraphQLFields for OrganizationDomain {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name verified verificationEmail authType claimed disableOrganizationCreation"
            .into()
    }
}
/// `INTERNAL` Domain claim request response.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationDomainClaimPayload {
    /// String to put into DNS for verification.
    pub verification_string: Option<String>,
}
impl GraphQLFields for OrganizationDomainClaimPayload {
    type FullType = Self;
    fn selection() -> String {
        "verificationString".into()
    }
}
/// `INTERNAL` Organization domain operation response.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationDomainPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The organization domain that was created or updated.
    pub organization_domain: Option<Box<OrganizationDomain>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationDomainPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `INTERNAL` Organization domain operation response.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationDomainSimplePayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationDomainSimplePayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationExistsPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// Whether the organization exists.
    pub exists: Option<bool>,
}
impl GraphQLFields for OrganizationExistsPayload {
    type FullType = Self;
    fn selection() -> String {
        "success exists".into()
    }
}
/// An invitation to the organization that has been sent via email.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationInvite {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The invitees email address.
    pub email: Option<String>,
    /// The user role that the invitee will receive upon accepting the invite.
    pub role: Option<UserRoleType>,
    /// The invite was sent to external address.
    pub external: Option<bool>,
    /// The time at which the invite was accepted. Null, if the invite hasn't been accepted.
    pub accepted_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the invite will be expiring. Null, if the invite shouldn't expire.
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Extra metadata associated with the organization invite.
    pub metadata: Option<serde_json::Value>,
    /// The user who created the invitation.
    pub inviter: Option<Box<User>>,
    /// The user who has accepted the invite. Null, if the invite hasn't been accepted.
    pub invitee: Option<Box<User>>,
    /// The organization that the invite is associated with.
    pub organization: Option<Box<Organization>>,
}
impl GraphQLFields for OrganizationInvite {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt email role external acceptedAt expiresAt metadata".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationInviteConnection {
    pub edges: Option<Box<Vec<OrganizationInviteEdge>>>,
    pub nodes: Option<Box<Vec<OrganizationInvite>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for OrganizationInviteConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationInviteEdge {
    pub node: Option<Box<OrganizationInvite>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for OrganizationInviteEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationInviteFullDetailsPayload {
    /// The status of the invite.
    pub status: Option<OrganizationInviteStatus>,
    /// The name of the inviter.
    pub inviter: Option<String>,
    /// The email of the invitee.
    pub email: Option<String>,
    /// What user role the invite should grant.
    pub role: Option<UserRoleType>,
    /// When the invite was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Name of the workspace the invite is for.
    pub organization_name: Option<String>,
    /// ID of the workspace the invite is for.
    pub organization_id: Option<String>,
    /// URL of the workspace logo the invite is for.
    pub organization_logo_url: Option<String>,
    /// Whether the invite has already been accepted.
    pub accepted: Option<bool>,
    /// Whether the invite has expired.
    pub expired: Option<bool>,
    /// Allowed authentication providers, empty array means all are allowed.
    pub allowed_auth_services: Option<Vec<String>>,
}
impl GraphQLFields for OrganizationInviteFullDetailsPayload {
    type FullType = Self;
    fn selection() -> String {
        "status inviter email role createdAt organizationName organizationId organizationLogoUrl accepted expired allowedAuthServices"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationInvitePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The organization invite that was created or updated.
    pub organization_invite: Option<Box<OrganizationInvite>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationInvitePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationIpRestriction {
    /// IP range in CIDR format.
    pub range: Option<String>,
    /// Restriction type.
    pub r#type: Option<String>,
    /// Optional restriction description.
    pub description: Option<String>,
    /// Whether the restriction is enabled.
    pub enabled: Option<bool>,
}
impl GraphQLFields for OrganizationIpRestriction {
    type FullType = Self;
    fn selection() -> String {
        "range type description enabled".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationMeta {
    /// The region the organization is hosted in.
    pub region: Option<String>,
    /// Allowed authentication providers, empty array means all are allowed.
    pub allowed_auth_services: Option<Vec<String>>,
}
impl GraphQLFields for OrganizationMeta {
    type FullType = Self;
    fn selection() -> String {
        "region allowedAuthServices".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The organization that was created or updated.
    pub organization: Option<Box<Organization>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct OrganizationStartTrialPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for OrganizationStartTrialPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PageInfo {
    /// Indicates if there are more results when paginating backward.
    pub has_previous_page: Option<bool>,
    /// Indicates if there are more results when paginating forward.
    pub has_next_page: Option<bool>,
    /// Cursor representing the first result in the paginated results.
    pub start_cursor: Option<String>,
    /// Cursor representing the last result in the paginated results.
    pub end_cursor: Option<String>,
}
impl GraphQLFields for PageInfo {
    type FullType = Self;
    fn selection() -> String {
        "hasPreviousPage hasNextPage startCursor endCursor".into()
    }
}
/// The paid subscription of an organization.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PaidSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The subscription type.
    pub r#type: Option<String>,
    /// The number of seats in the subscription.
    pub seats: Option<f64>,
    /// The minimum number of seats that will be billed in the subscription.
    pub seats_minimum: Option<f64>,
    /// The maximum number of seats that will be billed in the subscription.
    pub seats_maximum: Option<f64>,
    /// The creator of the subscription.
    pub creator: Option<Box<User>>,
    /// The organization that the subscription is associated with.
    pub organization: Option<Box<Organization>>,
    /// The collection method for this subscription, either automatically charged or invoiced.
    pub collection_method: Option<String>,
    /// The date the subscription was canceled, if any.
    pub canceled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date the subscription is scheduled to be canceled, if any.
    pub cancel_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The subscription type of a pending change. Null if no change pending.
    pub pending_change_type: Option<String>,
    /// The date the subscription will be billed next.
    pub next_billing_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for PaidSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type seats seatsMinimum seatsMaximum collectionMethod canceledAt cancelAt pendingChangeType nextBillingAt"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PasskeyLoginStartResponse {
    pub success: Option<bool>,
    pub options: Option<serde_json::Value>,
}
impl GraphQLFields for PasskeyLoginStartResponse {
    type FullType = Self;
    fn selection() -> String {
        "success options".into()
    }
}
/// `Internal` A generic post.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Post {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The update content in markdown format.
    pub body: Option<String>,
    /// `Internal` The content of the post as a Prosemirror document.
    pub body_data: Option<String>,
    /// `Internal` The written update data used to compose the written post.
    pub written_summary_data: Option<serde_json::Value>,
    /// The update content summarized for audio consumption.
    pub audio_summary: Option<String>,
    /// The post's title.
    pub title: Option<String>,
    /// The post's unique URL slug.
    pub slug_id: Option<String>,
    /// The user who wrote the post.
    pub creator: Option<Box<User>>,
    /// The time the post was edited.
    pub edited_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Emoji reaction summary, grouped by emoji type.
    pub reaction_data: Option<serde_json::Value>,
    /// A URL of the TTL (text-to-language) for the body.
    pub ttl_url: Option<String>,
    /// The user that the post is associated with.
    pub user: Option<Box<User>>,
    /// The team that the post is associated with.
    pub team: Option<Box<Team>>,
    /// The type of the post.
    pub r#type: Option<PostType>,
    /// The log id of the ai response.
    pub eval_log_id: Option<String>,
    /// Schedule used to create a post summary.
    pub feed_summary_schedule_at_create: Option<FeedSummarySchedule>,
    /// Reactions associated with the post.
    pub reactions: Option<Box<Vec<Reaction>>>,
    /// Comments associated with the post.
    pub comments: Option<Box<CommentConnection>>,
    /// A URL to the generated audio for the Post.
    pub audio_summary_url: Option<String>,
    /// Number of comments associated with the post.
    pub comment_count: Option<i64>,
}
impl GraphQLFields for Post {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt body bodyData writtenSummaryData audioSummary title slugId editedAt reactionData ttlUrl type evalLogId feedSummaryScheduleAtCreate audioSummaryUrl commentCount"
            .into()
    }
}
/// A post related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PostNotification {
    /// Related comment ID. Null if the notification is not related to a comment.
    pub comment_id: Option<String>,
    /// Related parent comment ID. Null if the notification is not related to a comment.
    pub parent_comment_id: Option<String>,
    /// Name of the reaction emoji related to the notification.
    pub reaction_emoji: Option<String>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related post ID.
    pub post_id: Option<String>,
}
impl GraphQLFields for PostNotification {
    type FullType = Self;
    fn selection() -> String {
        "commentId parentCommentId reactionEmoji id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority postId"
            .into()
    }
}
/// A project.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Project {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
    pub update_reminder_frequency_in_weeks: Option<f64>,
    /// The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
    pub update_reminder_frequency: Option<f64>,
    /// The resolution of the reminder frequency.
    pub frequency_resolution: Option<FrequencyResolutionType>,
    /// The day at which to prompt for updates.
    pub update_reminders_day: Option<Day>,
    /// The hour at which to prompt for updates.
    pub update_reminders_hour: Option<f64>,
    /// The project's name.
    pub name: Option<String>,
    /// The project's description.
    pub description: Option<String>,
    /// The project's unique URL slug.
    pub slug_id: Option<String>,
    /// The icon of the project.
    pub icon: Option<String>,
    /// The project's color.
    pub color: Option<String>,
    /// The status that the project is associated with.
    pub status: Option<Box<ProjectStatus>>,
    /// The user who created the project.
    pub creator: Option<Box<User>>,
    /// The project lead.
    pub lead: Option<Box<User>>,
    /// `Internal` Facets associated with the project.
    pub facets: Option<Box<Vec<Facet>>>,
    /// The time until which project update reminders are paused.
    pub project_update_reminders_paused_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The estimated start date of the project.
    pub start_date: Option<chrono::NaiveDate>,
    /// The resolution of the project's start date.
    pub start_date_resolution: Option<DateResolutionType>,
    /// The estimated completion date of the project.
    pub target_date: Option<chrono::NaiveDate>,
    /// The resolution of the project's estimated completion date.
    pub target_date_resolution: Option<DateResolutionType>,
    /// The time at which the project was moved into started state.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the project was moved into completed state.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the project was moved into canceled state.
    pub canceled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the project was automatically archived by the auto pruning process.
    pub auto_archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A flag that indicates whether the project is in the trash bin.
    pub trashed: Option<bool>,
    /// The sort order for the project within the organization.
    pub sort_order: Option<f64>,
    /// The sort order for the project within the organization, when ordered by priority.
    pub priority_sort_order: Option<f64>,
    /// The project was created based on this issue.
    pub converted_from_issue: Option<Box<Issue>>,
    /// The last template that was applied to this project.
    pub last_applied_template: Option<Box<Template>>,
    /// The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
    pub priority: Option<i64>,
    /// The last project update posted for this project.
    pub last_update: Option<Box<ProjectUpdate>>,
    /// The health of the project.
    pub health: Option<ProjectUpdateHealthType>,
    /// The time at which the project health was updated.
    pub health_updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The total number of issues in the project after each week.
    pub issue_count_history: Option<Vec<f64>>,
    /// The number of completed issues in the project after each week.
    pub completed_issue_count_history: Option<Vec<f64>>,
    /// The total number of estimation points after each week.
    pub scope_history: Option<Vec<f64>>,
    /// The number of completed estimation points after each week.
    pub completed_scope_history: Option<Vec<f64>>,
    /// The number of in progress estimation points after each week.
    pub in_progress_scope_history: Option<Vec<f64>>,
    /// `INTERNAL` The progress history of the project.
    pub progress_history: Option<serde_json::Value>,
    /// `INTERNAL` The current progress of the project.
    pub current_progress: Option<serde_json::Value>,
    /// Whether to send new issue notifications to Slack.
    pub slack_new_issue: Option<bool>,
    /// Whether to send new issue comment notifications to Slack.
    pub slack_issue_comments: Option<bool>,
    /// Whether to send new issue status updates to Slack.
    pub slack_issue_statuses: Option<bool>,
    /// Id of the labels associated with this project.
    pub label_ids: Option<Vec<String>>,
    /// The user's favorite associated with this project.
    pub favorite: Option<Box<Favorite>>,
    /// Project URL.
    pub url: Option<String>,
    /// Initiatives that this project belongs to.
    pub initiatives: Option<Box<InitiativeConnection>>,
    /// Associations of this project to parent initiatives.
    pub initiative_to_projects: Option<Box<InitiativeToProjectConnection>>,
    /// Teams associated with this project.
    pub teams: Option<Box<TeamConnection>>,
    /// Users that are members of the project.
    pub members: Option<Box<UserConnection>>,
    /// Project updates associated with the project.
    pub project_updates: Option<Box<ProjectUpdateConnection>>,
    /// Documents associated with the project.
    pub documents: Option<Box<DocumentConnection>>,
    /// Milestones associated with the project.
    pub project_milestones: Option<Box<ProjectMilestoneConnection>>,
    /// Issues associated with the project.
    pub issues: Option<Box<IssueConnection>>,
    /// External links associated with the project.
    pub external_links: Option<Box<EntityExternalLinkConnection>>,
    /// Attachments associated with the project.
    pub attachments: Option<Box<ProjectAttachmentConnection>>,
    /// History entries associated with the project.
    pub history: Option<Box<ProjectHistoryConnection>>,
    /// Labels associated with this project.
    pub labels: Option<Box<ProjectLabelConnection>>,
    /// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
    pub progress: Option<f64>,
    /// The overall scope (total estimate points) of the project.
    pub scope: Option<f64>,
    /// Settings for all integrations associated with that project.
    pub integrations_settings: Option<Box<IntegrationsSettings>>,
    /// The project's content in markdown format.
    pub content: Option<String>,
    /// `Internal` The project's content as YJS state.
    pub content_state: Option<String>,
    /// The content of the project description.
    pub document_content: Option<Box<DocumentContent>>,
    /// Comments associated with the project overview.
    pub comments: Option<Box<CommentConnection>>,
    /// Relations associated with this project.
    pub relations: Option<Box<ProjectRelationConnection>>,
    /// Inverse relations associated with this project.
    pub inverse_relations: Option<Box<ProjectRelationConnection>>,
    /// Customer needs associated with the project.
    pub needs: Option<Box<CustomerNeedConnection>>,
    /// `DEPRECATED` The type of the state.
    pub state: Option<String>,
    /// The priority of the project as a label.
    pub priority_label: Option<String>,
}
impl GraphQLFields for Project {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Project>>,
}
impl GraphQLFields for ProjectArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Project attachment
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectAttachment {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Title of the attachment.
    pub title: Option<String>,
    /// Optional subtitle of the attachment
    pub subtitle: Option<String>,
    /// URL of the attachment.
    pub url: Option<String>,
    /// The creator of the attachment.
    pub creator: Option<Box<User>>,
    /// Custom metadata related to the attachment.
    pub metadata: Option<serde_json::Value>,
    /// Information about the external source which created the attachment.
    pub source: Option<serde_json::Value>,
    /// An accessor helper to source.type, defines the source type of the attachment.
    pub source_type: Option<String>,
    /// The project this attachment belongs to.
    pub project: Option<Box<Project>>,
    /// The body data of the attachment, if any.
    pub body_data: Option<String>,
}
impl GraphQLFields for ProjectAttachment {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title subtitle url metadata source sourceType bodyData"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectAttachmentConnection {
    pub edges: Option<Box<Vec<ProjectAttachmentEdge>>>,
    pub nodes: Option<Box<Vec<ProjectAttachment>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectAttachmentConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectAttachmentEdge {
    pub node: Option<Box<ProjectAttachment>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectAttachmentEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectConnection {
    pub edges: Option<Box<Vec<ProjectEdge>>>,
    pub nodes: Option<Box<Vec<Project>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectEdge {
    pub node: Option<Box<Project>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectFilterSuggestionPayload {
    /// The json filter that is suggested.
    pub filter: Option<serde_json::Value>,
    /// The log id of the prompt, that created this filter.
    pub log_id: Option<String>,
}
impl GraphQLFields for ProjectFilterSuggestionPayload {
    type FullType = Self;
    fn selection() -> String {
        "filter logId".into()
    }
}
/// An history associated with a project.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectHistory {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The events that happened while recording that history.
    pub entries: Option<serde_json::Value>,
    /// The project that the history is associated with.
    pub project: Option<Box<Project>>,
}
impl GraphQLFields for ProjectHistory {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt entries".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectHistoryConnection {
    pub edges: Option<Box<Vec<ProjectHistoryEdge>>>,
    pub nodes: Option<Box<Vec<ProjectHistory>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectHistoryConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectHistoryEdge {
    pub node: Option<Box<ProjectHistory>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectHistoryEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// Labels that can be associated with projects.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectLabel {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The label's name.
    pub name: Option<String>,
    /// The label's description.
    pub description: Option<String>,
    /// The label's color as a HEX string.
    pub color: Option<String>,
    /// Whether the label is a group.
    pub is_group: Option<bool>,
    /// The date when the label was last applied to an issue or project.
    pub last_applied_at: Option<chrono::DateTime<chrono::Utc>>,
    /// `Internal` When the label was retired.
    pub retired_at: Option<chrono::DateTime<chrono::Utc>>,
    pub organization: Option<Box<Organization>>,
    /// The user who created the label.
    pub creator: Option<Box<User>>,
    /// The user who retired the label.
    pub retired_by: Option<Box<User>>,
    /// The parent label.
    pub parent: Option<Box<ProjectLabel>>,
    /// Projects associated with the label.
    pub projects: Option<Box<ProjectConnection>>,
    /// Children of the label.
    pub children: Option<Box<ProjectLabelConnection>>,
}
impl GraphQLFields for ProjectLabel {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name description color isGroup lastAppliedAt retiredAt"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectLabelConnection {
    pub edges: Option<Box<Vec<ProjectLabelEdge>>>,
    pub nodes: Option<Box<Vec<ProjectLabel>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectLabelConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectLabelEdge {
    pub node: Option<Box<ProjectLabel>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectLabelEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectLabelPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The label that was created or updated.
    pub project_label: Option<Box<ProjectLabel>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectLabelPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A milestone for a project.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestone {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the project milestone.
    pub name: Option<String>,
    /// The content of the project milestone description.
    pub document_content: Option<Box<DocumentContent>>,
    /// The planned completion date of the milestone.
    pub target_date: Option<chrono::NaiveDate>,
    /// The project of the milestone.
    pub project: Option<Box<Project>>,
    /// `Internal` The progress history of the project milestone.
    pub progress_history: Option<serde_json::Value>,
    /// `Internal` The current progress of the project milestone.
    pub current_progress: Option<serde_json::Value>,
    /// The order of the milestone in relation to other milestones within a project.
    pub sort_order: Option<f64>,
    /// The project milestone's description in markdown format.
    pub description: Option<String>,
    /// The status of the project milestone.
    pub status: Option<ProjectMilestoneStatus>,
    /// The progress % of the project milestone.
    pub progress: Option<f64>,
    /// `Internal` The project milestone's description as YJS state.
    pub description_state: Option<String>,
    /// Issues associated with the project milestone.
    pub issues: Option<Box<IssueConnection>>,
}
impl GraphQLFields for ProjectMilestone {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name targetDate progressHistory currentProgress sortOrder description status progress"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestoneConnection {
    pub edges: Option<Box<Vec<ProjectMilestoneEdge>>>,
    pub nodes: Option<Box<Vec<ProjectMilestone>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectMilestoneConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestoneEdge {
    pub node: Option<Box<ProjectMilestone>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectMilestoneEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestoneMoveIssueToTeam {
    /// The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team
    pub issue_id: Option<String>,
    /// The team id in this relationship
    pub team_id: Option<String>,
}
impl GraphQLFields for ProjectMilestoneMoveIssueToTeam {
    type FullType = Self;
    fn selection() -> String {
        "issueId teamId".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestoneMovePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The project milestone that was created or updated.
    pub project_milestone: Option<Box<ProjectMilestone>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// A snapshot of the issues that were moved to new teams, if the user selected to do it, containing an array of mappings between an issue and its previous team. Store on the client to use for undoing a previous milestone move.
    pub previous_issue_team_ids: Option<Box<Vec<ProjectMilestoneMoveIssueToTeam>>>,
    /// A snapshot of the project that had new teams added to it, if the user selected to do it, containing an array of mappings between a project and its previous teams. Store on the client to use for undoing a previous milestone move.
    pub previous_project_team_ids: Option<Box<ProjectMilestoneMoveProjectTeams>>,
}
impl GraphQLFields for ProjectMilestoneMovePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestoneMoveProjectTeams {
    /// The project id
    pub project_id: Option<String>,
    /// The team ids for the project
    pub team_ids: Option<Vec<String>>,
}
impl GraphQLFields for ProjectMilestoneMoveProjectTeams {
    type FullType = Self;
    fn selection() -> String {
        "projectId teamIds".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectMilestonePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The project milestone that was created or updated.
    pub project_milestone: Option<Box<ProjectMilestone>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectMilestonePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A project related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectNotification {
    /// Related comment ID. Null if the notification is not related to a comment.
    pub comment_id: Option<String>,
    /// Related parent comment ID. Null if the notification is not related to a comment.
    pub parent_comment_id: Option<String>,
    /// Name of the reaction emoji related to the notification.
    pub reaction_emoji: Option<String>,
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related project ID.
    pub project_id: Option<String>,
    /// Related project milestone ID.
    pub project_milestone_id: Option<String>,
    /// Related project update ID.
    pub project_update_id: Option<String>,
    /// The project related to the notification.
    pub project: Option<Box<Project>>,
    /// The document related to the notification.
    pub document: Option<Box<Document>>,
    /// The project update related to the notification.
    pub project_update: Option<Box<ProjectUpdate>>,
    /// The comment related to the notification.
    pub comment: Option<Box<Comment>>,
    /// The parent comment related to the notification, if a notification is a reply comment notification.
    pub parent_comment: Option<Box<Comment>>,
}
impl GraphQLFields for ProjectNotification {
    type FullType = Self;
    fn selection() -> String {
        "commentId parentCommentId reactionEmoji id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority projectId projectMilestoneId projectUpdateId"
            .into()
    }
}
/// A project notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The project subscribed to.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for ProjectNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The project that was created or updated.
    pub project: Option<Box<Project>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A relation between two projects.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectRelation {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The relationship of the project with the related project.
    pub r#type: Option<String>,
    /// The project whose relationship is being described.
    pub project: Option<Box<Project>>,
    /// The milestone within the project whose relationship is being described.
    pub project_milestone: Option<Box<ProjectMilestone>>,
    /// The type of anchor on the project end of the relation.
    pub anchor_type: Option<String>,
    /// The related project.
    pub related_project: Option<Box<Project>>,
    /// The milestone within the related project whose relationship is being described.
    pub related_project_milestone: Option<Box<ProjectMilestone>>,
    /// The type of anchor on the relatedProject end of the relation.
    pub related_anchor_type: Option<String>,
    /// The last user who created or modified the relation.
    pub user: Option<Box<User>>,
}
impl GraphQLFields for ProjectRelation {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type anchorType relatedAnchorType".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectRelationConnection {
    pub edges: Option<Box<Vec<ProjectRelationEdge>>>,
    pub nodes: Option<Box<Vec<ProjectRelation>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectRelationConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectRelationEdge {
    pub node: Option<Box<ProjectRelation>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectRelationEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectRelationPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The project relation that was created or updated.
    pub project_relation: Option<Box<ProjectRelation>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectRelationPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectSearchPayload {
    pub edges: Option<Box<Vec<ProjectSearchResultEdge>>>,
    pub nodes: Option<Box<Vec<ProjectSearchResult>>>,
    pub page_info: Option<Box<PageInfo>>,
    /// Archived entities matching the search term along with all their dependencies.
    pub archive_payload: Option<Box<ArchiveResponse>>,
    /// Total number of results for query without filters applied.
    pub total_count: Option<f64>,
}
impl GraphQLFields for ProjectSearchPayload {
    type FullType = Self;
    fn selection() -> String {
        "totalCount".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectSearchResult {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
    pub update_reminder_frequency_in_weeks: Option<f64>,
    /// The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
    pub update_reminder_frequency: Option<f64>,
    /// The resolution of the reminder frequency.
    pub frequency_resolution: Option<FrequencyResolutionType>,
    /// The day at which to prompt for updates.
    pub update_reminders_day: Option<Day>,
    /// The hour at which to prompt for updates.
    pub update_reminders_hour: Option<f64>,
    /// The project's name.
    pub name: Option<String>,
    /// The project's description.
    pub description: Option<String>,
    /// The project's unique URL slug.
    pub slug_id: Option<String>,
    /// The icon of the project.
    pub icon: Option<String>,
    /// The project's color.
    pub color: Option<String>,
    /// The status that the project is associated with.
    pub status: Option<Box<ProjectStatus>>,
    /// The user who created the project.
    pub creator: Option<Box<User>>,
    /// The project lead.
    pub lead: Option<Box<User>>,
    /// `Internal` Facets associated with the project.
    pub facets: Option<Box<Vec<Facet>>>,
    /// The time until which project update reminders are paused.
    pub project_update_reminders_paused_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The estimated start date of the project.
    pub start_date: Option<chrono::NaiveDate>,
    /// The resolution of the project's start date.
    pub start_date_resolution: Option<DateResolutionType>,
    /// The estimated completion date of the project.
    pub target_date: Option<chrono::NaiveDate>,
    /// The resolution of the project's estimated completion date.
    pub target_date_resolution: Option<DateResolutionType>,
    /// The time at which the project was moved into started state.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the project was moved into completed state.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the project was moved into canceled state.
    pub canceled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the project was automatically archived by the auto pruning process.
    pub auto_archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A flag that indicates whether the project is in the trash bin.
    pub trashed: Option<bool>,
    /// The sort order for the project within the organization.
    pub sort_order: Option<f64>,
    /// The sort order for the project within the organization, when ordered by priority.
    pub priority_sort_order: Option<f64>,
    /// The project was created based on this issue.
    pub converted_from_issue: Option<Box<Issue>>,
    /// The last template that was applied to this project.
    pub last_applied_template: Option<Box<Template>>,
    /// The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
    pub priority: Option<i64>,
    /// The last project update posted for this project.
    pub last_update: Option<Box<ProjectUpdate>>,
    /// The health of the project.
    pub health: Option<ProjectUpdateHealthType>,
    /// The time at which the project health was updated.
    pub health_updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The total number of issues in the project after each week.
    pub issue_count_history: Option<Vec<f64>>,
    /// The number of completed issues in the project after each week.
    pub completed_issue_count_history: Option<Vec<f64>>,
    /// The total number of estimation points after each week.
    pub scope_history: Option<Vec<f64>>,
    /// The number of completed estimation points after each week.
    pub completed_scope_history: Option<Vec<f64>>,
    /// The number of in progress estimation points after each week.
    pub in_progress_scope_history: Option<Vec<f64>>,
    /// `INTERNAL` The progress history of the project.
    pub progress_history: Option<serde_json::Value>,
    /// `INTERNAL` The current progress of the project.
    pub current_progress: Option<serde_json::Value>,
    /// Whether to send new issue notifications to Slack.
    pub slack_new_issue: Option<bool>,
    /// Whether to send new issue comment notifications to Slack.
    pub slack_issue_comments: Option<bool>,
    /// Whether to send new issue status updates to Slack.
    pub slack_issue_statuses: Option<bool>,
    /// Id of the labels associated with this project.
    pub label_ids: Option<Vec<String>>,
    /// The user's favorite associated with this project.
    pub favorite: Option<Box<Favorite>>,
    /// Project URL.
    pub url: Option<String>,
    /// Initiatives that this project belongs to.
    pub initiatives: Option<Box<InitiativeConnection>>,
    /// Associations of this project to parent initiatives.
    pub initiative_to_projects: Option<Box<InitiativeToProjectConnection>>,
    /// Teams associated with this project.
    pub teams: Option<Box<TeamConnection>>,
    /// Users that are members of the project.
    pub members: Option<Box<UserConnection>>,
    /// Project updates associated with the project.
    pub project_updates: Option<Box<ProjectUpdateConnection>>,
    /// Documents associated with the project.
    pub documents: Option<Box<DocumentConnection>>,
    /// Milestones associated with the project.
    pub project_milestones: Option<Box<ProjectMilestoneConnection>>,
    /// Issues associated with the project.
    pub issues: Option<Box<IssueConnection>>,
    /// External links associated with the project.
    pub external_links: Option<Box<EntityExternalLinkConnection>>,
    /// Attachments associated with the project.
    pub attachments: Option<Box<ProjectAttachmentConnection>>,
    /// History entries associated with the project.
    pub history: Option<Box<ProjectHistoryConnection>>,
    /// Labels associated with this project.
    pub labels: Option<Box<ProjectLabelConnection>>,
    /// The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
    pub progress: Option<f64>,
    /// The overall scope (total estimate points) of the project.
    pub scope: Option<f64>,
    /// Settings for all integrations associated with that project.
    pub integrations_settings: Option<Box<IntegrationsSettings>>,
    /// The project's content in markdown format.
    pub content: Option<String>,
    /// `Internal` The project's content as YJS state.
    pub content_state: Option<String>,
    /// The content of the project description.
    pub document_content: Option<Box<DocumentContent>>,
    /// Comments associated with the project overview.
    pub comments: Option<Box<CommentConnection>>,
    /// Relations associated with this project.
    pub relations: Option<Box<ProjectRelationConnection>>,
    /// Inverse relations associated with this project.
    pub inverse_relations: Option<Box<ProjectRelationConnection>>,
    /// Customer needs associated with the project.
    pub needs: Option<Box<CustomerNeedConnection>>,
    /// `DEPRECATED` The type of the state.
    pub state: Option<String>,
    /// The priority of the project as a label.
    pub priority_label: Option<String>,
    /// Metadata related to search result.
    pub metadata: Option<serde_json::Value>,
}
impl GraphQLFields for ProjectSearchResult {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt updateReminderFrequencyInWeeks updateReminderFrequency frequencyResolution updateRemindersDay updateRemindersHour name description slugId icon color projectUpdateRemindersPausedUntilAt startDate startDateResolution targetDate targetDateResolution startedAt completedAt canceledAt autoArchivedAt trashed sortOrder prioritySortOrder priority health healthUpdatedAt issueCountHistory completedIssueCountHistory scopeHistory completedScopeHistory inProgressScopeHistory progressHistory currentProgress slackNewIssue slackIssueComments slackIssueStatuses labelIds url progress scope content contentState state priorityLabel metadata"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectSearchResultEdge {
    pub node: Option<Box<ProjectSearchResult>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectSearchResultEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A project status.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectStatus {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the status.
    pub name: Option<String>,
    /// The UI color of the status as a HEX string.
    pub color: Option<String>,
    /// Description of the status.
    pub description: Option<String>,
    /// The position of the status in the workspace's project flow.
    pub position: Option<f64>,
    /// The type of the project status.
    pub r#type: Option<ProjectStatusType>,
    /// Whether or not a project can be in this status indefinitely.
    pub indefinite: Option<bool>,
}
impl GraphQLFields for ProjectStatus {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name color description position type indefinite".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectStatusArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<ProjectStatus>>,
}
impl GraphQLFields for ProjectStatusArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectStatusConnection {
    pub edges: Option<Box<Vec<ProjectStatusEdge>>>,
    pub nodes: Option<Box<Vec<ProjectStatus>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectStatusConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectStatusCountPayload {
    /// Total number of projects using this project status.
    pub count: Option<f64>,
    /// Total number of projects using this project status that are not visible to the user because they are in a private team.
    pub private_count: Option<f64>,
    /// Total number of projects using this project status that are not visible to the user because they are in an archived team.
    pub archived_team_count: Option<f64>,
}
impl GraphQLFields for ProjectStatusCountPayload {
    type FullType = Self;
    fn selection() -> String {
        "count privateCount archivedTeamCount".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectStatusEdge {
    pub node: Option<Box<ProjectStatus>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectStatusEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectStatusPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The project status that was created or updated.
    pub status: Option<Box<ProjectStatus>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectStatusPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An update associated with a project.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectUpdate {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The update content in markdown format.
    pub body: Option<String>,
    /// The time the update was edited.
    pub edited_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Emoji reaction summary, grouped by emoji type.
    pub reaction_data: Option<serde_json::Value>,
    /// `Internal` The content of the update as a Prosemirror document.
    pub body_data: Option<String>,
    /// The update's unique URL slug.
    pub slug_id: Option<String>,
    /// The project that the update is associated with.
    pub project: Option<Box<Project>>,
    /// The health of the project at the time of the update.
    pub health: Option<ProjectUpdateHealthType>,
    /// The user who wrote the update.
    pub user: Option<Box<User>>,
    /// `Internal` Serialized JSON representing current state of the project properties when posting the project update.
    pub info_snapshot: Option<serde_json::Value>,
    /// Whether project update diff should be hidden.
    pub is_diff_hidden: Option<bool>,
    /// The URL to the project update.
    pub url: Option<String>,
    /// Whether the project update is stale.
    pub is_stale: Option<bool>,
    /// The diff between the current update and the previous one.
    pub diff: Option<serde_json::Value>,
    /// The diff between the current update and the previous one, formatted as markdown.
    pub diff_markdown: Option<String>,
    /// Reactions associated with the project update.
    pub reactions: Option<Box<Vec<Reaction>>>,
    /// Comments associated with the project update.
    pub comments: Option<Box<CommentConnection>>,
    /// Number of comments associated with the project update.
    pub comment_count: Option<i64>,
}
impl GraphQLFields for ProjectUpdate {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt body editedAt reactionData bodyData slugId health infoSnapshot isDiffHidden url isStale diff diffMarkdown commentCount"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectUpdateArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<ProjectUpdate>>,
}
impl GraphQLFields for ProjectUpdateArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectUpdateConnection {
    pub edges: Option<Box<Vec<ProjectUpdateEdge>>>,
    pub nodes: Option<Box<Vec<ProjectUpdate>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ProjectUpdateConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectUpdateEdge {
    pub node: Option<Box<ProjectUpdate>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ProjectUpdateEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectUpdatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The project update that was created or updated.
    pub project_update: Option<Box<ProjectUpdate>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectUpdatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ProjectUpdateReminderPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ProjectUpdateReminderPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Internal` A pull request in a version control system.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PullRequest {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The pull request's unique URL slug.
    pub slug_id: Option<String>,
    /// The title of the pull request.
    pub title: Option<String>,
    /// The number of the pull request in the version control system.
    pub number: Option<f64>,
    /// The source branch of the pull request.
    pub source_branch: Option<String>,
    /// The target branch of the pull request.
    pub target_branch: Option<String>,
    /// The URL of the pull request in the version control system.
    pub url: Option<String>,
    /// The status of the pull request.
    pub status: Option<PullRequestStatus>,
    /// Merge settings for this pull request.
    pub merge_settings: Option<Box<PullRequestMergeSettings>>,
    /// The merge commit created when the PR was merged.
    pub merge_commit: Option<Box<PullRequestCommit>>,
    /// `Internal` The checks associated with the pull request.
    pub checks: Option<Box<Vec<PullRequestCheck>>>,
    /// `ALPHA` The commits associated with the pull request.
    pub commits: Option<Box<Vec<PullRequestCommit>>>,
    /// `Internal` The user who created the pull request.
    pub creator: Option<Box<User>>,
    /// Agent sessions associated with this pull request.
    pub agent_sessions: Option<Box<AgentSessionToPullRequestConnection>>,
    /// Pull request URL to the Linear app
    pub app_url: Option<String>,
    /// The pull request's description in markdown format.
    pub description: Option<String>,
    /// The pull request's description as a Prosemirror document.
    pub description_data: Option<serde_json::Value>,
    /// Integration type that created this pull request, if applicable.
    pub integration_source_type: Option<IntegrationService>,
    /// Diff statistics for the pull request including file count, additions, deletions, and changes.
    pub diff_stats: Option<Box<PullRequestDiffStats>>,
}
impl GraphQLFields for PullRequest {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt slugId title number sourceBranch targetBranch url status appUrl description descriptionData integrationSourceType"
            .into()
    }
}
/// `ALPHA` A pull request check.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PullRequestCheck {
    /// The name of the check.
    pub name: Option<String>,
    /// The name of the workflow that triggered the check.
    pub workflow_name: Option<String>,
    /// The status of the check.
    pub status: Option<String>,
    /// The URL of the check.
    pub url: Option<String>,
    /// Whether the check is required.
    pub is_required: Option<bool>,
    /// The date/time at which when the check was started.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date/time at which when the check was completed.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for PullRequestCheck {
    type FullType = Self;
    fn selection() -> String {
        "name workflowName status url isRequired startedAt completedAt".into()
    }
}
/// `ALPHA` A pull request commit.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PullRequestCommit {
    /// The Git commit SHA.
    pub sha: Option<String>,
    /// The full commit message.
    pub message: Option<String>,
    /// The timestamp when the commit was committed (ISO 8601 string).
    pub committed_at: Option<String>,
    /// Number of additions in this commit.
    pub additions: Option<f64>,
    /// Number of deletions in this commit.
    pub deletions: Option<f64>,
    /// The number of changed files if available.
    pub changed_files: Option<f64>,
    /// Linear user IDs for commit authors (includes co-authors).
    pub author_user_ids: Option<Vec<String>>,
    /// External user IDs for commit authors (includes co-authors).
    pub author_external_user_ids: Option<Vec<String>>,
}
impl GraphQLFields for PullRequestCommit {
    type FullType = Self;
    fn selection() -> String {
        "sha message committedAt additions deletions changedFiles authorUserIds authorExternalUserIds"
            .into()
    }
}
/// Diff statistics for a pull request.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PullRequestDiffStats {
    /// The number of files changed in the pull request.
    pub file_count: Option<f64>,
    /// The number of lines added in the pull request.
    pub additions: Option<f64>,
    /// The number of lines changed in the pull request.
    pub changes: Option<f64>,
    /// The number of lines deleted in the pull request.
    pub deletions: Option<f64>,
}
impl GraphQLFields for PullRequestDiffStats {
    type FullType = Self;
    fn selection() -> String {
        "fileCount additions changes deletions".into()
    }
}
/// `Internal` Merge settings for a pull request
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PullRequestMergeSettings {
    /// Whether merge queue is enabled for this repository.
    pub is_merge_queue_enabled: Option<bool>,
    /// Whether squash merge is allowed for this pull request's repository.
    pub squash_merge_allowed: Option<bool>,
    /// Whether auto-merge is allowed for the PR's repository.
    pub auto_merge_allowed: Option<bool>,
    /// Whether rebase merge is allowed for pull requests PR's repository.
    pub rebase_merge_allowed: Option<bool>,
    /// Whether merge commits are allowed for pull requests PR's repository.
    pub merge_commit_allowed: Option<bool>,
    /// Whether the branch will be deleted when the pull request is merged.
    pub delete_branch_on_merge: Option<bool>,
    /// The method used to merge a pull request.
    pub merge_queue_merge_method: Option<PullRequestMergeMethod>,
}
impl GraphQLFields for PullRequestMergeSettings {
    type FullType = Self;
    fn selection() -> String {
        "isMergeQueueEnabled squashMergeAllowed autoMergeAllowed rebaseMergeAllowed mergeCommitAllowed deleteBranchOnMerge mergeQueueMergeMethod"
            .into()
    }
}
/// A pull request related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PullRequestNotification {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related pull request.
    pub pull_request_id: Option<String>,
    /// Related pull request comment ID. Null if the notification is not related to a pull request comment.
    pub pull_request_comment_id: Option<String>,
    /// The pull request related to the notification.
    pub pull_request: Option<Box<PullRequest>>,
}
impl GraphQLFields for PullRequestNotification {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority pullRequestId pullRequestCommentId"
            .into()
    }
}
/// A user's web or mobile push notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PushSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for PushSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PushSubscriptionPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The push subscription that was created or updated.
    pub entity: Option<Box<PushSubscription>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for PushSubscriptionPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct PushSubscriptionTestPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for PushSubscriptionTestPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RateLimitPayload {
    /// The identifier we rate limit on.
    pub identifier: Option<String>,
    /// The kind of rate limit selected for this request.
    pub kind: Option<String>,
    /// The state of the rate limit.
    pub limits: Option<Box<Vec<RateLimitResultPayload>>>,
}
impl GraphQLFields for RateLimitPayload {
    type FullType = Self;
    fn selection() -> String {
        "identifier kind".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RateLimitResultPayload {
    /// What is being rate limited.
    pub r#type: Option<String>,
    /// The requested quantity for this type of limit.
    pub requested_amount: Option<f64>,
    /// The total allowed quantity for this type of limit.
    pub allowed_amount: Option<f64>,
    /// The period in which the rate limit is fully replenished in ms.
    pub period: Option<f64>,
    /// The remaining quantity for this type of limit after this request.
    pub remaining_amount: Option<f64>,
    /// The timestamp after the rate limit is fully replenished as a UNIX timestamp.
    pub reset: Option<f64>,
}
impl GraphQLFields for RateLimitResultPayload {
    type FullType = Self;
    fn selection() -> String {
        "type requestedAmount allowedAmount period remainingAmount reset".into()
    }
}
/// A reaction associated with a comment or a project update.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Reaction {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Name of the reaction's emoji.
    pub emoji: Option<String>,
    /// The issue that the reaction is associated with.
    pub issue: Option<Box<Issue>>,
    /// The comment that the reaction is associated with.
    pub comment: Option<Box<Comment>>,
    /// The project update that the reaction is associated with.
    pub project_update: Option<Box<ProjectUpdate>>,
    /// The initiative update that the reaction is associated with.
    pub initiative_update: Option<Box<InitiativeUpdate>>,
    /// The post that the reaction is associated with.
    pub post: Option<Box<Post>>,
    /// The user that created the reaction.
    pub user: Option<Box<User>>,
    /// The external user that created the reaction.
    pub external_user: Option<Box<ExternalUser>>,
}
impl GraphQLFields for Reaction {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt emoji".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReactionPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    pub reaction: Option<Box<Reaction>>,
    pub success: Option<bool>,
}
impl GraphQLFields for ReactionPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Internal` A release.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Release {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the release.
    pub name: Option<String>,
    /// The release's description.
    pub description: Option<String>,
    /// The version of the release.
    pub version: Option<String>,
    /// The commit SHA associated with this release.
    pub commit_sha: Option<String>,
    /// The pipeline this release belongs to.
    pub pipeline: Option<Box<ReleasePipeline>>,
    /// The current stage of the release.
    pub stage: Option<Box<ReleaseStage>>,
    /// The release's unique URL slug.
    pub slug_id: Option<String>,
    /// The estimated start date of the release.
    pub start_date: Option<chrono::NaiveDate>,
    /// The estimated completion date of the release.
    pub target_date: Option<chrono::NaiveDate>,
    /// The time at which the release was started.
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the release was completed.
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the release was canceled.
    pub canceled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Release URL.
    pub url: Option<String>,
    /// `Internal` Documents associated with the release.
    pub documents: Option<Box<DocumentConnection>>,
    /// `Internal` Links associated with the release.
    pub links: Option<Box<EntityExternalLinkConnection>>,
}
impl GraphQLFields for Release {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name description version commitSha slugId startDate targetDate startedAt completedAt canceledAt url"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Release>>,
}
impl GraphQLFields for ReleaseArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseConnection {
    pub edges: Option<Box<Vec<ReleaseEdge>>>,
    pub nodes: Option<Box<Vec<Release>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ReleaseConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseEdge {
    pub node: Option<Box<Release>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ReleaseEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleasePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The release that was created or updated.
    pub release: Option<Box<Release>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ReleasePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Internal` A release pipeline.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleasePipeline {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the pipeline.
    pub name: Option<String>,
    /// The pipeline's unique slug identifier.
    pub slug_id: Option<String>,
    /// The type of the pipeline.
    pub r#type: Option<ReleasePipelineType>,
    /// Glob patterns to include commits affecting matching file paths.
    pub include_path_patterns: Option<Vec<String>>,
    /// `ALPHA` The active access key for this pipeline.
    pub access_key: Option<Box<AccessKey>>,
    /// `ALPHA` Stages associated with this pipeline.
    pub stages: Option<Box<ReleaseStageConnection>>,
    /// `ALPHA` Releases associated with this pipeline.
    pub releases: Option<Box<ReleaseConnection>>,
}
impl GraphQLFields for ReleasePipeline {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name slugId type includePathPatterns".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleasePipelineArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<ReleasePipeline>>,
}
impl GraphQLFields for ReleasePipelineArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleasePipelineConnection {
    pub edges: Option<Box<Vec<ReleasePipelineEdge>>>,
    pub nodes: Option<Box<Vec<ReleasePipeline>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ReleasePipelineConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleasePipelineEdge {
    pub node: Option<Box<ReleasePipeline>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ReleasePipelineEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleasePipelinePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The release pipeline that was created or updated.
    pub release_pipeline: Option<Box<ReleasePipeline>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ReleasePipelinePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Internal` A release stage.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseStage {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the stage.
    pub name: Option<String>,
    /// The UI color of the stage as a HEX string.
    pub color: Option<String>,
    /// The type of the stage.
    pub r#type: Option<ReleaseStageType>,
    /// The position of the stage.
    pub position: Option<f64>,
    /// Whether this stage is frozen. Only applicable to started type stages.
    pub frozen: Option<bool>,
    /// The pipeline this stage belongs to.
    pub pipeline: Option<Box<ReleasePipeline>>,
    /// `ALPHA` Releases associated with this stage.
    pub releases: Option<Box<ReleaseConnection>>,
}
impl GraphQLFields for ReleaseStage {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name color type position frozen".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseStageArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<ReleaseStage>>,
}
impl GraphQLFields for ReleaseStageArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseStageConnection {
    pub edges: Option<Box<Vec<ReleaseStageEdge>>>,
    pub nodes: Option<Box<Vec<ReleaseStage>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for ReleaseStageConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseStageEdge {
    pub node: Option<Box<ReleaseStage>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for ReleaseStageEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ReleaseStagePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The release stage that was created or updated.
    pub release_stage: Option<Box<ReleaseStage>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ReleaseStagePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RepositorySuggestion {
    /// The full name of the repository in owner/name format (e.g., 'acme/backend').
    pub repository_full_name: Option<String>,
    /// Hostname of the Git service (e.g., 'github.com', 'github.company.com').
    pub hostname: Option<String>,
    /// Confidence score from 0.0 to 1.0.
    pub confidence: Option<f64>,
}
impl GraphQLFields for RepositorySuggestion {
    type FullType = Self;
    fn selection() -> String {
        "repositoryFullName hostname confidence".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RepositorySuggestionsPayload {
    /// The suggested repositories.
    pub suggestions: Option<Box<Vec<RepositorySuggestion>>>,
}
impl GraphQLFields for RepositorySuggestionsPayload {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
/// `Deprecated` A roadmap for projects.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Roadmap {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the roadmap.
    pub name: Option<String>,
    /// The description of the roadmap.
    pub description: Option<String>,
    /// The organization of the roadmap.
    pub organization: Option<Box<Organization>>,
    /// The user who created the roadmap.
    pub creator: Option<Box<User>>,
    /// The user who owns the roadmap.
    pub owner: Option<Box<User>>,
    /// The roadmap's unique URL slug.
    pub slug_id: Option<String>,
    /// The sort order of the roadmap within the organization.
    pub sort_order: Option<f64>,
    /// The roadmap's color.
    pub color: Option<String>,
    /// Projects associated with the roadmap.
    pub projects: Option<Box<ProjectConnection>>,
    /// The canonical url for the roadmap.
    pub url: Option<String>,
}
impl GraphQLFields for Roadmap {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name description slugId sortOrder color url".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Roadmap>>,
}
impl GraphQLFields for RoadmapArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapConnection {
    pub edges: Option<Box<Vec<RoadmapEdge>>>,
    pub nodes: Option<Box<Vec<Roadmap>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for RoadmapConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapEdge {
    pub node: Option<Box<Roadmap>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for RoadmapEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The roadmap that was created or updated.
    pub roadmap: Option<Box<Roadmap>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for RoadmapPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// `Deprecated` Join table between projects and roadmaps.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapToProject {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The project that the roadmap is associated with.
    pub project: Option<Box<Project>>,
    /// The roadmap that the project is associated with.
    pub roadmap: Option<Box<Roadmap>>,
    /// The sort order of the project within the roadmap.
    pub sort_order: Option<String>,
}
impl GraphQLFields for RoadmapToProject {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt sortOrder".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapToProjectConnection {
    pub edges: Option<Box<Vec<RoadmapToProjectEdge>>>,
    pub nodes: Option<Box<Vec<RoadmapToProject>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for RoadmapToProjectConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapToProjectEdge {
    pub node: Option<Box<RoadmapToProject>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for RoadmapToProjectEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct RoadmapToProjectPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The roadmapToProject that was created or updated.
    pub roadmap_to_project: Option<Box<RoadmapToProject>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for RoadmapToProjectPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Payload returned by semantic search.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SemanticSearchPayload {
    /// Whether the semantic search is enabled.
    pub enabled: Option<bool>,
    pub results: Option<Box<Vec<SemanticSearchResult>>>,
}
impl GraphQLFields for SemanticSearchPayload {
    type FullType = Self;
    fn selection() -> String {
        "enabled".into()
    }
}
/// A semantic search result reference.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SemanticSearchResult {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The type of the semantic search result.
    pub r#type: Option<SemanticSearchResultType>,
    /// The issue related to the semantic search result.
    pub issue: Option<Box<Issue>>,
    /// The project related to the semantic search result.
    pub project: Option<Box<Project>>,
    /// The initiative related to the semantic search result.
    pub initiative: Option<Box<Initiative>>,
    /// The document related to the semantic search result.
    pub document: Option<Box<Document>>,
}
impl GraphQLFields for SemanticSearchResult {
    type FullType = Self;
    fn selection() -> String {
        "id type".into()
    }
}
/// SES domain identity used for sending emails from a custom domain.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SesDomainIdentity {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The domain of the SES domain identity.
    pub domain: Option<String>,
    /// The AWS region of the SES domain identity.
    pub region: Option<String>,
    /// The organization of the SES domain identity.
    pub organization: Option<Box<Organization>>,
    /// The user who created the SES domain identity.
    pub creator: Option<Box<User>>,
    /// Whether the domain is fully verified and can be used for sending emails.
    pub can_send_from_custom_domain: Option<bool>,
    /// The DNS records for the SES domain identity.
    pub dns_records: Option<Box<Vec<SesDomainIdentityDnsRecord>>>,
}
impl GraphQLFields for SesDomainIdentity {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt domain region canSendFromCustomDomain".into()
    }
}
/// A DNS record for a SES domain identity.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SesDomainIdentityDnsRecord {
    /// The type of the DNS record.
    pub r#type: Option<String>,
    /// The name of the DNS record.
    pub name: Option<String>,
    /// The content of the DNS record.
    pub content: Option<String>,
    /// Whether the DNS record is verified in the domain's DNS configuration.
    pub is_verified: Option<bool>,
}
impl GraphQLFields for SesDomainIdentityDnsRecord {
    type FullType = Self;
    fn selection() -> String {
        "type name content isVerified".into()
    }
}
/// Tuple for mapping Slack channel IDs to names.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SlackAsksTeamSettings {
    /// The Linear team ID.
    pub id: Option<String>,
    /// Whether the default Asks template is enabled in the given channel for this team.
    pub has_default_ask: Option<bool>,
}
impl GraphQLFields for SlackAsksTeamSettings {
    type FullType = Self;
    fn selection() -> String {
        "id hasDefaultAsk".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SlackChannelConnectPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The integration that was created or updated.
    pub integration: Option<Box<Integration>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// Whether the bot needs to be manually added to the channel.
    pub add_bot: Option<bool>,
    /// Whether it's recommended to connect main Slack integration.
    pub nudge_to_connect_main_slack_integration: Option<bool>,
    /// Whether it's recommended to update main Slack integration.
    pub nudge_to_update_main_slack_integration: Option<bool>,
}
impl GraphQLFields for SlackChannelConnectPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success addBot nudgeToConnectMainSlackIntegration nudgeToUpdateMainSlackIntegration"
            .into()
    }
}
/// Object for mapping Slack channel IDs to names and other settings.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SlackChannelNameMapping {
    /// The Slack channel ID.
    pub id: Option<String>,
    /// The Slack channel name.
    pub name: Option<String>,
    /// Whether or not the Slack channel is private.
    pub is_private: Option<bool>,
    /// Whether or not the Slack channel is shared with an external org.
    pub is_shared: Option<bool>,
    /// Whether or not the Linear Asks bot has been added to this Slack channel.
    pub bot_added: Option<bool>,
    /// Which teams are connected to the channel and settings for those teams.
    pub teams: Option<Box<Vec<SlackAsksTeamSettings>>>,
    /// Whether or not top-level messages in this channel should automatically create Asks.
    pub auto_create_on_message: Option<bool>,
    /// Whether or not using the :ticket: emoji in this channel should automatically create Asks.
    pub auto_create_on_emoji: Option<bool>,
    /// Whether or not @-mentioning the bot should automatically create an Ask with the message.
    pub auto_create_on_bot_mention: Option<bool>,
    /// The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template.
    pub auto_create_template_id: Option<String>,
    /// Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled.
    pub post_cancellation_updates: Option<bool>,
    /// Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed.
    pub post_completion_updates: Option<bool>,
    /// Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage.
    pub post_accepted_from_triage_updates: Option<bool>,
    /// Whether or not to use AI to generate titles for Asks created in this channel.
    pub ai_titles: Option<bool>,
}
impl GraphQLFields for SlackChannelNameMapping {
    type FullType = Self;
    fn selection() -> String {
        "id name isPrivate isShared botAdded autoCreateOnMessage autoCreateOnEmoji autoCreateOnBotMention autoCreateTemplateId postCancellationUpdates postCompletionUpdates postAcceptedFromTriageUpdates aiTitles"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SsoUrlFromEmailResponse {
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// SAML SSO sign-in URL.
    pub saml_sso_url: Option<String>,
}
impl GraphQLFields for SsoUrlFromEmailResponse {
    type FullType = Self;
    fn selection() -> String {
        "success samlSsoUrl".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SuccessPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for SuccessPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// An AI-generated summary.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Summary {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The issue this summary belongs to.
    pub issue: Option<Box<Issue>>,
    /// The summary content as a Prosemirror document.
    pub content: Option<serde_json::Value>,
    /// The evaluation log id for this summary generation.
    pub eval_log_id: Option<String>,
    /// The generation status of the summary.
    pub generation_status: Option<SummaryGenerationStatus>,
    /// The time at which the summary was generated.
    pub generated_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl GraphQLFields for Summary {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt content evalLogId generationStatus generatedAt".into()
    }
}
/// A comment thread that is synced with an external source.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct SyncedExternalThread {
    pub id: Option<String>,
    /// The type of the external source.
    pub r#type: Option<String>,
    /// The sub type of the external source.
    pub sub_type: Option<String>,
    /// The display name of the source.
    pub name: Option<String>,
    /// The display name of the thread.
    pub display_name: Option<String>,
    /// The external url of the thread.
    pub url: Option<String>,
    /// Whether this thread is syncing with the external service.
    pub is_connected: Option<bool>,
    /// Whether the current user has the corresponding personal integration connected for the external service.
    pub is_personal_integration_connected: Option<bool>,
    /// Whether a connected personal integration is required to comment in this thread.
    pub is_personal_integration_required: Option<bool>,
}
impl GraphQLFields for SyncedExternalThread {
    type FullType = Self;
    fn selection() -> String {
        "id type subType name displayName url isConnected isPersonalIntegrationConnected isPersonalIntegrationRequired"
            .into()
    }
}
/// An organizational unit that contains issues.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Team {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The team's name.
    pub name: Option<String>,
    /// The team's unique key. The key is used in URLs.
    pub key: Option<String>,
    /// The team's description.
    pub description: Option<String>,
    /// The icon of the team.
    pub icon: Option<String>,
    /// The team's color.
    pub color: Option<String>,
    /// The time at which the team was retired. Null if the team has not been retired.
    pub retired_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The organization that the team is associated with.
    pub organization: Option<Box<Organization>>,
    /// `Internal` The team's parent team.
    pub parent: Option<Box<Team>>,
    /// `Internal` The team's sub-teams.
    pub children: Option<Box<Vec<Team>>>,
    /// Whether the team uses cycles.
    pub cycles_enabled: Option<bool>,
    /// The day of the week that a new cycle starts.
    pub cycle_start_day: Option<f64>,
    /// The duration of a cycle in weeks.
    pub cycle_duration: Option<f64>,
    /// The cooldown time after each cycle in weeks.
    pub cycle_cooldown_time: Option<f64>,
    /// Auto assign started issues to current cycle.
    pub cycle_issue_auto_assign_started: Option<bool>,
    /// Auto assign completed issues to current cycle.
    pub cycle_issue_auto_assign_completed: Option<bool>,
    /// Auto assign issues to current cycle if in active status.
    pub cycle_lock_to_active: Option<bool>,
    /// How many upcoming cycles to create.
    pub upcoming_cycle_count: Option<f64>,
    /// The timezone of the team. Defaults to "America/Los_Angeles"
    pub timezone: Option<String>,
    /// Whether the team should inherit its workflow statuses from its parent. Only applies to sub-teams.
    pub inherit_workflow_statuses: Option<bool>,
    /// Whether the team should inherit its estimation settings from its parent. Only applies to sub-teams.
    pub inherit_issue_estimation: Option<bool>,
    /// The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
    pub issue_estimation_type: Option<String>,
    /// `DEPRECATED` Whether issues without priority should be sorted first.
    pub issue_ordering_no_priority_first: Option<bool>,
    /// Whether to allow zeros in issues estimates.
    pub issue_estimation_allow_zero: Option<bool>,
    /// Where to move issues when changing state.
    pub set_issue_sort_order_on_state_change: Option<String>,
    /// Whether to add additional points to the estimate scale.
    pub issue_estimation_extended: Option<bool>,
    /// What to use as a default estimate for unestimated issues.
    pub default_issue_estimate: Option<f64>,
    /// Whether triage mode is enabled for the team or not.
    pub triage_enabled: Option<bool>,
    /// Whether an issue needs to have a priority set before leaving triage.
    pub require_priority_to_leave_triage: Option<bool>,
    /// The default workflow state into which issues are set when they are opened by team members.
    pub default_issue_state: Option<Box<WorkflowState>>,
    /// The default template to use for new issues created by members of the team.
    pub default_template_for_members: Option<Box<Template>>,
    /// The id of the default template to use for new issues created by members of the team.
    pub default_template_for_members_id: Option<String>,
    /// The default template to use for new issues created by non-members of the team.
    pub default_template_for_non_members: Option<Box<Template>>,
    /// The id of the default template to use for new issues created by non-members of the team.
    pub default_template_for_non_members_id: Option<String>,
    /// The default template to use for new projects created for the team.
    pub default_project_template: Option<Box<Template>>,
    /// The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
    pub triage_issue_state: Option<Box<WorkflowState>>,
    /// Whether the team is private or not.
    pub private: Option<bool>,
    /// Whether all members in the workspace can join the team. Only used for public teams.
    pub all_members_can_join: Option<bool>,
    /// Security settings for the team.
    pub security_settings: Option<serde_json::Value>,
    /// `Internal` Facets associated with the team.
    pub facets: Option<Box<Vec<Facet>>>,
    /// `Internal` Posts associated with the team.
    pub posts: Option<Box<Vec<Post>>>,
    /// Whether the team is managed by SCIM integration.
    pub scim_managed: Option<bool>,
    /// The SCIM group name for the team.
    pub scim_group_name: Option<String>,
    /// `Internal` The progress history of the team.
    pub progress_history: Option<serde_json::Value>,
    /// `Internal` The current progress of the team.
    pub current_progress: Option<serde_json::Value>,
    /// The workflow state into which issues are moved when a PR has been opened as draft.
    pub draft_workflow_state: Option<Box<WorkflowState>>,
    /// The workflow state into which issues are moved when a PR has been opened.
    pub start_workflow_state: Option<Box<WorkflowState>>,
    /// The workflow state into which issues are moved when a review has been requested for the PR.
    pub review_workflow_state: Option<Box<WorkflowState>>,
    /// The workflow state into which issues are moved when a PR is ready to be merged.
    pub mergeable_workflow_state: Option<Box<WorkflowState>>,
    /// The workflow state into which issues are moved when a PR has been merged.
    pub merge_workflow_state: Option<Box<WorkflowState>>,
    /// Whether to group recent issue history entries.
    pub group_issue_history: Option<bool>,
    /// Whether to enable resolved thread AI summaries.
    pub ai_thread_summaries_enabled: Option<bool>,
    /// Whether to enable AI discussion summaries for issues in this team.
    pub ai_discussion_summaries_enabled: Option<bool>,
    /// Whether to send new issue notifications to Slack.
    pub slack_new_issue: Option<bool>,
    /// Whether to send new issue comment notifications to Slack.
    pub slack_issue_comments: Option<bool>,
    /// Whether to send new issue status updates to Slack.
    pub slack_issue_statuses: Option<bool>,
    /// Period after which issues are automatically closed in months. Null/undefined means disabled.
    pub auto_close_period: Option<f64>,
    /// The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
    pub auto_close_state_id: Option<String>,
    /// Period after which automatically closed and completed issues are automatically archived in months.
    pub auto_archive_period: Option<f64>,
    /// Whether parent issues should automatically close when all child issues are closed
    pub auto_close_parent_issues: Option<bool>,
    /// Whether child issues should automatically close when their parent issue is closed
    pub auto_close_child_issues: Option<bool>,
    /// The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
    pub marked_as_duplicate_workflow_state: Option<Box<WorkflowState>>,
    /// `Internal` Whether new users should join this team by default.
    pub join_by_default: Option<bool>,
    /// Calendar feed URL (iCal) for cycles.
    pub cycle_calender_url: Option<String>,
    /// The name of the team including its parent team name if it has one.
    pub display_name: Option<String>,
    /// Issues associated with the team.
    pub issues: Option<Box<IssueConnection>>,
    /// Number of issues in the team.
    pub issue_count: Option<i64>,
    /// Cycles associated with the team.
    pub cycles: Option<Box<CycleConnection>>,
    /// Team's currently active cycle.
    pub active_cycle: Option<Box<Cycle>>,
    /// Team's triage responsibility.
    pub triage_responsibility: Option<Box<TriageResponsibility>>,
    /// Users who are members of this team.
    pub members: Option<Box<UserConnection>>,
    /// `ALPHA` The membership of the given user in the team.
    pub membership: Option<Box<TeamMembership>>,
    /// Memberships associated with the team. For easier access of the same data, use `members` query.
    pub memberships: Option<Box<TeamMembershipConnection>>,
    /// Projects associated with the team.
    pub projects: Option<Box<ProjectConnection>>,
    /// The states that define the workflow associated with the team.
    pub states: Option<Box<WorkflowStateConnection>>,
    /// The Git automation states for the team.
    pub git_automation_states: Option<Box<GitAutomationStateConnection>>,
    /// Templates associated with the team.
    pub templates: Option<Box<TemplateConnection>>,
    /// Labels associated with the team.
    pub labels: Option<Box<IssueLabelConnection>>,
    /// Webhooks associated with the team.
    pub webhooks: Option<Box<WebhookConnection>>,
    /// Settings for all integrations associated with that team.
    pub integrations_settings: Option<Box<IntegrationsSettings>>,
    /// `DEPRECATED` Whether to move issues to bottom of the column when changing state.
    pub issue_sort_order_default_to_bottom: Option<bool>,
    /// `DEPRECATED` Unique hash for the team to be used in invite URLs.
    pub invite_hash: Option<String>,
}
impl GraphQLFields for Team {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name key description icon color retiredAt cyclesEnabled cycleStartDay cycleDuration cycleCooldownTime cycleIssueAutoAssignStarted cycleIssueAutoAssignCompleted cycleLockToActive upcomingCycleCount timezone inheritWorkflowStatuses inheritIssueEstimation issueEstimationType issueOrderingNoPriorityFirst issueEstimationAllowZero setIssueSortOrderOnStateChange issueEstimationExtended defaultIssueEstimate triageEnabled requirePriorityToLeaveTriage defaultTemplateForMembersId defaultTemplateForNonMembersId private allMembersCanJoin securitySettings scimManaged scimGroupName progressHistory currentProgress groupIssueHistory aiThreadSummariesEnabled aiDiscussionSummariesEnabled slackNewIssue slackIssueComments slackIssueStatuses autoClosePeriod autoCloseStateId autoArchivePeriod autoCloseParentIssues autoCloseChildIssues joinByDefault cycleCalenderUrl displayName issueCount issueSortOrderDefaultToBottom inviteHash"
            .into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<Team>>,
}
impl GraphQLFields for TeamArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamConnection {
    pub edges: Option<Box<Vec<TeamEdge>>>,
    pub nodes: Option<Box<Vec<Team>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for TeamConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamEdge {
    pub node: Option<Box<Team>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for TeamEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// Defines the membership of a user to a team.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamMembership {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that the membership is associated with.
    pub user: Option<Box<User>>,
    /// The team that the membership is associated with.
    pub team: Option<Box<Team>>,
    /// Whether the user is an owner of the team.
    pub owner: Option<bool>,
    /// The order of the item in the users team list.
    pub sort_order: Option<f64>,
}
impl GraphQLFields for TeamMembership {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt owner sortOrder".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamMembershipConnection {
    pub edges: Option<Box<Vec<TeamMembershipEdge>>>,
    pub nodes: Option<Box<Vec<TeamMembership>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for TeamMembershipConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamMembershipEdge {
    pub node: Option<Box<TeamMembership>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for TeamMembershipEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamMembershipPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The team membership that was created or updated.
    pub team_membership: Option<Box<TeamMembership>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for TeamMembershipPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A team notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team subscribed to.
    pub team: Option<Box<Team>>,
    /// The user view associated with the notification subscription.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for TeamNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TeamPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The team that was created or updated.
    pub team: Option<Box<Team>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for TeamPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A template object used for creating entities faster.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Template {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The entity type this template is for.
    pub r#type: Option<String>,
    /// The name of the template.
    pub name: Option<String>,
    /// Template description.
    pub description: Option<String>,
    /// Template data.
    pub template_data: Option<serde_json::Value>,
    /// The sort order of the template.
    pub sort_order: Option<f64>,
    /// The date when the template was last applied.
    pub last_applied_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The organization that the template is associated with. If null, the template is associated with a particular team.
    pub organization: Option<Box<Organization>>,
    /// The team that the template is associated with. If null, the template is global to the workspace.
    pub team: Option<Box<Team>>,
    /// The user who created the template.
    pub creator: Option<Box<User>>,
    /// The user who last updated the template.
    pub last_updated_by: Option<Box<User>>,
    /// The original template inherited from.
    pub inherited_from: Option<Box<Template>>,
    /// `Internal` Whether the template has form fields
    pub has_form_fields: Option<bool>,
}
impl GraphQLFields for Template {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type name description templateData sortOrder lastAppliedAt hasFormFields"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TemplateConnection {
    pub edges: Option<Box<Vec<TemplateEdge>>>,
    pub nodes: Option<Box<Vec<Template>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for TemplateConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TemplateEdge {
    pub node: Option<Box<Template>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for TemplateEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TemplatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The template that was created or updated.
    pub template: Option<Box<Template>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for TemplatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A time schedule.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TimeSchedule {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the schedule.
    pub name: Option<String>,
    /// The schedule entries.
    pub entries: Option<Box<Vec<TimeScheduleEntry>>>,
    /// The identifier of the external schedule.
    pub external_id: Option<String>,
    /// The URL to the external schedule.
    pub external_url: Option<String>,
    /// The organization of the schedule.
    pub organization: Option<Box<Organization>>,
    /// The identifier of the Linear integration populating the schedule.
    pub integration: Option<Box<Integration>>,
}
impl GraphQLFields for TimeSchedule {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name externalId externalUrl".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TimeScheduleConnection {
    pub edges: Option<Box<Vec<TimeScheduleEdge>>>,
    pub nodes: Option<Box<Vec<TimeSchedule>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for TimeScheduleConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TimeScheduleEdge {
    pub node: Option<Box<TimeSchedule>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for TimeScheduleEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TimeScheduleEntry {
    /// The start date of the schedule in ISO 8601 date-time format.
    pub starts_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The end date of the schedule in ISO 8601 date-time format.
    pub ends_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference.
    pub user_id: Option<String>,
    /// The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id.
    pub user_email: Option<String>,
}
impl GraphQLFields for TimeScheduleEntry {
    type FullType = Self;
    fn selection() -> String {
        "startsAt endsAt userId userEmail".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TimeSchedulePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    pub time_schedule: Option<Box<TimeSchedule>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for TimeSchedulePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A team's triage responsibility.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TriageResponsibility {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The action to take when an issue is added to triage.
    pub action: Option<TriageResponsibilityAction>,
    /// Set of users used for triage responsibility.
    pub manual_selection: Option<Box<TriageResponsibilityManualSelection>>,
    /// The team to which the triage responsibility belongs to.
    pub team: Option<Box<Team>>,
    /// The time schedule used for scheduling.
    pub time_schedule: Option<Box<TimeSchedule>>,
    /// The user currently responsible for triage.
    pub current_user: Option<Box<User>>,
}
impl GraphQLFields for TriageResponsibility {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt action".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TriageResponsibilityConnection {
    pub edges: Option<Box<Vec<TriageResponsibilityEdge>>>,
    pub nodes: Option<Box<Vec<TriageResponsibility>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for TriageResponsibilityConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TriageResponsibilityEdge {
    pub node: Option<Box<TriageResponsibility>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for TriageResponsibilityEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TriageResponsibilityManualSelection {
    /// The set of users responsible for triage.
    pub user_ids: Option<Vec<String>>,
    /// `Internal` The index of the current userId used for the assign action when having more than one user.
    pub assignment_index: Option<i64>,
}
impl GraphQLFields for TriageResponsibilityManualSelection {
    type FullType = Self;
    fn selection() -> String {
        "userIds assignmentIndex".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct TriageResponsibilityPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    pub triage_responsibility: Option<Box<TriageResponsibility>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for TriageResponsibilityPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// Object representing Google Cloud upload policy, plus additional data.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UploadFile {
    /// The filename.
    pub filename: Option<String>,
    /// The content type.
    pub content_type: Option<String>,
    /// The size of the uploaded file.
    pub size: Option<i64>,
    /// The signed URL the for the uploaded file. (assigned automatically).
    pub upload_url: Option<String>,
    /// The asset URL for the uploaded file. (assigned automatically).
    pub asset_url: Option<String>,
    pub meta_data: Option<serde_json::Value>,
    pub headers: Option<Box<Vec<UploadFileHeader>>>,
}
impl GraphQLFields for UploadFile {
    type FullType = Self;
    fn selection() -> String {
        "filename contentType size uploadUrl assetUrl metaData".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UploadFileHeader {
    /// Upload file header key.
    pub key: Option<String>,
    /// Upload file header value.
    pub value: Option<String>,
}
impl GraphQLFields for UploadFileHeader {
    type FullType = Self;
    fn selection() -> String {
        "key value".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UploadPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Object describing the file to be uploaded.
    pub upload_file: Option<Box<UploadFile>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for UploadPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// A user that has access to the the resources of an organization.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct User {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user's full name.
    pub name: Option<String>,
    /// The user's display (nick) name. Unique within each organization.
    pub display_name: Option<String>,
    /// The user's email address.
    pub email: Option<String>,
    /// An URL to the user's avatar image.
    pub avatar_url: Option<String>,
    /// Reason why is the account disabled.
    pub disable_reason: Option<String>,
    /// `DEPRECATED` Hash for the user to be used in calendar URLs.
    pub calendar_hash: Option<String>,
    /// A short description of the user, either its title or bio.
    pub description: Option<String>,
    /// The emoji to represent the user current status.
    pub status_emoji: Option<String>,
    /// The label of the user current status.
    pub status_label: Option<String>,
    /// A date at which the user current status should be cleared.
    pub status_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The local timezone of the user.
    pub timezone: Option<String>,
    /// Organization the user belongs to.
    pub organization: Option<Box<Organization>>,
    /// The last time the user was seen online.
    pub last_seen: Option<chrono::DateTime<chrono::Utc>>,
    /// `INTERNAL` Identity provider the user is managed by.
    pub identity_provider: Option<Box<IdentityProvider>>,
    /// The initials of the user.
    pub initials: Option<String>,
    /// The background color of the avatar for users without set avatar.
    pub avatar_background_color: Option<String>,
    /// Whether the user is a guest in the workspace and limited to accessing a subset of teams.
    pub guest: Option<bool>,
    /// Whether the user is an app.
    pub app: Option<bool>,
    /// Whether the user is mentionable.
    pub is_mentionable: Option<bool>,
    /// Whether the user is assignable.
    pub is_assignable: Option<bool>,
    /// Whether the user account is active or disabled (suspended).
    pub active: Option<bool>,
    /// Enabled feature flags for the user.
    pub feature_flags: Option<Vec<String>>,
    /// The user's issue drafts
    pub issue_drafts: Option<Box<IssueDraftConnection>>,
    /// The user's drafts
    pub drafts: Option<Box<DraftConnection>>,
    /// User's profile URL.
    pub url: Option<String>,
    /// Issues assigned to the user.
    pub assigned_issues: Option<Box<IssueConnection>>,
    /// Issues delegated to this user.
    pub delegated_issues: Option<Box<IssueConnection>>,
    /// Issues created by the user.
    pub created_issues: Option<Box<IssueConnection>>,
    /// Number of issues created.
    pub created_issue_count: Option<i64>,
    /// Teams the user is part of.
    pub teams: Option<Box<TeamConnection>>,
    /// Memberships associated with the user. For easier access of the same data, use `teams` query.
    pub team_memberships: Option<Box<TeamMembershipConnection>>,
    /// `INTERNAL` The user's pinned feeds.
    pub feed_facets: Option<Box<FacetConnection>>,
    /// Whether this user can access any public team in the organization.
    pub can_access_any_public_team: Option<bool>,
    /// Whether the user is the currently authenticated user.
    pub is_me: Option<bool>,
    /// Whether the user is an organization administrator.
    pub admin: Option<bool>,
    /// Whether the user is an organization owner.
    pub owner: Option<bool>,
    /// Whether this agent user supports agent sessions.
    pub supports_agent_sessions: Option<bool>,
    /// `DEPRECATED` Unique hash for the user to be used in invite URLs.
    pub invite_hash: Option<String>,
    /// The user's GitHub user ID.
    pub git_hub_user_id: Option<String>,
}
impl GraphQLFields for User {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name displayName email avatarUrl disableReason calendarHash description statusEmoji statusLabel statusUntilAt timezone lastSeen initials avatarBackgroundColor guest app isMentionable isAssignable active url createdIssueCount canAccessAnyPublicTeam isMe admin owner supportsAgentSessions inviteHash gitHubUserId"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserAdminPayload {
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for UserAdminPayload {
    type FullType = Self;
    fn selection() -> String {
        "success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserConnection {
    pub edges: Option<Box<Vec<UserEdge>>>,
    pub nodes: Option<Box<Vec<User>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for UserConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserEdge {
    pub node: Option<Box<User>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for UserEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// A user notification subscription.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserNotificationSubscription {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user that subscribed to receive notifications.
    pub subscriber: Option<Box<User>>,
    /// The customer associated with the notification subscription.
    pub customer: Option<Box<Customer>>,
    /// The contextual custom view associated with the notification subscription.
    pub custom_view: Option<Box<CustomView>>,
    /// The contextual cycle view associated with the notification subscription.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual label view associated with the notification subscription.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual project view associated with the notification subscription.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the notification subscription.
    pub initiative: Option<Box<Initiative>>,
    /// The team associated with the notification subscription.
    pub team: Option<Box<Team>>,
    /// The user subscribed to.
    pub user: Option<Box<User>>,
    /// The type of view to which the notification subscription context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which the notification subscription context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
    /// Whether the subscription is active or not.
    pub active: Option<bool>,
    /// The type of subscription.
    pub notification_subscription_types: Option<Vec<String>>,
}
impl GraphQLFields for UserNotificationSubscription {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt contextViewType userContextViewType active notificationSubscriptionTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The user that was created or updated.
    pub user: Option<Box<User>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for UserPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
/// The settings of a user as a JSON object.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettings {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The notification delivery preferences for the user. Note: notificationDisabled field is deprecated in favor of notificationChannelPreferences.
    pub notification_delivery_preferences: Option<Box<NotificationDeliveryPreferences>>,
    /// The email types the user has unsubscribed from.
    pub unsubscribed_from: Option<Vec<String>>,
    /// The user associated with these settings.
    pub user: Option<Box<User>>,
    /// Hash for the user to be used in calendar URLs.
    pub calendar_hash: Option<String>,
    /// Whether this user is subscribed to changelog email or not.
    pub subscribed_to_changelog: Option<bool>,
    /// Whether this user is subscribed to DPA emails or not.
    pub subscribed_to_dpa: Option<bool>,
    /// Whether this user is subscribed to invite accepted emails or not.
    pub subscribed_to_invite_accepted: Option<bool>,
    /// Whether this user is subscribed to privacy and legal update emails or not.
    pub subscribed_to_privacy_legal_updates: Option<bool>,
    /// The user's feed summary schedule preference.
    pub feed_summary_schedule: Option<FeedSummarySchedule>,
    /// Whether to show full user names instead of display names.
    pub show_full_user_names: Option<bool>,
    /// The user's last seen time for the pulse feed.
    pub feed_last_seen_time: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to auto-assign newly created issues to the current user by default.
    pub auto_assign_to_self: Option<bool>,
    /// The user's notification category preferences.
    pub notification_category_preferences: Option<Box<NotificationCategoryPreferences>>,
    /// The user's notification channel preferences.
    pub notification_channel_preferences: Option<Box<NotificationChannelPreferences>>,
    /// The user's theme for a given mode and device type.
    pub theme: Option<Box<UserSettingsTheme>>,
}
impl GraphQLFields for UserSettings {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt unsubscribedFrom calendarHash subscribedToChangelog subscribedToDPA subscribedToInviteAccepted subscribedToPrivacyLegalUpdates feedSummarySchedule showFullUserNames feedLastSeenTime autoAssignToSelf"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettingsCustomSidebarTheme {
    /// The accent color in LCH format.
    pub accent: Option<Vec<f64>>,
    /// The base color in LCH format.
    pub base: Option<Vec<f64>>,
    /// The contrast value.
    pub contrast: Option<i64>,
}
impl GraphQLFields for UserSettingsCustomSidebarTheme {
    type FullType = Self;
    fn selection() -> String {
        "accent base contrast".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettingsCustomTheme {
    /// The accent color in LCH format.
    pub accent: Option<Vec<f64>>,
    /// The base color in LCH format.
    pub base: Option<Vec<f64>>,
    /// The contrast value.
    pub contrast: Option<i64>,
    /// Optional sidebar theme colors.
    pub sidebar: Option<Box<UserSettingsCustomSidebarTheme>>,
}
impl GraphQLFields for UserSettingsCustomTheme {
    type FullType = Self;
    fn selection() -> String {
        "accent base contrast".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettingsFlagPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The flag key which was updated.
    pub flag: Option<String>,
    /// The flag value after update.
    pub value: Option<i64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for UserSettingsFlagPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId flag value success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettingsFlagsResetPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for UserSettingsFlagsResetPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettingsPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The user's settings.
    pub user_settings: Option<Box<UserSettings>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for UserSettingsPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct UserSettingsTheme {
    /// The theme preset.
    pub preset: Option<UserSettingsThemePreset>,
    /// The custom theme definition, only present when preset is 'custom'.
    pub custom: Option<Box<UserSettingsCustomTheme>>,
}
impl GraphQLFields for UserSettingsTheme {
    type FullType = Self;
    fn selection() -> String {
        "preset".into()
    }
}
/// View preferences.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ViewPreferences {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The view preference type.
    pub r#type: Option<String>,
    /// The view type.
    pub view_type: Option<String>,
    /// The view preferences
    pub preferences: Option<Box<ViewPreferencesValues>>,
}
impl GraphQLFields for ViewPreferences {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type viewType".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ViewPreferencesPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The view preferences entity being mutated.
    pub view_preferences: Option<Box<ViewPreferences>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for ViewPreferencesPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct ViewPreferencesValues {
    /// The issue ordering.
    pub view_ordering: Option<String>,
    /// The issue grouping.
    pub issue_grouping: Option<String>,
    /// The issue sub grouping.
    pub issue_sub_grouping: Option<String>,
    /// Whether to show completed issues.
    pub show_completed_issues: Option<String>,
}
impl GraphQLFields for ViewPreferencesValues {
    type FullType = Self;
    fn selection() -> String {
        "viewOrdering issueGrouping issueSubGrouping showCompletedIssues".into()
    }
}
/// A webhook used to send HTTP notifications over data updates.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct Webhook {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Webhook label.
    pub label: Option<String>,
    /// Webhook URL.
    pub url: Option<String>,
    /// Whether the Webhook is enabled.
    pub enabled: Option<bool>,
    /// The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization or multiple teams.
    pub team: Option<Box<Team>>,
    /// `INTERNAL` The teams that the webhook is associated with. Used to represent a webhook that targets multiple teams, potentially in addition to all public teams of the organization.
    pub team_ids: Option<Vec<String>>,
    /// Whether the Webhook is enabled for all public teams, including teams created after the webhook was created.
    pub all_public_teams: Option<bool>,
    /// The user who created the webhook.
    pub creator: Option<Box<User>>,
    /// Secret token for verifying the origin on the recipient side.
    pub secret: Option<String>,
    /// The resource types this webhook is subscribed to.
    pub resource_types: Option<Vec<String>>,
    /// `INTERNAL` Webhook failure events associated with the webhook (last 50).
    pub failures: Option<Box<Vec<WebhookFailureEvent>>>,
}
impl GraphQLFields for Webhook {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt label url enabled teamIds allPublicTeams secret resourceTypes"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WebhookConnection {
    pub edges: Option<Box<Vec<WebhookEdge>>>,
    pub nodes: Option<Box<Vec<Webhook>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for WebhookConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WebhookEdge {
    pub node: Option<Box<Webhook>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for WebhookEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
/// Entity representing a webhook execution failure.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WebhookFailureEvent {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The webhook that this failure event is associated with.
    pub webhook: Option<Box<Webhook>>,
    /// The URL that the webhook was trying to push to.
    pub url: Option<String>,
    /// The HTTP status code returned by the recipient.
    pub http_status: Option<f64>,
    /// The HTTP response body returned by the recipient or error occured.
    pub response_or_error: Option<String>,
    /// The unique execution ID of the webhook push. This is retained between retries of the same push.
    pub execution_id: Option<String>,
}
impl GraphQLFields for WebhookFailureEvent {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt url httpStatus responseOrError executionId".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WebhookPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The webhook entity being mutated.
    pub webhook: Option<Box<Webhook>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for WebhookPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WebhookRotateSecretPayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The new webhook signing secret.
    pub secret: Option<String>,
}
impl GraphQLFields for WebhookRotateSecretPayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success secret".into()
    }
}
/// A welcome message for new users joining the workspace.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WelcomeMessage {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The title of the welcome message notification.
    pub title: Option<String>,
    /// Whether the welcome message is enabled.
    pub enabled: Option<bool>,
    /// The user who last updated the welcome message.
    pub updated_by: Option<Box<User>>,
}
impl GraphQLFields for WelcomeMessage {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt title enabled".into()
    }
}
/// A welcome message related notification.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WelcomeMessageNotification {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Notification type.
    pub r#type: Option<String>,
    /// The user that caused the notification.
    pub actor: Option<Box<User>>,
    /// The external user that caused the notification.
    pub external_user_actor: Option<Box<ExternalUser>>,
    /// The user that received the notification.
    pub user: Option<Box<User>>,
    /// The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
    pub read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at when an email reminder for this notification was sent to the user. Null, if no email
    /// reminder has been sent.
    pub emailed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time until a notification will be snoozed. After that it will appear in the inbox again.
    pub snoozed_until_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which a notification was unsnoozed..
    pub unsnoozed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The category of the notification.
    pub category: Option<NotificationCategory>,
    /// `Internal` URL to the target of the notification.
    pub url: Option<String>,
    /// `Internal` Inbox URL for the notification.
    pub inbox_url: Option<String>,
    /// `Internal` Notification title.
    pub title: Option<String>,
    /// `Internal` Notification subtitle.
    pub subtitle: Option<String>,
    /// `Internal` If notification actor was Linear.
    pub is_linear_actor: Option<bool>,
    /// `Internal` Notification avatar URL.
    pub actor_avatar_url: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_initials: Option<String>,
    /// `Internal` Notification actor initials if avatar is not available.
    pub actor_avatar_color: Option<String>,
    /// `Internal` Issue's status type for issue notifications.
    pub issue_status_type: Option<String>,
    /// `Internal` Project update health for new updates.
    pub project_update_health: Option<String>,
    /// `Internal` Initiative update health for new updates.
    pub initiative_update_health: Option<String>,
    /// `Internal` Notifications with the same grouping key will be grouped together in the UI.
    pub grouping_key: Option<String>,
    /// `Internal` Priority of the notification with the same grouping key. Higher number means higher priority. If priority is the same, notifications should be sorted by `createdAt`.
    pub grouping_priority: Option<f64>,
    /// The bot that caused the notification.
    pub bot_actor: Option<Box<ActorBot>>,
    /// Related welcome message.
    pub welcome_message_id: Option<String>,
}
impl GraphQLFields for WelcomeMessageNotification {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt type readAt emailedAt snoozedUntilAt unsnoozedAt category url inboxUrl title subtitle isLinearActor actorAvatarUrl actorInitials actorAvatarColor issueStatusType projectUpdateHealth initiativeUpdateHealth groupingKey groupingPriority welcomeMessageId"
            .into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WorkflowDefinition {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the workflow.
    pub name: Option<String>,
    /// The name of the group that the workflow belongs to.
    pub group_name: Option<String>,
    /// The description of the workflow.
    pub description: Option<String>,
    /// The type of the workflow.
    pub r#type: Option<WorkflowType>,
    /// The type of the event that triggers off the workflow.
    pub trigger: Option<WorkflowTrigger>,
    /// The object type (e.g. Issue) that triggers this workflow.
    pub trigger_type: Option<WorkflowTriggerType>,
    /// The conditions that need to be match for the workflow to be triggered.
    pub conditions: Option<serde_json::Value>,
    pub enabled: Option<bool>,
    /// The team associated with the workflow. If not set, the workflow is associated with the entire organization.
    pub team: Option<Box<Team>>,
    /// The user who created the workflow.
    pub creator: Option<Box<User>>,
    /// An array of activities that will be executed as part of the workflow.
    pub activities: Option<serde_json::Value>,
    /// The sort order of the workflow definition within its siblings.
    pub sort_order: Option<String>,
    /// The date when the workflow was last executed.
    pub last_executed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The user who last updated the workflow.
    pub last_updated_by: Option<Box<User>>,
    /// The contextual label view associated with the workflow.
    pub label: Option<Box<IssueLabel>>,
    /// The contextual cycle view associated with the workflow.
    pub cycle: Option<Box<Cycle>>,
    /// The contextual user view associated with the workflow.
    pub user: Option<Box<User>>,
    /// The contextual project view associated with the workflow.
    pub project: Option<Box<Project>>,
    /// The contextual initiative view associated with the workflow.
    pub initiative: Option<Box<Initiative>>,
    /// The context custom view associated with the workflow.
    pub custom_view: Option<Box<CustomView>>,
    /// The type of view to which this workflow's context is associated with.
    pub context_view_type: Option<ContextViewType>,
    /// The type of user view to which this workflow's context is associated with.
    pub user_context_view_type: Option<UserContextViewType>,
}
impl GraphQLFields for WorkflowDefinition {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name groupName description type trigger triggerType conditions enabled activities sortOrder lastExecutedAt contextViewType userContextViewType"
            .into()
    }
}
/// A state in a team workflow.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WorkflowState {
    /// The unique identifier of the entity.
    pub id: Option<String>,
    /// The time at which the entity was created.
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
    /// been updated after creation.
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time at which the entity was archived. Null if the entity has not been archived.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The state's name.
    pub name: Option<String>,
    /// The state's UI color as a HEX string.
    pub color: Option<String>,
    /// Description of the state.
    pub description: Option<String>,
    /// The position of the state in the team flow.
    pub position: Option<f64>,
    /// The type of the state. One of "triage", "backlog", "unstarted", "started", "completed", "canceled".
    pub r#type: Option<String>,
    /// The team to which this state belongs to.
    pub team: Option<Box<Team>>,
    /// The state inherited from
    pub inherited_from: Option<Box<WorkflowState>>,
    /// Issues belonging in this state.
    pub issues: Option<Box<IssueConnection>>,
}
impl GraphQLFields for WorkflowState {
    type FullType = Self;
    fn selection() -> String {
        "id createdAt updatedAt archivedAt name color description position type".into()
    }
}
/// A generic payload return from entity archive mutations.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WorkflowStateArchivePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
    /// The archived/unarchived entity. Null if entity was deleted.
    pub entity: Option<Box<WorkflowState>>,
}
impl GraphQLFields for WorkflowStateArchivePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WorkflowStateConnection {
    pub edges: Option<Box<Vec<WorkflowStateEdge>>>,
    pub nodes: Option<Box<Vec<WorkflowState>>>,
    pub page_info: Option<Box<PageInfo>>,
}
impl GraphQLFields for WorkflowStateConnection {
    type FullType = Self;
    fn selection() -> String {
        "".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WorkflowStateEdge {
    pub node: Option<Box<WorkflowState>>,
    /// Used in `before` and `after` args
    pub cursor: Option<String>,
}
impl GraphQLFields for WorkflowStateEdge {
    type FullType = Self;
    fn selection() -> String {
        "cursor".into()
    }
}
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", default)]
pub struct WorkflowStatePayload {
    /// The identifier of the last sync operation.
    pub last_sync_id: Option<f64>,
    /// The state that was created or updated.
    pub workflow_state: Option<Box<WorkflowState>>,
    /// Whether the operation was successful.
    pub success: Option<bool>,
}
impl GraphQLFields for WorkflowStatePayload {
    type FullType = Self;
    fn selection() -> String {
        "lastSyncId success".into()
    }
}
