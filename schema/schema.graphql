input ActivityCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  user: UserFilter
  and: [ActivityCollectionFilter!]
  or: [ActivityCollectionFilter!]
  some: ActivityFilter
  every: ActivityFilter
  length: NumberComparator
}

input ActivityFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  user: UserFilter
  and: [ActivityFilter!]
  or: [ActivityFilter!]
}

type ActorBot {
  id: ID
  type: String!
  subType: String
  name: String
  userDisplayName: String
  avatarUrl: String
}

type AgentActivity implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  agentSession: AgentSession!
  content: AgentActivityContent!
  sourceComment: Comment
  user: User!
  sourceMetadata: JSON
  signal: AgentActivitySignal
  signalMetadata: JSON
  ephemeral: Boolean!
  contextualMetadata: JSON
}

type AgentActivityActionContent {
  type: AgentActivityType!
  action: String!
  parameter: String!
  result: String
  resultData: JSONObject
}

type AgentActivityConnection {
  edges: [AgentActivityEdge!]!
  nodes: [AgentActivity!]!
  pageInfo: PageInfo!
}

union AgentActivityContent = AgentActivityThoughtContent | AgentActivityActionContent | AgentActivityResponseContent | AgentActivityPromptContent | AgentActivityErrorContent | AgentActivityElicitationContent

input AgentActivityCreateInput {
  id: String
  agentSessionId: String!
  signal: AgentActivitySignal
  signalMetadata: JSONObject
  contextualMetadata: JSONObject
  content: JSONObject!
  ephemeral: Boolean
}

input AgentActivityCreatePromptInput {
  id: String
  agentSessionId: String!
  signal: AgentActivitySignal
  signalMetadata: JSONObject
  contextualMetadata: JSONObject
  content: AgentActivityPromptCreateInputContent!
  sourceCommentId: String
}

type AgentActivityEdge {
  node: AgentActivity!
  cursor: String!
}

type AgentActivityElicitationContent {
  type: AgentActivityType!
  body: String!
  bodyData: JSONObject!
}

type AgentActivityErrorContent {
  type: AgentActivityType!
  body: String!
  bodyData: JSONObject!
}

input AgentActivityFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  agentSessionId: StringComparator
  type: StringComparator
  sourceComment: NullableCommentFilter
  and: [AgentActivityFilter!]
  or: [AgentActivityFilter!]
}

type AgentActivityPayload {
  lastSyncId: Float!
  agentActivity: AgentActivity!
  success: Boolean!
}

type AgentActivityPromptContent {
  type: AgentActivityType!
  body: String!
  bodyData: JSONObject!
}

input AgentActivityPromptCreateInputContent {
  type: AgentActivityType! = prompt
  body: String
  bodyData: JSONObject
}

type AgentActivityResponseContent {
  type: AgentActivityType!
  body: String!
  bodyData: JSONObject!
}

enum AgentActivitySignal {
  stop
  continue
  auth
  select
}

type AgentActivityThoughtContent {
  type: AgentActivityType!
  body: String!
  bodyData: JSONObject!
}

enum AgentActivityType {
  thought
  action
  response
  elicitation
  error
  prompt
}

type AgentSession implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  creator: User
  appUser: User!
  comment: Comment
  sourceComment: Comment
  issue: Issue
  status: AgentSessionStatus!
  startedAt: DateTime
  endedAt: DateTime
  dismissedAt: DateTime
  dismissedBy: User
  activities(filter: AgentActivityFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AgentActivityConnection!
  externalLink: String
  summary: String
  sourceMetadata: JSON
  plan: JSON
  context: JSON!
  type: AgentSessionType
  url: String
  pullRequests(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AgentSessionToPullRequestConnection!
  externalLinks: [AgentSessionExternalLink!]!
  externalUrls: JSON!
}

type AgentSessionConnection {
  edges: [AgentSessionEdge!]!
  nodes: [AgentSession!]!
  pageInfo: PageInfo!
}

input AgentSessionCreateInput {
  id: String
  issueId: String
  appUserId: String!
  context: JSONObject
}

input AgentSessionCreateOnComment {
  commentId: String!
  externalLink: String
  externalUrls: [AgentSessionExternalUrlInput!]
}

input AgentSessionCreateOnIssue {
  issueId: String!
  externalLink: String
  externalUrls: [AgentSessionExternalUrlInput!]
}

type AgentSessionEdge {
  node: AgentSession!
  cursor: String!
}

type AgentSessionExternalLink {
  url: String!
  label: String!
}

input AgentSessionExternalUrlInput {
  url: String!
  label: String!
}

type AgentSessionPayload {
  lastSyncId: Float!
  success: Boolean!
  agentSession: AgentSession!
}

enum AgentSessionStatus {
  pending
  active
  complete
  awaitingInput
  error
  stale
}

type AgentSessionToPullRequest implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  pullRequest: PullRequest!
  agentSession: AgentSession!
}

type AgentSessionToPullRequestConnection {
  edges: [AgentSessionToPullRequestEdge!]!
  nodes: [AgentSessionToPullRequest!]!
  pageInfo: PageInfo!
}

type AgentSessionToPullRequestEdge {
  node: AgentSessionToPullRequest!
  cursor: String!
}

enum AgentSessionType {
  commentThread
}

input AgentSessionUpdateExternalUrlInput {
  externalLink: String
  externalUrls: [AgentSessionExternalUrlInput!]
  addedExternalUrls: [AgentSessionExternalUrlInput!]
  removedExternalUrls: [String!]
}

input AgentSessionUpdateInput {
  externalLink: String
  externalUrls: [AgentSessionExternalUrlInput!]
  addedExternalUrls: [AgentSessionExternalUrlInput!]
  removedExternalUrls: [String!]
  plan: JSONObject
  dismissedAt: DateTime
  userState: [AgentSessionUserStateInput!]
}

input AgentSessionUserStateInput {
  userId: String!
  lastReadAt: DateTime
}

type AiPromptRules implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  updatedBy: User
}

input AirbyteConfigurationInput {
  apiKey: String!
}

type Application {
  id: String!
  clientId: String!
  name: String!
  description: String
  developer: String!
  developerUrl: String!
  imageUrl: String
}

input ApproximateNeedCountSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

interface ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
}

type ArchiveResponse {
  archive: String!
  totalCount: Float!
  databaseVersion: Float!
  includesDependencies: [String!]!
}

type AsksChannelConnectPayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
  mapping: SlackChannelNameMapping!
  addBot: Boolean!
}

type AsksWebPage implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  organization: Organization!
  asksWebSettings: AsksWebSettings!
  creator: User
  title: String!
  description: String
  slugId: String!
  issueCreatedAutoReply: String
  issueCreatedAutoReplyEnabled: Boolean!
  issueCompletedAutoReply: String
  issueCompletedAutoReplyEnabled: Boolean!
  issueCanceledAutoReply: String
  issueCanceledAutoReplyEnabled: Boolean!
}

input AsksWebPageCreateInput {
  id: String
  asksWebSettingsId: String!
  title: String!
  description: String
  issueCreatedAutoReply: String
  issueCreatedAutoReplyEnabled: Boolean
  issueCompletedAutoReply: String
  issueCompletedAutoReplyEnabled: Boolean
  issueCanceledAutoReply: String
  issueCanceledAutoReplyEnabled: Boolean
}

type AsksWebPagePayload {
  lastSyncId: Float!
  asksWebPage: AsksWebPage!
  success: Boolean!
}

input AsksWebPageUpdateInput {
  title: String
  description: String
  issueCreatedAutoReply: String
  issueCreatedAutoReplyEnabled: Boolean
  issueCompletedAutoReply: String
  issueCompletedAutoReplyEnabled: Boolean
  issueCanceledAutoReply: String
  issueCanceledAutoReplyEnabled: Boolean
}

type AsksWebSettings implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  organization: Organization!
  creator: User
  domain: String
  emailIntakeAddress: EmailIntakeAddress
  identityProvider: IdentityProvider
}

input AsksWebSettingsCreateInput {
  id: String
  domain: String
}

input AsksWebSettingsEmailIntakeAddressInput {
  senderName: String
  forwardingEmailAddress: String
}

type AsksWebSettingsPayload {
  lastSyncId: Float!
  asksWebSettings: AsksWebSettings!
  success: Boolean!
}

input AsksWebSettingsUpdateInput {
  domain: String
}

input AssigneeSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type Attachment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  title: String!
  subtitle: String
  url: String!
  creator: User
  externalUserCreator: ExternalUser
  metadata: JSONObject!
  source: JSONObject
  sourceType: String
  groupBySource: Boolean!
  originalIssue: Issue
  issue: Issue!
  bodyData: String
}

input AttachmentCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  title: StringComparator
  subtitle: NullableStringComparator
  url: StringComparator
  creator: NullableUserFilter
  sourceType: SourceTypeComparator
  and: [AttachmentCollectionFilter!]
  or: [AttachmentCollectionFilter!]
  some: AttachmentFilter
  every: AttachmentFilter
  length: NumberComparator
}

type AttachmentConnection {
  edges: [AttachmentEdge!]!
  nodes: [Attachment!]!
  pageInfo: PageInfo!
}

input AttachmentCreateInput {
  id: String
  title: String!
  subtitle: String
  url: String!
  issueId: String!
  iconUrl: String
  metadata: JSONObject
  groupBySource: Boolean
  commentBody: String
  commentBodyData: JSONObject
  createAsUser: String
}

type AttachmentEdge {
  node: Attachment!
  cursor: String!
}

input AttachmentFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  title: StringComparator
  subtitle: NullableStringComparator
  url: StringComparator
  creator: NullableUserFilter
  sourceType: SourceTypeComparator
  and: [AttachmentFilter!]
  or: [AttachmentFilter!]
}

type AttachmentPayload {
  lastSyncId: Float!
  attachment: Attachment!
  success: Boolean!
}

type AttachmentSourcesPayload {
  sources: JSONObject!
}

input AttachmentUpdateInput {
  title: String!
  subtitle: String
  metadata: JSONObject
  iconUrl: String
}

type AuditEntry implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  organization: Organization
  actor: User
  actorId: String
  ip: String
  countryCode: String
  metadata: JSONObject
  requestInformation: JSONObject
}

type AuditEntryConnection {
  edges: [AuditEntryEdge!]!
  nodes: [AuditEntry!]!
  pageInfo: PageInfo!
}

type AuditEntryEdge {
  node: AuditEntry!
  cursor: String!
}

input AuditEntryFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  type: StringComparator
  ip: StringComparator
  countryCode: StringComparator
  actor: NullableUserFilter
  and: [AuditEntryFilter!]
  or: [AuditEntryFilter!]
}

type AuditEntryType {
  type: String!
  description: String!
}

type AuthIdentityProvider {
  createdAt: DateTime!
  id: ID!
  defaultMigrated: Boolean!
  type: IdentityProviderType!
  samlEnabled: Boolean!
  ssoEndpoint: String
  ssoBinding: String
  ssoSignAlgo: String
  issuerEntityId: String
  spEntityId: String
  ssoSigningCert: String
  priority: Float
  scimEnabled: Boolean!
}

type AuthOrganization {
  createdAt: DateTime!
  id: ID!
  name: String!
  enabled: Boolean!
  urlKey: String!
  previousUrlKeys: [String!]!
  logoUrl: String
  deletionRequestedAt: DateTime
  releaseChannel: ReleaseChannel!
  samlEnabled: Boolean!
  samlSettings: JSONObject
  allowedAuthServices: [String!]!
  scimEnabled: Boolean!
  serviceId: String!
  region: String!
  hideNonPrimaryOrganizations: Boolean!
  userCount: Float
}

type AuthResolverResponse {
  id: String!
  email: String!
  allowDomainAccess: Boolean
  users: [AuthUser!]!
  lockedUsers: [AuthUser!]!
  availableOrganizations: [AuthOrganization!]
  lockedOrganizations: [AuthOrganization!]
  lastUsedOrganizationId: String
  service: String
  token: String
}

type AuthUser {
  createdAt: DateTime!
  id: ID!
  name: String!
  displayName: String!
  email: String!
  avatarUrl: String
  role: UserRoleType!
  active: Boolean!
  userAccountId: String!
  organization: AuthOrganization!
  identityProvider: AuthIdentityProvider
}

type AuthenticationSessionResponse {
  createdAt: DateTime!
  id: String!
  type: AuthenticationSessionType!
  ip: String
  locationCountry: String
  locationCountryCode: String
  countryCodes: [String!]!
  locationRegionCode: String
  locationCity: String
  userAgent: String
  browserType: String
  service: String
  lastActiveAt: DateTime
  updatedAt: DateTime!
  location: String
  operatingSystem: String
  client: String
  name: String!
  isCurrentSession: Boolean!
}

enum AuthenticationSessionType {
  web
  desktop
  ios
  android
}

scalar Boolean

input BooleanComparator {
  eq: Boolean
  neq: Boolean
}

input CandidateRepository {
  repositoryFullName: String!
  hostname: String!
}

type Comment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  body: String!
  issue: Issue
  issueId: String
  documentContent: DocumentContent
  documentContentId: String
  projectUpdate: ProjectUpdate
  projectUpdateId: String
  initiativeUpdate: InitiativeUpdate
  initiativeUpdateId: String
  post: Post
  parent: Comment
  parentId: String
  resolvingUser: User
  resolvedAt: DateTime
  resolvingComment: Comment
  resolvingCommentId: String
  user: User
  externalUser: ExternalUser
  editedAt: DateTime
  bodyData: String!
  quotedText: String
  reactionData: JSONObject!
  threadSummary: JSONObject
  isArtificialAgentSessionRoot: Boolean!
  url: String!
  children(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  agentSession: AgentSession
  agentSessions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AgentSessionConnection!
  createdIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  botActor: ActorBot
  externalThread: SyncedExternalThread
  hideInLinear: Boolean!
  reactions: [Reaction!]!
  syncedWith: [ExternalEntityInfo!]
}

input CommentCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  body: StringComparator
  user: UserFilter
  issue: NullableIssueFilter
  projectUpdate: NullableProjectUpdateFilter
  parent: NullableCommentFilter
  documentContent: NullableDocumentContentFilter
  reactions: ReactionCollectionFilter
  needs: CustomerNeedCollectionFilter
  and: [CommentCollectionFilter!]
  or: [CommentCollectionFilter!]
  some: CommentFilter
  every: CommentFilter
  length: NumberComparator
}

type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
}

input CommentCreateInput {
  id: String
  body: String
  bodyData: JSON
  issueId: String
  projectUpdateId: String
  initiativeUpdateId: String
  postId: String
  documentContentId: String
  parentId: String
  createAsUser: String
  displayIconUrl: String
  createdAt: DateTime
  doNotSubscribeToIssue: Boolean
  createOnSyncedSlackThread: Boolean
  quotedText: String
  subscriberIds: [String!]
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

input CommentFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  body: StringComparator
  user: UserFilter
  issue: NullableIssueFilter
  projectUpdate: NullableProjectUpdateFilter
  parent: NullableCommentFilter
  documentContent: NullableDocumentContentFilter
  reactions: ReactionCollectionFilter
  needs: CustomerNeedCollectionFilter
  and: [CommentFilter!]
  or: [CommentFilter!]
}

type CommentPayload {
  lastSyncId: Float!
  comment: Comment!
  success: Boolean!
}

input CommentUpdateInput {
  body: String
  bodyData: JSON
  resolvingUserId: String
  resolvingCommentId: String
  quotedText: String
  subscriberIds: [String!]
  doNotSubscribeToIssue: Boolean
}

input CompletedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input ContactCreateInput {
  type: String!
  message: String!
  operatingSystem: String
  browser: String
  device: String
  clientVersion: String
  disappointmentRating: Int
}

type ContactPayload {
  success: Boolean!
}

input ContactSalesCreateInput {
  name: String!
  email: String!
  companySize: String
  message: String
  url: String
  distinctId: String
  sessionId: String
}

input ContentComparator {
  contains: String
  notContains: String
}

enum ContextViewType {
  activeIssues
  activeCycle
  upcomingCycle
  backlog
  triage
}

type CreateCsvExportReportPayload {
  success: Boolean!
}

type CreateOrJoinOrganizationResponse {
  organization: AuthOrganization!
  user: AuthUser!
}

input CreateOrganizationInput {
  name: String!
  urlKey: String!
  domainAccess: Boolean
  timezone: String
  utm: String
}

input CreatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type CustomView implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  description: String
  icon: String
  color: String
  organization: Organization!
  creator: User!
  owner: User!
  updatedBy: User
  filters: JSONObject!
  filterData: JSONObject!
  projectFilterData: JSONObject
  initiativeFilterData: JSONObject
  feedItemFilterData: JSONObject
  shared: Boolean!
  slugId: String!
  modelName: String!
  facet: Facet
  team: Team
  projects(includeSubTeams: Boolean = true, filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [ProjectSortInput!]): ProjectConnection!
  issues(includeSubTeams: Boolean = false, filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [IssueSortInput!]): IssueConnection!
  updates(includeSubTeams: Boolean = false, filter: FeedItemFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): FeedItemConnection!
  userViewPreferences: ViewPreferences
  organizationViewPreferences: ViewPreferences
  viewPreferencesValues: ViewPreferencesValues
  initiatives(filter: InitiativeFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeConnection!
}

type CustomViewConnection {
  edges: [CustomViewEdge!]!
  nodes: [CustomView!]!
  pageInfo: PageInfo!
}

input CustomViewCreateInput {
  id: String
  name: String!
  description: String
  icon: String
  color: String
  teamId: String
  projectId: String
  initiativeId: String
  ownerId: String
  filterData: IssueFilter
  projectFilterData: ProjectFilter
  initiativeFilterData: InitiativeFilter
  feedItemFilterData: FeedItemFilter
  shared: Boolean
}

input CustomViewCreatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type CustomViewEdge {
  node: CustomView!
  cursor: String!
}

input CustomViewFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  modelName: StringComparator
  team: NullableTeamFilter
  creator: UserFilter
  shared: BooleanComparator
  hasFacet: Boolean
  and: [CustomViewFilter!]
  or: [CustomViewFilter!]
}

type CustomViewHasSubscribersPayload {
  hasSubscribers: Boolean!
}

input CustomViewNameSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type CustomViewNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView!
  cycle: Cycle
  label: IssueLabel
  project: Project
  initiative: Initiative
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

type CustomViewPayload {
  lastSyncId: Float!
  customView: CustomView!
  success: Boolean!
}

input CustomViewSharedSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input CustomViewSortInput {
  name: CustomViewNameSort
  createdAt: CustomViewCreatedAtSort
  shared: CustomViewSharedSort
  updatedAt: CustomViewUpdatedAtSort
}

type CustomViewSuggestionPayload {
  name: String
  description: String
  icon: String
}

input CustomViewUpdateInput {
  name: String
  description: String
  icon: String
  color: String
  teamId: String
  projectId: String
  initiativeId: String
  ownerId: String
  filterData: IssueFilter
  projectFilterData: ProjectFilter
  initiativeFilterData: InitiativeFilter
  feedItemFilterData: FeedItemFilter
  shared: Boolean
}

input CustomViewUpdatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type Customer implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  logoUrl: String
  domains: [String!]!
  externalIds: [String!]!
  slackChannelId: String
  owner: User
  status: CustomerStatus!
  revenue: Int
  size: Float
  tier: CustomerTier
  approximateNeedCount: Float!
  slugId: String!
  mainSourceId: String
  integration: Integration
  url: String!
}

type CustomerConnection {
  edges: [CustomerEdge!]!
  nodes: [Customer!]!
  pageInfo: PageInfo!
}

input CustomerCountSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input CustomerCreateInput {
  id: String
  name: String!
  domains: [String!] = []
  externalIds: [String!] = []
  slackChannelId: String
  ownerId: String
  statusId: String
  revenue: Int
  size: Int
  tierId: String
  logoUrl: String
  mainSourceId: String
}

input CustomerCreatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

input CustomerFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slackChannelId: StringComparator
  domains: StringArrayComparator
  externalIds: StringArrayComparator
  owner: NullableUserFilter
  needs: CustomerNeedCollectionFilter
  revenue: NumberComparator
  size: NumberComparator
  status: CustomerStatusFilter
  tier: CustomerTierFilter
  and: [CustomerFilter!]
  or: [CustomerFilter!]
}

input CustomerImportantCountSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type CustomerNeed implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  customer: Customer
  issue: Issue
  project: Project
  comment: Comment
  attachment: Attachment
  projectAttachment: ProjectAttachment
  priority: Float!
  body: String
  bodyData: String
  creator: User
  originalIssue: Issue
  url: String
}

type CustomerNeedArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: CustomerNeed
}

input CustomerNeedCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  priority: NumberComparator
  project: NullableProjectFilter
  issue: NullableIssueFilter
  comment: NullableCommentFilter
  customer: NullableCustomerFilter
  and: [CustomerNeedCollectionFilter!]
  or: [CustomerNeedCollectionFilter!]
  some: CustomerNeedFilter
  every: CustomerNeedFilter
  length: NumberComparator
}

type CustomerNeedConnection {
  edges: [CustomerNeedEdge!]!
  nodes: [CustomerNeed!]!
  pageInfo: PageInfo!
}

input CustomerNeedCreateFromAttachmentInput {
  attachmentId: String!
}

input CustomerNeedCreateInput {
  id: String
  customerId: String
  customerExternalId: String
  issueId: String
  projectId: String
  commentId: String
  attachmentId: String
  priority: Float
  body: String
  bodyData: JSON
  attachmentUrl: String
  createAsUser: String
  displayIconUrl: String
}

type CustomerNeedEdge {
  node: CustomerNeed!
  cursor: String!
}

input CustomerNeedFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  priority: NumberComparator
  project: NullableProjectFilter
  issue: NullableIssueFilter
  comment: NullableCommentFilter
  customer: NullableCustomerFilter
  and: [CustomerNeedFilter!]
  or: [CustomerNeedFilter!]
}

type CustomerNeedNotification implements Notification & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  customerNeedId: String!
  relatedIssue: Issue
  relatedProject: Project
  customerNeed: CustomerNeed!
}

type CustomerNeedPayload {
  lastSyncId: Float!
  need: CustomerNeed!
  success: Boolean!
}

input CustomerNeedUpdateInput {
  id: String
  customerId: String
  customerExternalId: String
  issueId: String
  projectId: String
  priority: Float
  applyPriorityToRelatedNeeds: Boolean
  body: String
  bodyData: JSON
  attachmentUrl: String
}

type CustomerNeedUpdatePayload {
  lastSyncId: Float!
  need: CustomerNeed!
  success: Boolean!
  updatedRelatedNeeds: [CustomerNeed!]!
}

type CustomerNotification implements Notification & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  customerId: String!
  customer: Customer!
}

type CustomerNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer!
  customView: CustomView
  cycle: Cycle
  label: IssueLabel
  project: Project
  initiative: Initiative
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

type CustomerPayload {
  lastSyncId: Float!
  customer: Customer!
  success: Boolean!
}

input CustomerRevenueSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input CustomerSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input CustomerSortInput {
  name: NameSort
  createdAt: CustomerCreatedAtSort
  owner: OwnerSort
  status: CustomerStatusSort
  revenue: RevenueSort
  size: SizeSort
  tier: TierSort
  approximateNeedCount: ApproximateNeedCountSort
}

type CustomerStatus implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  color: String!
  description: String
  position: Float!
  displayName: String!
  type: CustomerStatusType
}

type CustomerStatusConnection {
  edges: [CustomerStatusEdge!]!
  nodes: [CustomerStatus!]!
  pageInfo: PageInfo!
}

input CustomerStatusCreateInput {
  id: String
  name: String
  color: String!
  description: String
  position: Float
  displayName: String
}

type CustomerStatusEdge {
  node: CustomerStatus!
  cursor: String!
}

input CustomerStatusFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  description: StringComparator
  position: NumberComparator
  type: StringComparator
  color: StringComparator
  and: [CustomerStatusFilter!]
  or: [CustomerStatusFilter!]
}

type CustomerStatusPayload {
  lastSyncId: Float!
  status: CustomerStatus!
  success: Boolean!
}

input CustomerStatusSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

enum CustomerStatusType {
  active
  inactive
}

input CustomerStatusUpdateInput {
  name: String
  color: String
  description: String
  position: Float
  displayName: String
}

type CustomerTier implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  color: String!
  description: String
  position: Float!
  displayName: String!
}

type CustomerTierConnection {
  edges: [CustomerTierEdge!]!
  nodes: [CustomerTier!]!
  pageInfo: PageInfo!
}

input CustomerTierCreateInput {
  id: String
  name: String
  color: String!
  description: String
  position: Float
  displayName: String
}

type CustomerTierEdge {
  node: CustomerTier!
  cursor: String!
}

input CustomerTierFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  displayName: StringComparator
  description: StringComparator
  position: NumberComparator
  color: StringComparator
  and: [CustomerTierFilter!]
  or: [CustomerTierFilter!]
}

type CustomerTierPayload {
  lastSyncId: Float!
  tier: CustomerTier!
  success: Boolean!
}

input CustomerTierUpdateInput {
  name: String
  color: String
  description: String
  position: Float
  displayName: String
}

input CustomerUpdateInput {
  name: String
  domains: [String!]
  externalIds: [String!]
  slackChannelId: String
  ownerId: String
  statusId: String
  revenue: Int
  size: Int
  tierId: String
  logoUrl: String
  mainSourceId: String
}

input CustomerUpsertInput {
  id: String
  name: String
  domains: [String!]
  externalId: String
  slackChannelId: String
  ownerId: String
  statusId: String
  revenue: Int
  size: Int
  tierId: String
  logoUrl: String
  tierName: String
}

enum CustomerVisibilityMode {
  LinearOnly
  SlackMembers
  SlackMembersAndGuests
}

type Cycle implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  number: Float!
  name: String
  description: String
  startsAt: DateTime!
  endsAt: DateTime!
  completedAt: DateTime
  autoArchivedAt: DateTime
  issueCountHistory: [Float!]!
  completedIssueCountHistory: [Float!]!
  scopeHistory: [Float!]!
  completedScopeHistory: [Float!]!
  inProgressScopeHistory: [Float!]!
  team: Team!
  progressHistory: JSONObject!
  currentProgress: JSONObject!
  inheritedFrom: Cycle
  isActive: Boolean!
  isFuture: Boolean!
  isPast: Boolean!
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  uncompletedIssuesUponClose(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  progress: Float!
  isNext: Boolean!
  isPrevious: Boolean!
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  links(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EntityExternalLinkConnection!
}

type CycleArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Cycle
}

type CycleConnection {
  edges: [CycleEdge!]!
  nodes: [Cycle!]!
  pageInfo: PageInfo!
}

input CycleCreateInput {
  id: String
  name: String
  description: String
  teamId: String!
  startsAt: DateTime!
  endsAt: DateTime!
  completedAt: DateTime
}

type CycleEdge {
  node: Cycle!
  cursor: String!
}

input CycleFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  number: NumberComparator
  name: StringComparator
  startsAt: DateComparator
  endsAt: DateComparator
  completedAt: DateComparator
  isActive: BooleanComparator
  isInCooldown: BooleanComparator
  isNext: BooleanComparator
  isPrevious: BooleanComparator
  isFuture: BooleanComparator
  isPast: BooleanComparator
  team: TeamFilter
  issues: IssueCollectionFilter
  inheritedFromId: IDComparator
  and: [CycleFilter!]
  or: [CycleFilter!]
}

type CycleNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle!
  label: IssueLabel
  project: Project
  initiative: Initiative
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

type CyclePayload {
  lastSyncId: Float!
  cycle: Cycle
  success: Boolean!
}

enum CyclePeriod {
  before
  during
  after
}

input CyclePeriodComparator {
  eq: CyclePeriod
  neq: CyclePeriod
  in: [CyclePeriod!]
  nin: [CyclePeriod!]
  null: Boolean
}

input CycleShiftAllInput {
  id: String!
  daysToShift: Float!
}

input CycleSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
  currentCycleFirst: Boolean = false
}

input CycleUpdateInput {
  name: String
  description: String
  startsAt: DateTime
  endsAt: DateTime
  completedAt: DateTime
}

type Dashboard implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  slugId: String!
  name: String!
  description: String
  icon: String
  color: String
  sortOrder: Float!
  shared: Boolean!
  organization: Organization!
  creator: User
  updatedBy: User
  owner: User
  issueFilter: JSONObject
  projectFilter: JSONObject
  widgets: JSONObject!
}

input DateComparator {
  eq: DateTimeOrDuration
  neq: DateTimeOrDuration
  in: [DateTimeOrDuration!]
  nin: [DateTimeOrDuration!]
  lt: DateTimeOrDuration
  lte: DateTimeOrDuration
  gt: DateTimeOrDuration
  gte: DateTimeOrDuration
}

enum DateResolutionType {
  month
  quarter
  halfYear
  year
}

scalar DateTime

scalar DateTimeOrDuration

enum Day {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
}

input DelegateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input DeleteOrganizationInput {
  deletionCode: String!
}

type DeletePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entityId: String!
}

type Document implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  title: String!
  icon: String
  color: String
  creator: User
  updatedBy: User
  project: Project
  initiative: Initiative
  team: Team
  issue: Issue
  release: Release
  cycle: Cycle
  slugId: String!
  lastAppliedTemplate: Template
  hiddenAt: DateTime
  trashed: Boolean
  sortOrder: Float!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  content: String
  contentState: String
  documentContentId: String
  url: String!
}

type DocumentArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Document
}

type DocumentConnection {
  edges: [DocumentEdge!]!
  nodes: [Document!]!
  pageInfo: PageInfo!
}

type DocumentContent implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  content: String
  contentState: String
  issue: Issue
  project: Project
  initiative: Initiative
  projectMilestone: ProjectMilestone
  document: Document
  aiPromptRules: AiPromptRules
  welcomeMessage: WelcomeMessage
  restoredAt: DateTime
}

type DocumentContentHistoryPayload {
  history: [DocumentContentHistoryType!]!
  success: Boolean!
}

type DocumentContentHistoryType {
  id: String!
  createdAt: DateTime!
  contentDataSnapshotAt: DateTime!
  contentData: JSON
  actorIds: [String!]
}

input DocumentCreateInput {
  id: String
  title: String!
  icon: String
  color: String
  content: String
  projectId: String
  initiativeId: String
  teamId: String
  issueId: String
  releaseId: String
  cycleId: String
  resourceFolderId: String
  lastAppliedTemplateId: String
  sortOrder: Float
  subscriberIds: [String!]
}

type DocumentEdge {
  node: Document!
  cursor: String!
}

input DocumentFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  title: StringComparator
  slugId: StringComparator
  creator: UserFilter
  project: ProjectFilter
  issue: IssueFilter
  initiative: InitiativeFilter
  and: [DocumentFilter!]
  or: [DocumentFilter!]
}

type DocumentNotification implements Notification & Entity & Node {
  commentId: String
  parentCommentId: String
  reactionEmoji: String
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  documentId: String!
}

type DocumentPayload {
  lastSyncId: Float!
  document: Document!
  success: Boolean!
}

type DocumentSearchPayload {
  edges: [DocumentSearchResultEdge!]!
  nodes: [DocumentSearchResult!]!
  pageInfo: PageInfo!
  archivePayload: ArchiveResponse!
  totalCount: Float!
}

type DocumentSearchResult implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  title: String!
  icon: String
  color: String
  creator: User
  updatedBy: User
  project: Project
  initiative: Initiative
  team: Team
  issue: Issue
  release: Release
  cycle: Cycle
  slugId: String!
  lastAppliedTemplate: Template
  hiddenAt: DateTime
  trashed: Boolean
  sortOrder: Float!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  content: String
  contentState: String
  documentContentId: String
  url: String!
  metadata: JSONObject!
}

type DocumentSearchResultEdge {
  node: DocumentSearchResult!
  cursor: String!
}

input DocumentUpdateInput {
  title: String
  icon: String
  color: String
  content: String
  projectId: String
  initiativeId: String
  teamId: String
  issueId: String
  releaseId: String
  cycleId: String
  resourceFolderId: String
  lastAppliedTemplateId: String
  hiddenAt: DateTime
  sortOrder: Float
  trashed: Boolean
  subscriberIds: [String!]
}

type Draft implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  bodyData: JSON!
  data: JSONObject
  isAutogenerated: Boolean!
  wasLocalDraft: Boolean!
  user: User!
  issue: Issue
  project: Project
  projectUpdate: ProjectUpdate
  initiative: Initiative
  initiativeUpdate: InitiativeUpdate
  post: Post
  parentComment: Comment
  customerNeed: CustomerNeed
  anchor: String
  team: Team
}

type DraftConnection {
  edges: [DraftEdge!]!
  nodes: [Draft!]!
  pageInfo: PageInfo!
}

type DraftEdge {
  node: Draft!
  cursor: String!
}

input DueDateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

scalar Duration

type EmailIntakeAddress implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  address: String!
  type: EmailIntakeAddressType!
  forwardingEmailAddress: String
  senderName: String
  enabled: Boolean!
  repliesEnabled: Boolean!
  useUserNamesInReplies: Boolean!
  template: Template
  team: Team
  organization: Organization!
  sesDomainIdentity: SesDomainIdentity
  creator: User
  customerRequestsEnabled: Boolean!
  issueCreatedAutoReply: String
  issueCreatedAutoReplyEnabled: Boolean!
  issueCompletedAutoReplyEnabled: Boolean!
  issueCompletedAutoReply: String
  issueCanceledAutoReplyEnabled: Boolean!
  issueCanceledAutoReply: String
}

input EmailIntakeAddressCreateInput {
  id: String
  type: EmailIntakeAddressType
  forwardingEmailAddress: String
  senderName: String
  teamId: String
  templateId: String
  repliesEnabled: Boolean
  useUserNamesInReplies: Boolean
  issueCreatedAutoReplyEnabled: Boolean
  issueCreatedAutoReply: String
  issueCompletedAutoReplyEnabled: Boolean
  issueCompletedAutoReply: String
  issueCanceledAutoReplyEnabled: Boolean
  issueCanceledAutoReply: String
  customerRequestsEnabled: Boolean
}

type EmailIntakeAddressPayload {
  lastSyncId: Float!
  emailIntakeAddress: EmailIntakeAddress!
  success: Boolean!
}

enum EmailIntakeAddressType {
  team
  template
  asks
  asksWeb
}

input EmailIntakeAddressUpdateInput {
  enabled: Boolean
  forwardingEmailAddress: String
  senderName: String
  teamId: String
  templateId: String
  repliesEnabled: Boolean
  useUserNamesInReplies: Boolean
  issueCreatedAutoReplyEnabled: Boolean
  issueCreatedAutoReply: String
  issueCompletedAutoReplyEnabled: Boolean
  issueCompletedAutoReply: String
  issueCanceledAutoReplyEnabled: Boolean
  issueCanceledAutoReply: String
  customerRequestsEnabled: Boolean
}

input EmailUnsubscribeInput {
  type: String!
  token: String!
  userId: String!
}

type EmailUnsubscribePayload {
  success: Boolean!
}

input EmailUserAccountAuthChallengeInput {
  email: String!
  isDesktop: Boolean
  clientAuthCode: String
  inviteLink: String
  loginCodeOnly: Boolean
  challengeResponse: String
}

type EmailUserAccountAuthChallengeResponse {
  success: Boolean!
  authType: String!
}

type Emoji implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  url: String!
  source: String!
  creator: User
  organization: Organization!
}

type EmojiConnection {
  edges: [EmojiEdge!]!
  nodes: [Emoji!]!
  pageInfo: PageInfo!
}

input EmojiCreateInput {
  id: String
  name: String!
  url: String!
}

type EmojiEdge {
  node: Emoji!
  cursor: String!
}

type EmojiPayload {
  lastSyncId: Float!
  emoji: Emoji!
  success: Boolean!
}

interface Entity {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
}

type EntityExternalLink implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  url: String!
  label: String!
  sortOrder: Float!
  creator: User!
  initiative: Initiative
}

type EntityExternalLinkConnection {
  edges: [EntityExternalLinkEdge!]!
  nodes: [EntityExternalLink!]!
  pageInfo: PageInfo!
}

input EntityExternalLinkCreateInput {
  id: String
  url: String!
  label: String!
  initiativeId: String
  projectId: String
  teamId: String
  releaseId: String
  cycleId: String
  resourceFolderId: String
  sortOrder: Float
}

type EntityExternalLinkEdge {
  node: EntityExternalLink!
  cursor: String!
}

type EntityExternalLinkPayload {
  lastSyncId: Float!
  entityExternalLink: EntityExternalLink!
  success: Boolean!
}

input EntityExternalLinkUpdateInput {
  url: String
  label: String
  sortOrder: Float
  resourceFolderId: String
}

input EstimateComparator {
  eq: Float
  neq: Float
  in: [Float!]
  nin: [Float!]
  null: Boolean
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  or: [NullableNumberComparator!]
  and: [NullableNumberComparator!]
}

input EstimateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type ExternalEntityInfo {
  id: String!
  service: ExternalSyncService!
  metadata: ExternalEntityInfoMetadata
}

type ExternalEntityInfoGithubMetadata {
  repo: String
  owner: String
  number: Float
}

type ExternalEntityInfoJiraMetadata {
  issueKey: String
  projectId: String
  issueTypeId: String
}

union ExternalEntityInfoMetadata = ExternalEntityInfoGithubMetadata | ExternalEntityInfoJiraMetadata | ExternalEntitySlackMetadata

type ExternalEntitySlackMetadata {
  isFromSlack: Boolean!
  channelId: String
  channelName: String
  messageUrl: String
}

enum ExternalSyncService {
  jira
  github
  slack
}

type ExternalUser implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  displayName: String!
  email: String
  avatarUrl: String
  organization: Organization!
  lastSeen: DateTime
}

type ExternalUserConnection {
  edges: [ExternalUserEdge!]!
  nodes: [ExternalUser!]!
  pageInfo: PageInfo!
}

type ExternalUserEdge {
  node: ExternalUser!
  cursor: String!
}

type Facet implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  sortOrder: Float!
  sourceOrganization: Organization
  sourceTeam: Team
  sourceProject: Project
  sourceInitiative: Initiative
  sourceFeedUser: User
  sourcePage: FacetPageSource
  targetCustomView: CustomView
}

type FacetConnection {
  edges: [FacetEdge!]!
  nodes: [Facet!]!
  pageInfo: PageInfo!
}

type FacetEdge {
  node: Facet!
  cursor: String!
}

enum FacetPageSource {
  projects
  teamIssues
  feed
}

type Favorite implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  parent: Favorite
  folderName: String
  projectTab: ProjectTab
  predefinedViewType: String
  initiativeTab: InitiativeTab
  owner: User!
  sortOrder: Float!
  children(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): FavoriteConnection!
  issue: Issue
  project: Project
  facet: Facet
  projectTeam: Team
  cycle: Cycle
  customView: CustomView
  predefinedViewTeam: Team
  document: Document
  initiative: Initiative
  label: IssueLabel
  projectLabel: ProjectLabel
  user: User
  customer: Customer
  dashboard: Dashboard
  pullRequest: PullRequest
  release: Release
  releasePipeline: ReleasePipeline
  url: String
  title: String!
  detail: String
  color: String
  icon: String
}

type FavoriteConnection {
  edges: [FavoriteEdge!]!
  nodes: [Favorite!]!
  pageInfo: PageInfo!
}

input FavoriteCreateInput {
  id: String
  folderName: String
  parentId: String
  issueId: String
  facetId: String
  projectId: String
  projectTab: ProjectTab
  predefinedViewType: String
  predefinedViewTeamId: String
  cycleId: String
  customViewId: String
  documentId: String
  initiativeId: String
  initiativeTab: InitiativeTab
  labelId: String
  projectLabelId: String
  userId: String
  sortOrder: Float
  customerId: String
  dashboardId: String
  pullRequestId: String
  releaseId: String
  releasePipelineId: String
}

type FavoriteEdge {
  node: Favorite!
  cursor: String!
}

type FavoritePayload {
  lastSyncId: Float!
  favorite: Favorite!
  success: Boolean!
}

input FavoriteUpdateInput {
  sortOrder: Float
  parentId: String
  folderName: String
}

type FeedItem implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  organization: Organization!
  user: User
  team: Team
  projectUpdate: ProjectUpdate
  initiativeUpdate: InitiativeUpdate
  post: Post
}

type FeedItemConnection {
  edges: [FeedItemEdge!]!
  nodes: [FeedItem!]!
  pageInfo: PageInfo!
}

type FeedItemEdge {
  node: FeedItem!
  cursor: String!
}

input FeedItemFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  author: UserFilter
  updateType: StringComparator
  updateHealth: StringComparator
  projectUpdate: ProjectUpdateFilter
  relatedInitiatives: InitiativeCollectionFilter
  relatedTeams: TeamCollectionFilter
  and: [FeedItemFilter!]
  or: [FeedItemFilter!]
}

enum FeedSummarySchedule {
  daily
  weekly
  never
}

type FetchDataPayload {
  data: JSONObject
  query: String
  filters: JSONObject
  success: Boolean!
}

type FileUploadDeletePayload {
  success: Boolean!
}

scalar Float

enum FrequencyResolutionType {
  daily
  weekly
}

type FrontAttachmentPayload {
  lastSyncId: Float!
  attachment: Attachment!
  success: Boolean!
}

input FrontSettingsInput {
  sendNoteOnStatusChange: Boolean
  sendNoteOnComment: Boolean
  automateTicketReopeningOnCompletion: Boolean
  automateTicketReopeningOnCancellation: Boolean
  automateTicketReopeningOnComment: Boolean
  disableCustomerRequestsAutoCreation: Boolean
  automateTicketReopeningOnProjectCompletion: Boolean
  automateTicketReopeningOnProjectCancellation: Boolean
  enableAiIntake: Boolean
}

type GitAutomationState implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  state: WorkflowState
  team: Team!
  targetBranch: GitAutomationTargetBranch
  event: GitAutomationStates!
  branchPattern: String
}

type GitAutomationStateConnection {
  edges: [GitAutomationStateEdge!]!
  nodes: [GitAutomationState!]!
  pageInfo: PageInfo!
}

input GitAutomationStateCreateInput {
  id: String
  teamId: String!
  stateId: String
  targetBranchId: String
  event: GitAutomationStates!
}

type GitAutomationStateEdge {
  node: GitAutomationState!
  cursor: String!
}

type GitAutomationStatePayload {
  lastSyncId: Float!
  gitAutomationState: GitAutomationState!
  success: Boolean!
}

input GitAutomationStateUpdateInput {
  stateId: String
  targetBranchId: String
  event: GitAutomationStates
}

enum GitAutomationStates {
  draft
  start
  review
  mergeable
  merge
}

type GitAutomationTargetBranch implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  team: Team!
  branchPattern: String!
  isRegex: Boolean!
  automationStates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): GitAutomationStateConnection!
}

input GitAutomationTargetBranchCreateInput {
  id: String
  teamId: String!
  branchPattern: String!
  isRegex: Boolean = false
}

type GitAutomationTargetBranchPayload {
  lastSyncId: Float!
  targetBranch: GitAutomationTargetBranch!
  success: Boolean!
}

input GitAutomationTargetBranchUpdateInput {
  branchPattern: String
  isRegex: Boolean
}

type GitHubCommitIntegrationPayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
  webhookSecret: String!
}

type GitHubEnterpriseServerInstallVerificationPayload {
  success: Boolean!
}

type GitHubEnterpriseServerPayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
  setupUrl: String!
  installUrl: String!
  webhookSecret: String!
}

input GitHubImportSettingsInput {
  orgLogin: String!
  orgAvatarUrl: String!
  repositories: [GitHubRepoInput!]!
  labels: JSONObject
  orgType: GithubOrgType!
}

input GitHubPersonalSettingsInput {
  login: String!
}

input GitHubRepoInput {
  id: Float!
  fullName: String!
  archived: Boolean
}

input GitHubRepoMappingInput {
  id: String!
  linearTeamId: String!
  gitHubRepoId: Float!
  gitHubLabels: [String!]
  bidirectional: Boolean
  default: Boolean
}

input GitHubSettingsInput {
  pullRequestReviewTool: PullRequestReviewTool
  orgAvatarUrl: String
  orgLogin: String!
  repositories: [GitHubRepoInput!]
  repositoriesMapping: [GitHubRepoMappingInput!]
  orgType: GithubOrgType
  codeAccess: Boolean
}

type GitLabIntegrationCreatePayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
  webhookSecret: String!
  error: String
  errorResponseBody: String
  errorResponseHeaders: String
}

input GitLabSettingsInput {
  url: String
  readonly: Boolean
  expiresAt: String
}

type GitLabTestConnectionPayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
  error: String
  errorResponseBody: String
  errorResponseHeaders: String
}

enum GitLinkKind {
  closes
  contributes
  links
}

enum GithubOrgType {
  user
  organization
}

input GongRecordingImportConfigInput {
  teamId: String
}

input GongSettingsInput {
  importConfig: GongRecordingImportConfigInput
}

input GoogleSheetsExportSettings {
  enabled: Boolean
  spreadsheetId: String
  spreadsheetUrl: String
  sheetId: Float
  updatedAt: DateTime
}

input GoogleSheetsSettingsInput {
  spreadsheetId: String
  spreadsheetUrl: String
  sheetId: Float
  updatedIssuesAt: DateTime
  issue: GoogleSheetsExportSettings
  project: GoogleSheetsExportSettings
  initiative: GoogleSheetsExportSettings
}

input GoogleUserAccountAuthInput {
  code: String!
  redirectUri: String
  timezone: String!
  inviteLink: String
  disallowSignup: Boolean
}

scalar ID

input IDComparator {
  eq: ID
  neq: ID
  in: [ID!]
  nin: [ID!]
}

type IdentityProvider implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  defaultMigrated: Boolean!
  type: IdentityProviderType!
  samlEnabled: Boolean!
  ssoEndpoint: String
  ssoBinding: String
  ssoSignAlgo: String
  ssoSigningCert: String
  issuerEntityId: String
  spEntityId: String
  priority: Float
  scimEnabled: Boolean!
  ownersGroupPush: JSONObject
  adminsGroupPush: JSONObject
  guestsGroupPush: JSONObject
  allowNameChange: Boolean!
}

enum IdentityProviderType {
  general
  webForms
}

type ImageUploadFromUrlPayload {
  lastSyncId: Float!
  url: String
  success: Boolean!
}

input InheritanceEntityMapping {
  workflowStates: JSONObject!
  issueLabels: JSONObject
}

type Initiative implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  updateReminderFrequencyInWeeks: Float
  updateReminderFrequency: Float
  frequencyResolution: FrequencyResolutionType!
  updateRemindersDay: Day
  updateRemindersHour: Float
  name: String!
  description: String
  organization: Organization!
  creator: User
  owner: User
  slugId: String!
  sortOrder: Float!
  color: String
  icon: String
  trashed: Boolean
  facets: [Facet!]!
  targetDate: TimelessDate
  targetDateResolution: DateResolutionType
  status: InitiativeStatus!
  lastUpdate: InitiativeUpdate
  health: InitiativeUpdateHealthType
  healthUpdatedAt: DateTime
  startedAt: DateTime
  completedAt: DateTime
  url: String!
  projects(includeSubInitiatives: Boolean, filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [ProjectSortInput!]): ProjectConnection!
  links(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EntityExternalLinkConnection!
  integrationsSettings: IntegrationsSettings
  history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeHistoryConnection!
  initiativeUpdates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeUpdateConnection!
  subInitiatives(filter: InitiativeFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [InitiativeSortInput!]): InitiativeConnection!
  parentInitiative: Initiative
  parentInitiatives(filter: InitiativeFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [InitiativeSortInput!]): InitiativeConnection!
  content: String
  documentContent: DocumentContent
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
}

type InitiativeArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Initiative
}

input InitiativeCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  creator: NullableUserFilter
  status: StringComparator
  teams: TeamCollectionFilter
  owner: NullableUserFilter
  targetDate: NullableDateComparator
  health: StringComparator
  healthWithAge: StringComparator
  activityType: StringComparator
  ancestors: InitiativeCollectionFilter
  and: [InitiativeCollectionFilter!]
  or: [InitiativeCollectionFilter!]
  some: InitiativeFilter
  every: InitiativeFilter
  length: NumberComparator
}

type InitiativeConnection {
  edges: [InitiativeEdge!]!
  nodes: [Initiative!]!
  pageInfo: PageInfo!
}

input InitiativeCreateInput {
  id: String
  name: String!
  description: String
  ownerId: String
  sortOrder: Float
  color: String
  icon: String
  status: InitiativeStatus
  targetDate: TimelessDate
  targetDateResolution: DateResolutionType
  content: String
}

input InitiativeCreatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type InitiativeEdge {
  node: Initiative!
  cursor: String!
}

input InitiativeFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  creator: NullableUserFilter
  status: StringComparator
  teams: TeamCollectionFilter
  owner: NullableUserFilter
  targetDate: NullableDateComparator
  health: StringComparator
  healthWithAge: StringComparator
  activityType: StringComparator
  ancestors: InitiativeCollectionFilter
  and: [InitiativeFilter!]
  or: [InitiativeFilter!]
}

input InitiativeHealthSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input InitiativeHealthUpdatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type InitiativeHistory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  entries: JSONObject!
  initiative: Initiative!
}

type InitiativeHistoryConnection {
  edges: [InitiativeHistoryEdge!]!
  nodes: [InitiativeHistory!]!
  pageInfo: PageInfo!
}

type InitiativeHistoryEdge {
  node: InitiativeHistory!
  cursor: String!
}

input InitiativeManualSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input InitiativeNameSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type InitiativeNotification implements Notification & Entity & Node {
  commentId: String
  parentCommentId: String
  reactionEmoji: String
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  initiativeId: String!
  initiativeUpdateId: String
  initiative: Initiative
  document: Document
  initiativeUpdate: InitiativeUpdate
  comment: Comment
  parentComment: Comment
}

type InitiativeNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle
  label: IssueLabel
  project: Project
  initiative: Initiative!
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

input InitiativeOwnerSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type InitiativePayload {
  lastSyncId: Float!
  initiative: Initiative!
  success: Boolean!
}

type InitiativeRelation implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  initiative: Initiative!
  relatedInitiative: Initiative!
  user: User
  sortOrder: Float!
}

type InitiativeRelationConnection {
  edges: [InitiativeRelationEdge!]!
  nodes: [InitiativeRelation!]!
  pageInfo: PageInfo!
}

input InitiativeRelationCreateInput {
  id: String
  initiativeId: String!
  relatedInitiativeId: String!
  sortOrder: Float
}

type InitiativeRelationEdge {
  node: InitiativeRelation!
  cursor: String!
}

type InitiativeRelationPayload {
  lastSyncId: Float!
  initiativeRelation: InitiativeRelation!
  success: Boolean!
}

input InitiativeRelationUpdateInput {
  sortOrder: Float
}

input InitiativeSortInput {
  name: InitiativeNameSort
  manual: InitiativeManualSort
  updatedAt: InitiativeUpdatedAtSort
  createdAt: InitiativeCreatedAtSort
  targetDate: InitiativeTargetDateSort
  health: InitiativeHealthSort
  healthUpdatedAt: InitiativeHealthUpdatedAtSort
  owner: InitiativeOwnerSort
}

enum InitiativeStatus {
  Planned
  Active
  Completed
}

enum InitiativeTab {
  overview
  projects
  updates
}

input InitiativeTargetDateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type InitiativeToProject implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  project: Project!
  initiative: Initiative!
  sortOrder: String!
}

type InitiativeToProjectConnection {
  edges: [InitiativeToProjectEdge!]!
  nodes: [InitiativeToProject!]!
  pageInfo: PageInfo!
}

input InitiativeToProjectCreateInput {
  id: String
  projectId: String!
  initiativeId: String!
  sortOrder: Float
}

type InitiativeToProjectEdge {
  node: InitiativeToProject!
  cursor: String!
}

type InitiativeToProjectPayload {
  lastSyncId: Float!
  initiativeToProject: InitiativeToProject!
  success: Boolean!
}

input InitiativeToProjectUpdateInput {
  sortOrder: Float
}

type InitiativeUpdate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  body: String!
  editedAt: DateTime
  reactionData: JSONObject!
  bodyData: String!
  slugId: String!
  initiative: Initiative!
  user: User!
  health: InitiativeUpdateHealthType!
  infoSnapshot: JSONObject
  isDiffHidden: Boolean!
  url: String!
  isStale: Boolean!
  diff: JSONObject
  diffMarkdown: String
  reactions: [Reaction!]!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  commentCount: Int!
}

type InitiativeUpdateArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: InitiativeUpdate
}

type InitiativeUpdateConnection {
  edges: [InitiativeUpdateEdge!]!
  nodes: [InitiativeUpdate!]!
  pageInfo: PageInfo!
}

input InitiativeUpdateCreateInput {
  id: String
  body: String
  bodyData: JSON
  health: InitiativeUpdateHealthType
  initiativeId: String!
  isDiffHidden: Boolean
}

type InitiativeUpdateEdge {
  node: InitiativeUpdate!
  cursor: String!
}

input InitiativeUpdateFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  user: UserFilter
  initiative: InitiativeFilter
  reactions: ReactionCollectionFilter
  and: [InitiativeUpdateFilter!]
  or: [InitiativeUpdateFilter!]
}

enum InitiativeUpdateHealthType {
  onTrack
  atRisk
  offTrack
}

input InitiativeUpdateInput {
  name: String
  description: String
  ownerId: String
  sortOrder: Float
  color: String
  icon: String
  targetDate: TimelessDate
  status: InitiativeStatus
  targetDateResolution: DateResolutionType
  trashed: Boolean
  content: String
  updateReminderFrequencyInWeeks: Float
  updateReminderFrequency: Float
  frequencyResolution: FrequencyResolutionType
  updateRemindersDay: Day
  updateRemindersHour: Int
}

type InitiativeUpdatePayload {
  lastSyncId: Float!
  initiativeUpdate: InitiativeUpdate!
  success: Boolean!
}

type InitiativeUpdateReminderPayload {
  lastSyncId: Float!
  success: Boolean!
}

input InitiativeUpdateUpdateInput {
  body: String
  bodyData: JSON
  health: InitiativeUpdateHealthType
  isDiffHidden: Boolean
}

input InitiativeUpdatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

scalar Int

type Integration implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  service: String!
  organization: Organization!
  team: Team
  creator: User!
}

type IntegrationConnection {
  edges: [IntegrationEdge!]!
  nodes: [Integration!]!
  pageInfo: PageInfo!
}

input IntegrationCustomerDataAttributesRefreshInput {
  service: String!
}

type IntegrationEdge {
  node: Integration!
  cursor: String!
}

type IntegrationHasScopesPayload {
  hasAllScopes: Boolean!
  missingScopes: [String!]
}

type IntegrationPayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
}

input IntegrationRequestInput {
  email: String
  name: String!
}

type IntegrationRequestPayload {
  success: Boolean!
}

enum IntegrationService {
  airbyte
  discord
  figma
  figmaPlugin
  front
  github
  gong
  githubEnterpriseServer
  githubCommit
  githubImport
  githubPersonal
  githubCodeAccessPersonal
  gitlab
  googleCalendarPersonal
  googleSheets
  intercom
  jira
  jiraPersonal
  launchDarkly
  launchDarklyPersonal
  loom
  notion
  opsgenie
  pagerDuty
  salesforce
  slack
  slackAsks
  slackCustomViewNotifications
  slackOrgProjectUpdatesPost
  slackOrgInitiativeUpdatesPost
  slackPersonal
  slackPost
  slackProjectPost
  slackProjectUpdatesPost
  slackInitiativePost
  sentry
  zendesk
  email
  mcpServerPersonal
  mcpServer
  microsoftTeams
}

input IntegrationSettingsInput {
  slack: SlackSettingsInput
  slackAsks: SlackAsksSettingsInput
  slackPost: SlackPostSettingsInput
  slackProjectPost: SlackPostSettingsInput
  slackInitiativePost: SlackPostSettingsInput
  slackCustomViewNotifications: SlackPostSettingsInput
  slackOrgProjectUpdatesPost: SlackPostSettingsInput
  slackOrgInitiativeUpdatesPost: SlackPostSettingsInput
  googleSheets: GoogleSheetsSettingsInput
  gitHub: GitHubSettingsInput
  gitHubImport: GitHubImportSettingsInput
  gitHubPersonal: GitHubPersonalSettingsInput
  gitLab: GitLabSettingsInput
  sentry: SentrySettingsInput
  zendesk: ZendeskSettingsInput
  intercom: IntercomSettingsInput
  front: FrontSettingsInput
  gong: GongSettingsInput
  microsoftTeams: MicrosoftTeamsSettingsInput
  jira: JiraSettingsInput
  notion: NotionSettingsInput
  opsgenie: OpsgenieInput
  pagerDuty: PagerDutyInput
  launchDarkly: LaunchDarklySettingsInput
  jiraPersonal: JiraPersonalSettingsInput
  salesforce: SalesforceSettingsInput
}

type IntegrationSlackWorkspaceNamePayload {
  name: String!
  success: Boolean!
}

type IntegrationTemplate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  template: Template!
  integration: Integration!
  foreignEntityId: String
}

type IntegrationTemplateConnection {
  edges: [IntegrationTemplateEdge!]!
  nodes: [IntegrationTemplate!]!
  pageInfo: PageInfo!
}

input IntegrationTemplateCreateInput {
  id: String
  integrationId: String!
  templateId: String!
  foreignEntityId: String
}

type IntegrationTemplateEdge {
  node: IntegrationTemplate!
  cursor: String!
}

type IntegrationTemplatePayload {
  lastSyncId: Float!
  integrationTemplate: IntegrationTemplate!
  success: Boolean!
}

input IntegrationUpdateInput {
  settings: IntegrationSettingsInput
}

type IntegrationsSettings implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  contextViewType: ContextViewType
  slackIssueCreated: Boolean
  slackIssueNewComment: Boolean
  slackIssueStatusChangedDone: Boolean
  slackIssueAddedToView: Boolean
  slackIssueStatusChangedAll: Boolean
  slackProjectUpdateCreated: Boolean
  slackProjectUpdateCreatedToTeam: Boolean
  slackProjectUpdateCreatedToWorkspace: Boolean
  slackInitiativeUpdateCreated: Boolean
  slackIssueAddedToTriage: Boolean
  slackIssueSlaHighRisk: Boolean
  slackIssueSlaBreached: Boolean
  team: Team
  project: Project
  initiative: Initiative
}

input IntegrationsSettingsCreateInput {
  slackIssueCreated: Boolean
  slackIssueAddedToView: Boolean
  slackIssueNewComment: Boolean
  slackIssueStatusChangedDone: Boolean
  slackIssueStatusChangedAll: Boolean
  slackProjectUpdateCreated: Boolean
  slackProjectUpdateCreatedToTeam: Boolean
  slackProjectUpdateCreatedToWorkspace: Boolean
  slackInitiativeUpdateCreated: Boolean
  slackIssueAddedToTriage: Boolean
  slackIssueSlaHighRisk: Boolean
  slackIssueSlaBreached: Boolean
  id: String
  teamId: String
  projectId: String
  initiativeId: String
  customViewId: String
  contextViewType: ContextViewType
}

type IntegrationsSettingsPayload {
  lastSyncId: Float!
  integrationsSettings: IntegrationsSettings!
  success: Boolean!
}

input IntegrationsSettingsUpdateInput {
  slackIssueCreated: Boolean
  slackIssueAddedToView: Boolean
  slackIssueNewComment: Boolean
  slackIssueStatusChangedDone: Boolean
  slackIssueStatusChangedAll: Boolean
  slackProjectUpdateCreated: Boolean
  slackProjectUpdateCreatedToTeam: Boolean
  slackProjectUpdateCreatedToWorkspace: Boolean
  slackInitiativeUpdateCreated: Boolean
  slackIssueAddedToTriage: Boolean
  slackIssueSlaHighRisk: Boolean
  slackIssueSlaBreached: Boolean
}

input IntercomSettingsInput {
  sendNoteOnStatusChange: Boolean
  sendNoteOnComment: Boolean
  automateTicketReopeningOnCompletion: Boolean
  automateTicketReopeningOnCancellation: Boolean
  automateTicketReopeningOnComment: Boolean
  disableCustomerRequestsAutoCreation: Boolean
  automateTicketReopeningOnProjectCompletion: Boolean
  automateTicketReopeningOnProjectCancellation: Boolean
  enableAiIntake: Boolean
}

type Issue implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  number: Float!
  title: String!
  priority: Float!
  estimate: Float
  boardOrder: Float!
  sortOrder: Float!
  prioritySortOrder: Float!
  startedAt: DateTime
  completedAt: DateTime
  startedTriageAt: DateTime
  triagedAt: DateTime
  canceledAt: DateTime
  autoClosedAt: DateTime
  autoArchivedAt: DateTime
  dueDate: TimelessDate
  slaStartedAt: DateTime
  slaMediumRiskAt: DateTime
  slaHighRiskAt: DateTime
  slaBreachesAt: DateTime
  slaType: String
  addedToProjectAt: DateTime
  addedToCycleAt: DateTime
  addedToTeamAt: DateTime
  trashed: Boolean
  snoozedUntilAt: DateTime
  suggestionsGeneratedAt: DateTime
  activitySummary: JSONObject
  summary: Summary
  labelIds: [String!]!
  team: Team!
  cycle: Cycle
  project: Project
  projectMilestone: ProjectMilestone
  lastAppliedTemplate: Template
  recurringIssueTemplate: Template
  previousIdentifiers: [String!]!
  creator: User
  externalUserCreator: ExternalUser
  assignee: User
  delegate: User
  snoozedBy: User
  state: WorkflowState!
  subIssueSortOrder: Float
  reactionData: JSONObject!
  priorityLabel: String!
  sourceComment: Comment
  integrationSourceType: IntegrationService
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  botActor: ActorBot
  favorite: Favorite
  identifier: String!
  url: String!
  branchName: String!
  customerTicketCount: Int!
  subscribers(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
  parent: Issue
  children(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueHistoryConnection!
  labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
  relations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
  inverseRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
  attachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
  formerAttachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
  description: String
  descriptionState: String
  documentContent: DocumentContent
  reactions: [Reaction!]!
  needs(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  formerNeeds(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  syncedWith: [ExternalEntityInfo!]
  suggestions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueSuggestionConnection!
  incomingSuggestions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueSuggestionConnection!
  asksRequester: User
  asksExternalUserRequester: ExternalUser
  stateHistory(before: String, after: String, first: Int, last: Int): IssueStateSpanConnection!
}

type IssueArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Issue
}

input IssueBatchCreateInput {
  issues: [IssueCreateInput!]!
}

type IssueBatchPayload {
  lastSyncId: Float!
  issues: [Issue!]!
  success: Boolean!
}

input IssueCollectionFilter {
  id: IssueIDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  number: NumberComparator
  title: StringComparator
  description: NullableStringComparator
  priority: NullableNumberComparator
  estimate: EstimateComparator
  startedAt: NullableDateComparator
  triagedAt: NullableDateComparator
  completedAt: NullableDateComparator
  canceledAt: NullableDateComparator
  archivedAt: NullableDateComparator
  autoClosedAt: NullableDateComparator
  autoArchivedAt: NullableDateComparator
  addedToCycleAt: NullableDateComparator
  addedToCyclePeriod: CyclePeriodComparator
  dueDate: NullableTimelessDateComparator
  accumulatedStateUpdatedAt: NullableDateComparator
  snoozedUntilAt: NullableDateComparator
  assignee: NullableUserFilter
  delegate: NullableUserFilter
  lastAppliedTemplate: NullableTemplateFilter
  recurringIssueTemplate: NullableTemplateFilter
  sourceMetadata: SourceMetadataComparator
  creator: NullableUserFilter
  parent: NullableIssueFilter
  snoozedBy: NullableUserFilter
  labels: IssueLabelCollectionFilter
  subscribers: UserCollectionFilter
  hasSharedUsers: RelationExistsComparator
  sharedWith: UserCollectionFilter
  team: TeamFilter
  projectMilestone: NullableProjectMilestoneFilter
  comments: CommentCollectionFilter
  activity: ActivityCollectionFilter
  suggestions: IssueSuggestionCollectionFilter
  cycle: NullableCycleFilter
  project: NullableProjectFilter
  state: WorkflowStateFilter
  children: IssueCollectionFilter
  attachments: AttachmentCollectionFilter
  searchableContent: ContentComparator
  hasRelatedRelations: RelationExistsComparator
  hasDuplicateRelations: RelationExistsComparator
  hasBlockedByRelations: RelationExistsComparator
  hasBlockingRelations: RelationExistsComparator
  hasSuggestedRelatedIssues: RelationExistsComparator
  hasSuggestedSimilarIssues: RelationExistsComparator
  hasSuggestedAssignees: RelationExistsComparator
  hasSuggestedProjects: RelationExistsComparator
  hasSuggestedLabels: RelationExistsComparator
  hasSuggestedTeams: RelationExistsComparator
  slaStatus: SlaStatusComparator
  reactions: ReactionCollectionFilter
  needs: CustomerNeedCollectionFilter
  releases: ReleaseCollectionFilter
  customerCount: NumberComparator
  customerImportantCount: NumberComparator
  leadTime: NullableDurationComparator
  cycleTime: NullableDurationComparator
  ageTime: NullableDurationComparator
  triageTime: NullableDurationComparator
  and: [IssueCollectionFilter!]
  or: [IssueCollectionFilter!]
  some: IssueFilter
  every: IssueFilter
  length: NumberComparator
}

type IssueConnection {
  edges: [IssueEdge!]!
  nodes: [Issue!]!
  pageInfo: PageInfo!
}

input IssueCreateInput {
  id: String
  title: String
  description: String
  descriptionData: JSON
  assigneeId: String
  delegateId: String
  parentId: String
  priority: Int
  estimate: Int
  subscriberIds: [String!]
  labelIds: [String!]
  teamId: String!
  cycleId: String
  projectId: String
  projectMilestoneId: String
  lastAppliedTemplateId: String
  stateId: String
  referenceCommentId: String
  sourceCommentId: String
  sourcePullRequestCommentId: String
  sortOrder: Float
  prioritySortOrder: Float
  subIssueSortOrder: Float
  dueDate: TimelessDate
  createAsUser: String
  displayIconUrl: String
  preserveSortOrderOnCreate: Boolean
  createdAt: DateTime
  slaBreachesAt: DateTime
  slaStartedAt: DateTime
  templateId: String
  completedAt: DateTime
  slaType: SLADayCountType
  useDefaultTemplate: Boolean
}

type IssueDraft implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  title: String!
  description: String
  priority: Float!
  estimate: Float
  dueDate: TimelessDate
  labelIds: [String!]!
  teamId: String!
  cycleId: String
  projectId: String
  projectMilestoneId: String
  creator: User!
  assigneeId: String
  delegateId: String
  stateId: String!
  parent: IssueDraft
  parentId: String
  sourceCommentId: String
  parentIssue: Issue
  parentIssueId: String
  subIssueSortOrder: Float
  priorityLabel: String!
  descriptionData: JSON
  attachments: JSONObject
  needs: JSONObject
  schedule: JSONObject
}

type IssueDraftConnection {
  edges: [IssueDraftEdge!]!
  nodes: [IssueDraft!]!
  pageInfo: PageInfo!
}

type IssueDraftEdge {
  node: IssueDraft!
  cursor: String!
}

type IssueEdge {
  node: Issue!
  cursor: String!
}

input IssueFilter {
  id: IssueIDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  number: NumberComparator
  title: StringComparator
  description: NullableStringComparator
  priority: NullableNumberComparator
  estimate: EstimateComparator
  startedAt: NullableDateComparator
  triagedAt: NullableDateComparator
  completedAt: NullableDateComparator
  canceledAt: NullableDateComparator
  archivedAt: NullableDateComparator
  autoClosedAt: NullableDateComparator
  autoArchivedAt: NullableDateComparator
  addedToCycleAt: NullableDateComparator
  addedToCyclePeriod: CyclePeriodComparator
  dueDate: NullableTimelessDateComparator
  accumulatedStateUpdatedAt: NullableDateComparator
  snoozedUntilAt: NullableDateComparator
  assignee: NullableUserFilter
  delegate: NullableUserFilter
  lastAppliedTemplate: NullableTemplateFilter
  recurringIssueTemplate: NullableTemplateFilter
  sourceMetadata: SourceMetadataComparator
  creator: NullableUserFilter
  parent: NullableIssueFilter
  snoozedBy: NullableUserFilter
  labels: IssueLabelCollectionFilter
  subscribers: UserCollectionFilter
  hasSharedUsers: RelationExistsComparator
  sharedWith: UserCollectionFilter
  team: TeamFilter
  projectMilestone: NullableProjectMilestoneFilter
  comments: CommentCollectionFilter
  activity: ActivityCollectionFilter
  suggestions: IssueSuggestionCollectionFilter
  cycle: NullableCycleFilter
  project: NullableProjectFilter
  state: WorkflowStateFilter
  children: IssueCollectionFilter
  attachments: AttachmentCollectionFilter
  searchableContent: ContentComparator
  hasRelatedRelations: RelationExistsComparator
  hasDuplicateRelations: RelationExistsComparator
  hasBlockedByRelations: RelationExistsComparator
  hasBlockingRelations: RelationExistsComparator
  hasSuggestedRelatedIssues: RelationExistsComparator
  hasSuggestedSimilarIssues: RelationExistsComparator
  hasSuggestedAssignees: RelationExistsComparator
  hasSuggestedProjects: RelationExistsComparator
  hasSuggestedLabels: RelationExistsComparator
  hasSuggestedTeams: RelationExistsComparator
  slaStatus: SlaStatusComparator
  reactions: ReactionCollectionFilter
  needs: CustomerNeedCollectionFilter
  releases: ReleaseCollectionFilter
  customerCount: NumberComparator
  customerImportantCount: NumberComparator
  leadTime: NullableDurationComparator
  cycleTime: NullableDurationComparator
  ageTime: NullableDurationComparator
  triageTime: NullableDurationComparator
  and: [IssueFilter!]
  or: [IssueFilter!]
}

type IssueFilterSuggestionPayload {
  filter: JSONObject
  logId: String
}

type IssueHistory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  issue: Issue!
  actorId: String
  updatedDescription: Boolean
  fromTitle: String
  toTitle: String
  fromAssigneeId: String
  toAssigneeId: String
  fromPriority: Float
  toPriority: Float
  fromTeamId: String
  toTeamId: String
  fromParentId: String
  toParentId: String
  fromStateId: String
  toStateId: String
  fromCycleId: String
  toCycleId: String
  toConvertedProjectId: String
  fromProjectId: String
  toProjectId: String
  fromEstimate: Float
  toEstimate: Float
  archived: Boolean
  trashed: Boolean
  attachmentId: String
  addedLabelIds: [String!]
  removedLabelIds: [String!]
  addedToReleaseIds: [String!]
  removedFromReleaseIds: [String!]
  relationChanges: [IssueRelationHistoryPayload!]
  autoClosed: Boolean
  autoArchived: Boolean
  fromDueDate: TimelessDate
  toDueDate: TimelessDate
  customerNeedId: String
  changes: JSONObject
  actor: User
  actors: [User!]
  descriptionUpdatedBy: [User!]
  fromAssignee: User
  toAssignee: User
  fromCycle: Cycle
  toCycle: Cycle
  toConvertedProject: Project
  fromDelegate: User
  toDelegate: User
  fromProject: Project
  toProject: Project
  fromState: WorkflowState
  toState: WorkflowState
  fromTeam: Team
  toTeam: Team
  fromParent: Issue
  toParent: Issue
  attachment: Attachment
  issueImport: IssueImport
  triageResponsibilityNotifiedUsers: [User!]
  triageResponsibilityAutoAssigned: Boolean
  triageResponsibilityTeam: Team
  fromProjectMilestone: ProjectMilestone
  toProjectMilestone: ProjectMilestone
  fromSlaStartedAt: DateTime
  toSlaStartedAt: DateTime
  fromSlaBreachesAt: DateTime
  toSlaBreachesAt: DateTime
  fromSlaBreached: Boolean
  toSlaBreached: Boolean
  fromSlaType: String
  toSlaType: String
  botActor: ActorBot
  addedLabels: [IssueLabel!]
  removedLabels: [IssueLabel!]
  addedToReleases: [Release!]
  removedFromReleases: [Release!]
  triageRuleMetadata: IssueHistoryTriageRuleMetadata
}

type IssueHistoryConnection {
  edges: [IssueHistoryEdge!]!
  nodes: [IssueHistory!]!
  pageInfo: PageInfo!
}

type IssueHistoryEdge {
  node: IssueHistory!
  cursor: String!
}

type IssueHistoryTriageRuleError {
  type: TriageRuleErrorType!
  property: String
  conflictForSameChildLabel: Boolean
  fromTeam: Team
  toTeam: Team
  conflictingLabels: [IssueLabel!]
}

type IssueHistoryTriageRuleMetadata {
  triageRuleError: IssueHistoryTriageRuleError
  updatedByTriageRule: WorkflowDefinition
}

input IssueIDComparator {
  eq: ID
  neq: ID
  in: [ID!]
  nin: [ID!]
}

type IssueImport implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  teamName: String
  creatorId: String
  service: String!
  status: String!
  mapping: JSONObject
  error: String
  progress: Float
  csvFileUrl: String
  errorMetadata: JSONObject
  serviceMetadata: JSONObject
  displayName: String!
}

type IssueImportCheckPayload {
  success: Boolean!
}

type IssueImportDeletePayload {
  lastSyncId: Float!
  issueImport: IssueImport
  success: Boolean!
}

type IssueImportJqlCheckPayload {
  success: Boolean!
  count: Float
  error: String
}

type IssueImportPayload {
  lastSyncId: Float!
  issueImport: IssueImport
  success: Boolean!
}

type IssueImportSyncCheckPayload {
  canSync: Boolean!
  error: String
}

input IssueImportUpdateInput {
  mapping: JSONObject!
}

type IssueLabel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  description: String
  color: String!
  isGroup: Boolean!
  lastAppliedAt: DateTime
  retiredAt: DateTime
  organization: Organization!
  team: Team
  creator: User
  retiredBy: User
  parent: IssueLabel
  inheritedFrom: IssueLabel
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  children(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
}

input IssueLabelCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  isGroup: BooleanComparator
  creator: NullableUserFilter
  team: NullableTeamFilter
  parent: IssueLabelFilter
  null: Boolean
  and: [IssueLabelCollectionFilter!]
  or: [IssueLabelCollectionFilter!]
  some: IssueLabelFilter
  every: IssueLabelFilter
  length: NumberComparator
}

type IssueLabelConnection {
  edges: [IssueLabelEdge!]!
  nodes: [IssueLabel!]!
  pageInfo: PageInfo!
}

input IssueLabelCreateInput {
  id: String
  name: String!
  description: String
  color: String
  parentId: String
  teamId: String
  isGroup: Boolean
  retiredAt: DateTime
}

type IssueLabelEdge {
  node: IssueLabel!
  cursor: String!
}

input IssueLabelFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  isGroup: BooleanComparator
  creator: NullableUserFilter
  team: NullableTeamFilter
  parent: IssueLabelFilter
  and: [IssueLabelFilter!]
  or: [IssueLabelFilter!]
}

type IssueLabelPayload {
  lastSyncId: Float!
  issueLabel: IssueLabel!
  success: Boolean!
}

input IssueLabelUpdateInput {
  name: String
  description: String
  parentId: String
  color: String
  isGroup: Boolean
  retiredAt: DateTime
}

type IssueNotification implements Notification & Entity & Node {
  commentId: String
  parentCommentId: String
  reactionEmoji: String
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  issueId: String!
  issue: Issue!
  comment: Comment
  parentComment: Comment
  team: Team!
  subscriptions: [NotificationSubscription!]
}

type IssuePayload {
  lastSyncId: Float!
  issue: Issue
  success: Boolean!
}

type IssuePriorityValue {
  priority: Int!
  label: String!
}

input IssueReferenceInput {
  identifier: String!
  commitSha: String!
}

type IssueRelation implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  issue: Issue!
  relatedIssue: Issue!
}

type IssueRelationConnection {
  edges: [IssueRelationEdge!]!
  nodes: [IssueRelation!]!
  pageInfo: PageInfo!
}

input IssueRelationCreateInput {
  id: String
  type: IssueRelationType!
  issueId: String!
  relatedIssueId: String!
}

type IssueRelationEdge {
  node: IssueRelation!
  cursor: String!
}

type IssueRelationHistoryPayload {
  identifier: String!
  type: String!
}

type IssueRelationPayload {
  lastSyncId: Float!
  issueRelation: IssueRelation!
  success: Boolean!
}

enum IssueRelationType {
  blocks
  duplicate
  related
  similar
}

input IssueRelationUpdateInput {
  type: String
  issueId: String
  relatedIssueId: String
}

type IssueSearchPayload {
  edges: [IssueSearchResultEdge!]!
  nodes: [IssueSearchResult!]!
  pageInfo: PageInfo!
  archivePayload: ArchiveResponse!
  totalCount: Float!
}

type IssueSearchResult implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  number: Float!
  title: String!
  priority: Float!
  estimate: Float
  boardOrder: Float!
  sortOrder: Float!
  prioritySortOrder: Float!
  startedAt: DateTime
  completedAt: DateTime
  startedTriageAt: DateTime
  triagedAt: DateTime
  canceledAt: DateTime
  autoClosedAt: DateTime
  autoArchivedAt: DateTime
  dueDate: TimelessDate
  slaStartedAt: DateTime
  slaMediumRiskAt: DateTime
  slaHighRiskAt: DateTime
  slaBreachesAt: DateTime
  slaType: String
  addedToProjectAt: DateTime
  addedToCycleAt: DateTime
  addedToTeamAt: DateTime
  trashed: Boolean
  snoozedUntilAt: DateTime
  suggestionsGeneratedAt: DateTime
  activitySummary: JSONObject
  summary: Summary
  labelIds: [String!]!
  team: Team!
  cycle: Cycle
  project: Project
  projectMilestone: ProjectMilestone
  lastAppliedTemplate: Template
  recurringIssueTemplate: Template
  previousIdentifiers: [String!]!
  creator: User
  externalUserCreator: ExternalUser
  assignee: User
  delegate: User
  snoozedBy: User
  state: WorkflowState!
  subIssueSortOrder: Float
  reactionData: JSONObject!
  priorityLabel: String!
  sourceComment: Comment
  integrationSourceType: IntegrationService
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  botActor: ActorBot
  favorite: Favorite
  identifier: String!
  url: String!
  branchName: String!
  customerTicketCount: Int!
  subscribers(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
  parent: Issue
  children(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueHistoryConnection!
  labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
  relations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
  inverseRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
  attachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
  formerAttachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
  description: String
  descriptionState: String
  documentContent: DocumentContent
  reactions: [Reaction!]!
  needs(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  formerNeeds(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  syncedWith: [ExternalEntityInfo!]
  suggestions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueSuggestionConnection!
  incomingSuggestions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueSuggestionConnection!
  asksRequester: User
  asksExternalUserRequester: ExternalUser
  stateHistory(before: String, after: String, first: Int, last: Int): IssueStateSpanConnection!
  metadata: JSONObject!
}

type IssueSearchResultEdge {
  node: IssueSearchResult!
  cursor: String!
}

input IssueSortInput {
  priority: PrioritySort
  estimate: EstimateSort
  title: TitleSort
  label: LabelSort
  labelGroup: LabelGroupSort
  slaStatus: SlaStatusSort
  createdAt: CreatedAtSort
  updatedAt: UpdatedAtSort
  completedAt: CompletedAtSort
  dueDate: DueDateSort
  accumulatedStateUpdatedAt: TimeInStatusSort
  cycle: CycleSort
  milestone: MilestoneSort
  assignee: AssigneeSort
  delegate: DelegateSort
  project: ProjectSort
  team: TeamSort
  manual: ManualSort
  workflowState: WorkflowStateSort
  customer: CustomerSort
  customerRevenue: CustomerRevenueSort
  customerCount: CustomerCountSort
  customerImportantCount: CustomerImportantCountSort
  rootIssue: RootIssueSort
  linkCount: LinkCountSort
}

type IssueStateSpan {
  id: ID!
  stateId: ID!
  startedAt: DateTime!
  endedAt: DateTime
  state: WorkflowState
}

type IssueStateSpanConnection {
  edges: [IssueStateSpanEdge!]!
  nodes: [IssueStateSpan!]!
  pageInfo: PageInfo!
}

type IssueStateSpanEdge {
  node: IssueStateSpan!
  cursor: String!
}

type IssueSuggestion implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  issue: Issue!
  issueId: String!
  type: IssueSuggestionType!
  state: IssueSuggestionState!
  stateChangedAt: DateTime!
  dismissalReason: String
  metadata: IssueSuggestionMetadata
  suggestedIssue: Issue
  suggestedIssueId: String
  suggestedTeam: Team
  suggestedProject: Project
  suggestedUser: User
  suggestedUserId: String
  suggestedLabel: IssueLabel
  suggestedLabelId: String
}

input IssueSuggestionCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  type: StringComparator
  state: StringComparator
  suggestedUser: NullableUserFilter
  suggestedProject: NullableProjectFilter
  suggestedTeam: NullableTeamFilter
  suggestedLabel: IssueLabelFilter
  and: [IssueSuggestionCollectionFilter!]
  or: [IssueSuggestionCollectionFilter!]
  some: IssueSuggestionFilter
  every: IssueSuggestionFilter
  length: NumberComparator
}

type IssueSuggestionConnection {
  edges: [IssueSuggestionEdge!]!
  nodes: [IssueSuggestion!]!
  pageInfo: PageInfo!
}

type IssueSuggestionEdge {
  node: IssueSuggestion!
  cursor: String!
}

input IssueSuggestionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  type: StringComparator
  state: StringComparator
  suggestedUser: NullableUserFilter
  suggestedProject: NullableProjectFilter
  suggestedTeam: NullableTeamFilter
  suggestedLabel: IssueLabelFilter
  and: [IssueSuggestionFilter!]
  or: [IssueSuggestionFilter!]
}

type IssueSuggestionMetadata {
  score: Float
  classification: String
  reasons: [String!]
  evalLogId: String
  rank: Float
  variant: String
  appliedAutomationRuleId: String
}

enum IssueSuggestionState {
  active
  stale
  accepted
  dismissed
}

enum IssueSuggestionType {
  team
  project
  assignee
  label
  similarIssue
  relatedIssue
}

type IssueTitleSuggestionFromCustomerRequestPayload {
  lastSyncId: Float!
  title: String!
  logId: String
}

type IssueToRelease implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  issue: Issue!
  release: Release!
  pullRequest: PullRequest
}

type IssueToReleaseConnection {
  edges: [IssueToReleaseEdge!]!
  nodes: [IssueToRelease!]!
  pageInfo: PageInfo!
}

input IssueToReleaseCreateInput {
  id: String
  issueId: String!
  releaseId: String!
}

type IssueToReleaseEdge {
  node: IssueToRelease!
  cursor: String!
}

type IssueToReleasePayload {
  lastSyncId: Float!
  issueToRelease: IssueToRelease!
  success: Boolean!
}

input IssueUpdateInput {
  title: String
  description: String
  descriptionData: JSON
  assigneeId: String
  delegateId: String
  parentId: String
  priority: Int
  estimate: Int
  subscriberIds: [String!]
  labelIds: [String!]
  addedLabelIds: [String!]
  removedLabelIds: [String!]
  teamId: String
  cycleId: String
  projectId: String
  projectMilestoneId: String
  lastAppliedTemplateId: String
  stateId: String
  sortOrder: Float
  prioritySortOrder: Float
  subIssueSortOrder: Float
  dueDate: TimelessDate
  trashed: Boolean
  slaBreachesAt: DateTime
  slaStartedAt: DateTime
  snoozedUntilAt: DateTime
  snoozedById: String
  slaType: SLADayCountType
  autoClosedByParentClosing: Boolean
}

scalar JSON

scalar JSONObject

input JiraConfigurationInput {
  accessToken: String!
  email: String!
  hostname: String!
  manualSetup: Boolean
}

input JiraLinearMappingInput {
  jiraProjectId: String!
  linearTeamId: String!
  bidirectional: Boolean
  default: Boolean
}

input JiraPersonalSettingsInput {
  siteName: String
}

input JiraProjectDataInput {
  id: String!
  key: String!
  name: String!
}

input JiraSettingsInput {
  projectMapping: [JiraLinearMappingInput!]
  projects: [JiraProjectDataInput!]!
  isJiraServer: Boolean = false
  setupPending: Boolean
  manualSetup: Boolean
  label: String
  statusNamesPerIssueType: JSONObject
}

input JiraUpdateInput {
  id: String!
  updateProjects: Boolean
  updateMetadata: Boolean
  deleteWebhook: Boolean
  webhookSecret: String
  noSecret: Boolean
  accessToken: String
  email: String
}

input JoinOrganizationInput {
  organizationId: String!
  inviteLink: String
}

input LabelGroupSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
  labelGroupId: String!
}

type LabelNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle
  label: IssueLabel!
  project: Project
  initiative: Initiative
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

input LabelSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input LaunchDarklySettingsInput {
  projectKey: String!
  environment: String!
}

input LinkCountSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type LogoutResponse {
  success: Boolean!
}

input ManualSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input MicrosoftTeamsSettingsInput {
  tenantName: String
}

input MilestoneSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type Mutation {
  fileUpload(metaData: JSON, makePublic: Boolean, size: Int!, contentType: String!, filename: String!): UploadPayload!
  importFileUpload(metaData: JSON, size: Int!, contentType: String!, filename: String!): UploadPayload!
  imageUploadFromUrl(url: String!): ImageUploadFromUrlPayload!
  fileUploadDangerouslyDelete(assetUrl: String!): FileUploadDeletePayload!
  workflowStateCreate(input: WorkflowStateCreateInput!): WorkflowStatePayload!
  workflowStateUpdate(input: WorkflowStateUpdateInput!, id: String!): WorkflowStatePayload!
  workflowStateArchive(id: String!): WorkflowStateArchivePayload!
  webhookCreate(input: WebhookCreateInput!): WebhookPayload!
  webhookUpdate(input: WebhookUpdateInput!, id: String!): WebhookPayload!
  webhookDelete(id: String!): DeletePayload!
  webhookRotateSecret(id: String!): WebhookRotateSecretPayload!
  viewPreferencesCreate(input: ViewPreferencesCreateInput!): ViewPreferencesPayload!
  viewPreferencesUpdate(input: ViewPreferencesUpdateInput!, id: String!): ViewPreferencesPayload!
  viewPreferencesDelete(id: String!): DeletePayload!
  userSettingsUpdate(input: UserSettingsUpdateInput!, id: String!): UserSettingsPayload!
  userSettingsFlagsReset(flags: [UserFlagType!]): UserSettingsFlagsResetPayload!
  userFlagUpdate(operation: UserFlagUpdateOperation!, flag: UserFlagType!): UserSettingsFlagPayload!
  notificationCategoryChannelSubscriptionUpdate(channel: NotificationChannel!, category: NotificationCategory!, subscribe: Boolean!): UserSettingsPayload!
  userUpdate(input: UserUpdateInput!, id: String!): UserPayload!
  userDiscordConnect(redirectUri: String!, code: String!): UserPayload!
  userExternalUserDisconnect(service: String!): UserPayload!
  userChangeRole(role: UserRoleType!, id: String!): UserAdminPayload!
  userSuspend(forceBypassScimRestrictions: Boolean, id: String!): UserAdminPayload!
  userRevokeAllSessions(id: String!): UserAdminPayload!
  userRevokeSession(sessionId: String!, id: String!): UserAdminPayload!
  userUnsuspend(forceBypassScimRestrictions: Boolean, id: String!): UserAdminPayload!
  userUnlinkFromIdentityProvider(id: String!): UserAdminPayload!
  triageResponsibilityCreate(input: TriageResponsibilityCreateInput!): TriageResponsibilityPayload!
  triageResponsibilityUpdate(input: TriageResponsibilityUpdateInput!, id: String!): TriageResponsibilityPayload!
  triageResponsibilityDelete(id: String!): DeletePayload!
  timeScheduleCreate(input: TimeScheduleCreateInput!): TimeSchedulePayload!
  timeScheduleUpdate(input: TimeScheduleUpdateInput!, id: String!): TimeSchedulePayload!
  timeScheduleUpsertExternal(input: TimeScheduleUpdateInput!, externalId: String!): TimeSchedulePayload!
  timeScheduleDelete(id: String!): DeletePayload!
  timeScheduleRefreshIntegrationSchedule(id: String!): TimeSchedulePayload!
  templateCreate(input: TemplateCreateInput!): TemplatePayload!
  templateUpdate(input: TemplateUpdateInput!, id: String!): TemplatePayload!
  templateDelete(id: String!): DeletePayload!
  projectCreate(slackChannelName: String, input: ProjectCreateInput!): ProjectPayload!
  projectUpdate(input: ProjectUpdateInput!, id: String!): ProjectPayload!
  projectReassignStatus(newProjectStatusId: String!, originalProjectStatusId: String!): SuccessPayload!
  projectDelete(id: String!): ProjectArchivePayload!
  projectArchive(trash: Boolean, id: String!): ProjectArchivePayload!
  projectUnarchive(id: String!): ProjectArchivePayload!
  projectAddLabel(labelId: String!, id: String!): ProjectPayload!
  projectRemoveLabel(labelId: String!, id: String!): ProjectPayload!
  projectExternalSyncDisable(syncSource: ExternalSyncService!, projectId: String!): ProjectPayload!
  teamCreate(copySettingsFromTeamId: String, input: TeamCreateInput!): TeamPayload!
  teamUpdate(mapping: InheritanceEntityMapping, input: TeamUpdateInput!, id: String!): TeamPayload!
  teamDelete(id: String!): DeletePayload!
  teamUnarchive(id: String!): TeamArchivePayload!
  teamCyclesDelete(id: String!): TeamPayload!
  teamMembershipCreate(input: TeamMembershipCreateInput!): TeamMembershipPayload!
  teamMembershipUpdate(input: TeamMembershipUpdateInput!, id: String!): TeamMembershipPayload!
  teamMembershipDelete(alsoLeaveParentTeams: Boolean, id: String!): DeletePayload!
  teamKeyDelete(id: String!): DeletePayload!
  roadmapToProjectCreate(input: RoadmapToProjectCreateInput!): RoadmapToProjectPayload!
  roadmapToProjectUpdate(input: RoadmapToProjectUpdateInput!, id: String!): RoadmapToProjectPayload!
  roadmapToProjectDelete(id: String!): DeletePayload!
  roadmapCreate(input: RoadmapCreateInput!): RoadmapPayload!
  roadmapUpdate(input: RoadmapUpdateInput!, id: String!): RoadmapPayload!
  roadmapArchive(id: String!): RoadmapArchivePayload!
  roadmapUnarchive(id: String!): RoadmapArchivePayload!
  roadmapDelete(id: String!): DeletePayload!
  createCsvExportReport(includePrivateTeamIds: [String!]): CreateCsvExportReportPayload!
  releaseStageCreate(input: ReleaseStageCreateInput!): ReleaseStagePayload!
  releaseStageUpdate(input: ReleaseStageUpdateInput!, id: String!): ReleaseStagePayload!
  releaseStageArchive(id: String!): ReleaseStageArchivePayload!
  releaseStageUnarchive(id: String!): ReleaseStageArchivePayload!
  releaseSync(input: ReleaseSyncInput!): ReleasePayload!
  releaseCreate(input: ReleaseCreateInput!): ReleasePayload!
  releaseUpdate(input: ReleaseUpdateInput!, id: String!): ReleasePayload!
  releaseComplete(input: ReleaseCompleteInput!): ReleasePayload!
  releaseUpdateByPipeline(input: ReleaseUpdateByPipelineInput!): ReleasePayload!
  releaseDelete(id: String!): DeletePayload!
  releaseArchive(id: String!): ReleaseArchivePayload!
  releaseUnarchive(id: String!): ReleaseArchivePayload!
  releaseSyncByAccessKey(input: ReleaseSyncInputBase!): ReleasePayload!
  releaseCompleteByAccessKey(input: ReleaseCompleteInputBase!): ReleasePayload!
  releaseUpdateByPipelineByAccessKey(input: ReleaseUpdateByPipelineInputBase!): ReleasePayload!
  releasePipelineCreate(input: ReleasePipelineCreateInput!): ReleasePipelinePayload!
  releasePipelineUpdate(input: ReleasePipelineUpdateInput!, id: String!): ReleasePipelinePayload!
  releasePipelineArchive(id: String!): ReleasePipelineArchivePayload!
  releasePipelineUnarchive(id: String!): ReleasePipelineArchivePayload!
  releasePipelineDelete(id: String!): DeletePayload!
  reactionCreate(input: ReactionCreateInput!): ReactionPayload!
  reactionDelete(id: String!): DeletePayload!
  pushSubscriptionCreate(input: PushSubscriptionCreateInput!): PushSubscriptionPayload!
  pushSubscriptionDelete(id: String!): PushSubscriptionPayload!
  projectUpdateCreate(input: ProjectUpdateCreateInput!): ProjectUpdatePayload!
  projectUpdateUpdate(input: ProjectUpdateUpdateInput!, id: String!): ProjectUpdatePayload!
  projectUpdateArchive(id: String!): ProjectUpdateArchivePayload!
  projectUpdateUnarchive(id: String!): ProjectUpdateArchivePayload!
  projectUpdateDelete(id: String!): DeletePayload!
  createProjectUpdateReminder(userId: String, projectId: String!): ProjectUpdateReminderPayload!
  projectStatusCreate(input: ProjectStatusCreateInput!): ProjectStatusPayload!
  projectStatusUpdate(input: ProjectStatusUpdateInput!, id: String!): ProjectStatusPayload!
  projectStatusArchive(id: String!): ProjectStatusArchivePayload!
  projectStatusUnarchive(id: String!): ProjectStatusArchivePayload!
  projectRelationCreate(input: ProjectRelationCreateInput!): ProjectRelationPayload!
  projectRelationUpdate(input: ProjectRelationUpdateInput!, id: String!): ProjectRelationPayload!
  projectRelationDelete(id: String!): DeletePayload!
  projectMilestoneCreate(input: ProjectMilestoneCreateInput!): ProjectMilestonePayload!
  projectMilestoneUpdate(input: ProjectMilestoneUpdateInput!, id: String!): ProjectMilestonePayload!
  projectMilestoneDelete(id: String!): DeletePayload!
  projectMilestoneMove(input: ProjectMilestoneMoveInput!, id: String!): ProjectMilestoneMovePayload!
  projectLabelCreate(input: ProjectLabelCreateInput!): ProjectLabelPayload!
  projectLabelUpdate(input: ProjectLabelUpdateInput!, id: String!): ProjectLabelPayload!
  projectLabelDelete(id: String!): DeletePayload!
  projectLabelRetire(id: String!): ProjectLabelPayload!
  projectLabelRestore(id: String!): ProjectLabelPayload!
  organizationUpdate(input: OrganizationUpdateInput!): OrganizationPayload!
  organizationDeleteChallenge: OrganizationDeletePayload!
  organizationDelete(input: DeleteOrganizationInput!): OrganizationDeletePayload!
  organizationCancelDelete: OrganizationCancelDeletePayload!
  organizationStartTrialForPlan(input: OrganizationStartTrialInput!): OrganizationStartTrialPayload!
  organizationStartTrial: OrganizationStartTrialPayload!
  organizationInviteCreate(input: OrganizationInviteCreateInput!): OrganizationInvitePayload!
  organizationInviteUpdate(input: OrganizationInviteUpdateInput!, id: String!): OrganizationInvitePayload!
  resendOrganizationInvite(id: String!): DeletePayload!
  resendOrganizationInviteByEmail(email: String!): DeletePayload!
  organizationInviteDelete(id: String!): DeletePayload!
  organizationDomainClaim(id: String!): OrganizationDomainSimplePayload!
  organizationDomainVerify(input: OrganizationDomainVerificationInput!): OrganizationDomainPayload!
  organizationDomainCreate(triggerEmailVerification: Boolean, input: OrganizationDomainCreateInput!): OrganizationDomainPayload!
  organizationDomainUpdate(input: OrganizationDomainUpdateInput!, id: String!): OrganizationDomainPayload!
  organizationDomainDelete(id: String!): DeletePayload!
  notificationSubscriptionCreate(input: NotificationSubscriptionCreateInput!): NotificationSubscriptionPayload!
  notificationSubscriptionUpdate(input: NotificationSubscriptionUpdateInput!, id: String!): NotificationSubscriptionPayload!
  notificationSubscriptionDelete(id: String!): DeletePayload!
  notificationUpdate(input: NotificationUpdateInput!, id: String!): NotificationPayload!
  notificationMarkReadAll(readAt: DateTime!, input: NotificationEntityInput!): NotificationBatchActionPayload!
  notificationMarkUnreadAll(input: NotificationEntityInput!): NotificationBatchActionPayload!
  notificationSnoozeAll(snoozedUntilAt: DateTime!, input: NotificationEntityInput!): NotificationBatchActionPayload!
  notificationUnsnoozeAll(unsnoozedAt: DateTime!, input: NotificationEntityInput!): NotificationBatchActionPayload!
  notificationArchive(id: String!): NotificationArchivePayload!
  notificationArchiveAll(input: NotificationEntityInput!): NotificationBatchActionPayload!
  notificationUnarchive(id: String!): NotificationArchivePayload!
  issueToReleaseCreate(input: IssueToReleaseCreateInput!): IssueToReleasePayload!
  issueToReleaseDeleteByIssueAndRelease(releaseId: String!, issueId: String!): DeletePayload!
  issueToReleaseDelete(id: String!): DeletePayload!
  issueCreate(input: IssueCreateInput!): IssuePayload!
  issueBatchCreate(input: IssueBatchCreateInput!): IssueBatchPayload!
  issueUpdate(input: IssueUpdateInput!, id: String!): IssuePayload!
  issueBatchUpdate(input: IssueUpdateInput!, ids: [UUID!]!): IssueBatchPayload!
  issueArchive(trash: Boolean, id: String!): IssueArchivePayload!
  issueUnarchive(id: String!): IssueArchivePayload!
  issueDelete(permanentlyDelete: Boolean, id: String!): IssueArchivePayload!
  issueAddLabel(labelId: String!, id: String!): IssuePayload!
  issueRemoveLabel(labelId: String!, id: String!): IssuePayload!
  issueReminder(reminderAt: DateTime!, id: String!): IssuePayload!
  issueSubscribe(userEmail: String, userId: String, id: String!): IssuePayload!
  issueUnsubscribe(userEmail: String, userId: String, id: String!): IssuePayload!
  issueDescriptionUpdateFromFront(description: String!, id: String!): IssuePayload!
  issueExternalSyncDisable(attachmentId: String!): IssuePayload!
  issueRelationCreate(overrideCreatedAt: DateTime, input: IssueRelationCreateInput!): IssueRelationPayload!
  issueRelationUpdate(input: IssueRelationUpdateInput!, id: String!): IssueRelationPayload!
  issueRelationDelete(id: String!): DeletePayload!
  issueLabelCreate(replaceTeamLabels: Boolean, input: IssueLabelCreateInput!): IssueLabelPayload!
  issueLabelUpdate(replaceTeamLabels: Boolean, input: IssueLabelUpdateInput!, id: String!): IssueLabelPayload!
  issueLabelDelete(id: String!): DeletePayload!
  issueLabelRetire(id: String!): IssueLabelPayload!
  issueLabelRestore(id: String!): IssueLabelPayload!
  issueImportCreateGithub(teamId: String, teamName: String, githubRepoIds: [Int!], githubLabels: [String!], instantProcess: Boolean, includeClosedIssues: Boolean): IssueImportPayload!
  issueImportCreateJira(teamId: String, teamName: String, jiraToken: String!, jiraProject: String!, jiraEmail: String!, jiraHostname: String!, jql: String, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
  issueImportCreateCSVJira(teamId: String, teamName: String, csvUrl: String!, jiraHostname: String, jiraToken: String, jiraEmail: String): IssueImportPayload!
  issueImportCreateClubhouse(teamId: String, teamName: String, clubhouseToken: String!, clubhouseGroupName: String!, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
  issueImportCreateAsana(teamId: String, teamName: String, asanaToken: String!, asanaTeamName: String!, instantProcess: Boolean, includeClosedIssues: Boolean, id: String): IssueImportPayload!
  issueImportCreateLinearV2(linearSourceOrganizationId: String!, id: String): IssueImportPayload!
  issueImportDelete(issueImportId: String!): IssueImportDeletePayload!
  issueImportProcess(mapping: JSONObject!, issueImportId: String!): IssueImportPayload!
  issueImportUpdate(input: IssueImportUpdateInput!, id: String!): IssueImportPayload!
  integrationsSettingsCreate(input: IntegrationsSettingsCreateInput!): IntegrationsSettingsPayload!
  integrationsSettingsUpdate(input: IntegrationsSettingsUpdateInput!, id: String!): IntegrationsSettingsPayload!
  integrationTemplateCreate(input: IntegrationTemplateCreateInput!): IntegrationTemplatePayload!
  integrationTemplateDelete(id: String!): DeletePayload!
  integrationUpdate(input: IntegrationUpdateInput!, id: String!): IntegrationPayload!
  integrationSettingsUpdate(input: IntegrationSettingsInput!, id: String!): IntegrationPayload!
  integrationGithubCommitCreate: GitHubCommitIntegrationPayload!
  integrationGithubConnect(githubHost: String, codeAccess: Boolean = false, code: String!, installationId: String!): IntegrationPayload!
  integrationGithubImportConnect(code: String!, installationId: String!): IntegrationPayload!
  integrationGithubImportRefresh(id: String!): IntegrationPayload!
  integrationGitHubEnterpriseServerConnect(organizationName: String!, githubUrl: String!): GitHubEnterpriseServerPayload!
  integrationGitlabConnect(gitlabUrl: String!, accessToken: String!): GitLabIntegrationCreatePayload!
  integrationGitlabTestConnection(integrationId: String!): GitLabTestConnectionPayload!
  airbyteIntegrationConnect(input: AirbyteConfigurationInput!): IntegrationPayload!
  integrationGoogleCalendarPersonalConnect(code: String!): IntegrationPayload!
  integrationLaunchDarklyConnect(code: String!, projectKey: String!, environment: String!): IntegrationPayload!
  integrationLaunchDarklyPersonalConnect(code: String!): IntegrationPayload!
  jiraIntegrationConnect(input: JiraConfigurationInput!): IntegrationPayload!
  integrationJiraUpdate(input: JiraUpdateInput!): IntegrationPayload!
  integrationJiraPersonal(code: String, accessToken: String): IntegrationPayload!
  integrationGitHubPersonal(codeAccess: Boolean, code: String!): IntegrationPayload!
  integrationIntercom(domainUrl: String, redirectUri: String!, code: String!): IntegrationPayload!
  integrationIntercomDelete: IntegrationPayload!
  integrationCustomerDataAttributesRefresh(input: IntegrationCustomerDataAttributesRefreshInput!): IntegrationPayload!
  integrationIntercomSettingsUpdate(input: IntercomSettingsInput!): IntegrationPayload!
  integrationDiscord(redirectUri: String!, code: String!): IntegrationPayload!
  integrationOpsgenieConnect(apiKey: String!): IntegrationPayload!
  integrationOpsgenieRefreshScheduleMappings: IntegrationPayload!
  integrationPagerDutyConnect(code: String!, redirectUri: String!): IntegrationPayload!
  integrationPagerDutyRefreshScheduleMappings: IntegrationPayload!
  updateIntegrationSlackScopes(integrationId: String!, redirectUri: String!, code: String!): IntegrationPayload!
  integrationSlack(shouldUseV2Auth: Boolean, redirectUri: String!, code: String!): IntegrationPayload!
  integrationSlackAsks(redirectUri: String!, code: String!): IntegrationPayload!
  integrationSlackOrAsksUpdateSlackTeamName(integrationId: String!): IntegrationSlackWorkspaceNamePayload!
  integrationSlackPersonal(redirectUri: String!, code: String!): IntegrationPayload!
  integrationAsksConnectChannel(redirectUri: String!, code: String!): AsksChannelConnectPayload!
  integrationSlackPost(shouldUseV2Auth: Boolean, redirectUri: String!, teamId: String!, code: String!): SlackChannelConnectPayload!
  integrationSlackProjectPost(service: String!, redirectUri: String!, projectId: String!, code: String!): SlackChannelConnectPayload!
  integrationSlackInitiativePost(redirectUri: String!, initiativeId: String!, code: String!): SlackChannelConnectPayload!
  integrationSlackCustomViewNotifications(redirectUri: String!, customViewId: String!, code: String!): SlackChannelConnectPayload!
  integrationSlackCustomerChannelLink(redirectUri: String!, customerId: String!, code: String!): SuccessPayload!
  integrationSlackOrgProjectUpdatesPost(redirectUri: String!, code: String!): SlackChannelConnectPayload!
  integrationSlackOrgInitiativeUpdatesPost(redirectUri: String!, code: String!): SlackChannelConnectPayload!
  integrationSlackImportEmojis(redirectUri: String!, code: String!): IntegrationPayload!
  integrationFigma(redirectUri: String!, code: String!): IntegrationPayload!
  integrationGong(redirectUri: String!, code: String!): IntegrationPayload!
  integrationMicrosoftTeams(redirectUri: String!, code: String!): IntegrationPayload!
  integrationGoogleSheets(code: String!): IntegrationPayload!
  refreshGoogleSheetsData(type: String, id: String!): IntegrationPayload!
  integrationSentryConnect(organizationSlug: String!, code: String!, installationId: String!): IntegrationPayload!
  integrationFront(redirectUri: String!, code: String!): IntegrationPayload!
  integrationZendesk(subdomain: String!, code: String!, scope: String!, redirectUri: String!): IntegrationPayload!
  integrationLoom: IntegrationPayload!
  integrationSalesforce(code: String!, subdomain: String!, redirectUri: String!): IntegrationPayload!
  integrationSalesforceMetadataRefresh(id: String!): IntegrationPayload!
  integrationMcpServerPersonalConnect(serverUrl: String!): IntegrationPayload!
  integrationMcpServerConnect(teamId: String, serverUrl: String!): IntegrationPayload!
  integrationDelete(skipInstallationDeletion: Boolean, id: String!): DeletePayload!
  integrationArchive(id: String!): DeletePayload!
  integrationSlackWorkflowAccessUpdate(enabled: Boolean!, integrationId: String!): IntegrationPayload!
  integrationRequest(input: IntegrationRequestInput!): IntegrationRequestPayload!
  initiativeUpdateCreate(input: InitiativeUpdateCreateInput!): InitiativeUpdatePayload!
  initiativeUpdateUpdate(input: InitiativeUpdateUpdateInput!, id: String!): InitiativeUpdatePayload!
  initiativeUpdateArchive(id: String!): InitiativeUpdateArchivePayload!
  createInitiativeUpdateReminder(userId: String, initiativeId: String!): InitiativeUpdateReminderPayload!
  initiativeUpdateUnarchive(id: String!): InitiativeUpdateArchivePayload!
  initiativeToProjectCreate(input: InitiativeToProjectCreateInput!): InitiativeToProjectPayload!
  initiativeToProjectUpdate(input: InitiativeToProjectUpdateInput!, id: String!): InitiativeToProjectPayload!
  initiativeToProjectDelete(id: String!): DeletePayload!
  initiativeCreate(input: InitiativeCreateInput!): InitiativePayload!
  initiativeUpdate(input: InitiativeUpdateInput!, id: String!): InitiativePayload!
  initiativeArchive(id: String!): InitiativeArchivePayload!
  initiativeUnarchive(id: String!): InitiativeArchivePayload!
  initiativeDelete(id: String!): DeletePayload!
  initiativeRelationCreate(input: InitiativeRelationCreateInput!): InitiativeRelationPayload!
  initiativeRelationUpdate(input: InitiativeRelationUpdateInput!, id: String!): DeletePayload!
  initiativeRelationDelete(id: String!): DeletePayload!
  gitAutomationTargetBranchCreate(input: GitAutomationTargetBranchCreateInput!): GitAutomationTargetBranchPayload!
  gitAutomationTargetBranchUpdate(input: GitAutomationTargetBranchUpdateInput!, id: String!): GitAutomationTargetBranchPayload!
  gitAutomationTargetBranchDelete(id: String!): DeletePayload!
  gitAutomationStateCreate(input: GitAutomationStateCreateInput!): GitAutomationStatePayload!
  gitAutomationStateUpdate(input: GitAutomationStateUpdateInput!, id: String!): GitAutomationStatePayload!
  gitAutomationStateDelete(id: String!): DeletePayload!
  favoriteCreate(input: FavoriteCreateInput!): FavoritePayload!
  favoriteUpdate(input: FavoriteUpdateInput!, id: String!): FavoritePayload!
  favoriteDelete(id: String!): DeletePayload!
  entityExternalLinkCreate(input: EntityExternalLinkCreateInput!): EntityExternalLinkPayload!
  entityExternalLinkUpdate(input: EntityExternalLinkUpdateInput!, id: String!): EntityExternalLinkPayload!
  entityExternalLinkDelete(id: String!): DeletePayload!
  emojiCreate(input: EmojiCreateInput!): EmojiPayload!
  emojiDelete(id: String!): DeletePayload!
  emailUnsubscribe(input: EmailUnsubscribeInput!): EmailUnsubscribePayload!
  emailIntakeAddressCreate(input: EmailIntakeAddressCreateInput!): EmailIntakeAddressPayload!
  emailIntakeAddressRotate(id: String!): EmailIntakeAddressPayload!
  emailIntakeAddressUpdate(input: EmailIntakeAddressUpdateInput!, id: String!): EmailIntakeAddressPayload!
  emailIntakeAddressDelete(id: String!): DeletePayload!
  documentCreate(input: DocumentCreateInput!): DocumentPayload!
  documentUpdate(input: DocumentUpdateInput!, id: String!): DocumentPayload!
  documentDelete(id: String!): DocumentArchivePayload!
  documentUnarchive(id: String!): DocumentArchivePayload!
  cycleCreate(input: CycleCreateInput!): CyclePayload!
  cycleUpdate(input: CycleUpdateInput!, id: String!): CyclePayload!
  cycleArchive(id: String!): CycleArchivePayload!
  cycleShiftAll(input: CycleShiftAllInput!): CyclePayload!
  cycleStartUpcomingCycleToday(id: String!): CyclePayload!
  customerTierCreate(input: CustomerTierCreateInput!): CustomerTierPayload!
  customerTierUpdate(input: CustomerTierUpdateInput!, id: String!): CustomerTierPayload!
  customerTierDelete(id: String!): DeletePayload!
  customerStatusCreate(input: CustomerStatusCreateInput!): CustomerStatusPayload!
  customerStatusUpdate(input: CustomerStatusUpdateInput!, id: String!): CustomerStatusPayload!
  customerStatusDelete(id: String!): DeletePayload!
  customerCreate(input: CustomerCreateInput!): CustomerPayload!
  customerUpdate(input: CustomerUpdateInput!, id: String!): CustomerPayload!
  customerDelete(id: String!): DeletePayload!
  customerMerge(sourceCustomerId: String!, targetCustomerId: String!): CustomerPayload!
  customerUpsert(input: CustomerUpsertInput!): CustomerPayload!
  customerUnsync(id: String!): CustomerPayload!
  customerNeedCreate(input: CustomerNeedCreateInput!): CustomerNeedPayload!
  customerNeedCreateFromAttachment(input: CustomerNeedCreateFromAttachmentInput!): CustomerNeedPayload!
  customerNeedUpdate(input: CustomerNeedUpdateInput!, id: String!): CustomerNeedUpdatePayload!
  customerNeedDelete(keepAttachment: Boolean, id: String!): DeletePayload!
  customerNeedArchive(id: String!): CustomerNeedArchivePayload!
  customerNeedUnarchive(id: String!): CustomerNeedArchivePayload!
  customViewCreate(input: CustomViewCreateInput!): CustomViewPayload!
  customViewUpdate(input: CustomViewUpdateInput!, id: String!): CustomViewPayload!
  customViewDelete(id: String!): DeletePayload!
  contactCreate(input: ContactCreateInput!): ContactPayload!
  contactSalesCreate(input: ContactSalesCreateInput!): ContactPayload!
  commentCreate(input: CommentCreateInput!): CommentPayload!
  commentUpdate(skipEditedAt: Boolean, input: CommentUpdateInput!, id: String!): CommentPayload!
  commentDelete(id: String!): DeletePayload!
  commentResolve(resolvingCommentId: String, id: String!): CommentPayload!
  commentUnresolve(id: String!): CommentPayload!
  emailUserAccountAuthChallenge(input: EmailUserAccountAuthChallengeInput!): EmailUserAccountAuthChallengeResponse!
  emailTokenUserAccountAuth(input: TokenUserAccountAuthInput!): AuthResolverResponse!
  samlTokenUserAccountAuth(input: TokenUserAccountAuthInput!): AuthResolverResponse!
  googleUserAccountAuth(input: GoogleUserAccountAuthInput!): AuthResolverResponse!
  passkeyLoginStart(authId: String!): PasskeyLoginStartResponse!
  passkeyLoginFinish(response: JSONObject!, authId: String!): AuthResolverResponse!
  createOrganizationFromOnboarding(sessionId: String, survey: OnboardingCustomerSurvey, input: CreateOrganizationInput!): CreateOrJoinOrganizationResponse!
  joinOrganizationFromOnboarding(input: JoinOrganizationInput!): CreateOrJoinOrganizationResponse!
  leaveOrganization(organizationId: String!): CreateOrJoinOrganizationResponse!
  logout(reason: String): LogoutResponse!
  logoutSession(sessionId: String!): LogoutResponse!
  logoutAllSessions(reason: String): LogoutResponse!
  logoutOtherSessions(reason: String): LogoutResponse!
  attachmentCreate(input: AttachmentCreateInput!): AttachmentPayload!
  attachmentUpdate(input: AttachmentUpdateInput!, id: String!): AttachmentPayload!
  attachmentLinkURL(createAsUser: String, displayIconUrl: String, title: String, url: String!, issueId: String!, id: String): AttachmentPayload!
  attachmentLinkGitLabMR(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!, projectPathWithNamespace: String!, number: Float!): AttachmentPayload!
  attachmentLinkGitHubIssue(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!): AttachmentPayload!
  attachmentLinkGitHubPR(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!, linkKind: GitLinkKind): AttachmentPayload!
  attachmentLinkZendesk(createAsUser: String, displayIconUrl: String, title: String, ticketId: String!, issueId: String!, id: String, url: String): AttachmentPayload!
  attachmentLinkDiscord(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, channelId: String!, messageId: String!, url: String!): AttachmentPayload!
  attachmentSyncToSlack(id: String!): AttachmentPayload!
  attachmentLinkSlack(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, url: String!, id: String, syncToCommentThread: Boolean): AttachmentPayload!
  attachmentLinkFront(createAsUser: String, displayIconUrl: String, title: String, conversationId: String!, issueId: String!, id: String): FrontAttachmentPayload!
  attachmentLinkIntercom(createAsUser: String, displayIconUrl: String, title: String, conversationId: String!, partId: String, id: String, issueId: String!): AttachmentPayload!
  attachmentLinkJiraIssue(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, jiraIssueId: String!, id: String, url: String): AttachmentPayload!
  attachmentLinkSalesforce(createAsUser: String, displayIconUrl: String, title: String, issueId: String!, id: String, url: String!): AttachmentPayload!
  attachmentDelete(id: String!): DeletePayload!
  asksWebSettingsCreate(emailIntakeAddress: AsksWebSettingsEmailIntakeAddressInput, input: AsksWebSettingsCreateInput!): AsksWebSettingsPayload!
  asksWebSettingsUpdate(emailIntakeAddress: AsksWebSettingsEmailIntakeAddressInput, input: AsksWebSettingsUpdateInput!, id: String!): AsksWebSettingsPayload!
  asksWebPageCreate(input: AsksWebPageCreateInput!): AsksWebPagePayload!
  asksWebPageUpdate(input: AsksWebPageUpdateInput!, id: String!): AsksWebPagePayload!
  asksWebPageDelete(id: String!): DeletePayload!
  agentSessionCreateOnComment(input: AgentSessionCreateOnComment!): AgentSessionPayload!
  agentSessionCreateOnIssue(input: AgentSessionCreateOnIssue!): AgentSessionPayload!
  agentSessionCreate(input: AgentSessionCreateInput!): AgentSessionPayload!
  agentSessionUpdateExternalUrl(input: AgentSessionUpdateExternalUrlInput!, id: String!): AgentSessionPayload!
  agentSessionUpdate(input: AgentSessionUpdateInput!, id: String!): AgentSessionPayload!
  agentActivityCreate(input: AgentActivityCreateInput!): AgentActivityPayload!
  agentActivityCreatePrompt(input: AgentActivityCreatePromptInput!): AgentActivityPayload!
}

input NameSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

interface Node {
  id: ID!
}

interface Notification {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
}

type NotificationArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Notification
}

type NotificationBatchActionPayload {
  lastSyncId: Float!
  notifications: [Notification!]!
  success: Boolean!
}

enum NotificationCategory {
  assignments
  statusChanges
  commentsAndReplies
  mentions
  reactions
  subscriptions
  documentChanges
  postsAndUpdates
  reminders
  reviews
  appsAndIntegrations
  triage
  customers
  feed
  system
}

type NotificationCategoryPreferences {
  assignments: NotificationChannelPreferences!
  statusChanges: NotificationChannelPreferences!
  commentsAndReplies: NotificationChannelPreferences!
  mentions: NotificationChannelPreferences!
  reactions: NotificationChannelPreferences!
  subscriptions: NotificationChannelPreferences!
  documentChanges: NotificationChannelPreferences!
  postsAndUpdates: NotificationChannelPreferences!
  reminders: NotificationChannelPreferences!
  reviews: NotificationChannelPreferences!
  appsAndIntegrations: NotificationChannelPreferences!
  system: NotificationChannelPreferences!
  triage: NotificationChannelPreferences!
  customers: NotificationChannelPreferences!
  feed: NotificationChannelPreferences!
}

input NotificationCategoryPreferencesInput {
  assignments: PartialNotificationChannelPreferencesInput
  statusChanges: PartialNotificationChannelPreferencesInput
  commentsAndReplies: PartialNotificationChannelPreferencesInput
  mentions: PartialNotificationChannelPreferencesInput
  reactions: PartialNotificationChannelPreferencesInput
  subscriptions: PartialNotificationChannelPreferencesInput
  documentChanges: PartialNotificationChannelPreferencesInput
  postsAndUpdates: PartialNotificationChannelPreferencesInput
  reminders: PartialNotificationChannelPreferencesInput
  reviews: PartialNotificationChannelPreferencesInput
  appsAndIntegrations: PartialNotificationChannelPreferencesInput
  triage: PartialNotificationChannelPreferencesInput
  customers: PartialNotificationChannelPreferencesInput
  feed: PartialNotificationChannelPreferencesInput
}

enum NotificationChannel {
  desktop
  mobile
  email
  slack
}

type NotificationChannelPreferences {
  mobile: Boolean!
  desktop: Boolean!
  email: Boolean!
  slack: Boolean!
}

type NotificationConnection {
  edges: [NotificationEdge!]!
  nodes: [Notification!]!
  pageInfo: PageInfo!
}

type NotificationDeliveryPreferences {
  mobile: NotificationDeliveryPreferencesChannel
}

type NotificationDeliveryPreferencesChannel {
  notificationsDisabled: Boolean
  schedule: NotificationDeliveryPreferencesSchedule
}

input NotificationDeliveryPreferencesChannelInput {
  schedule: NotificationDeliveryPreferencesScheduleInput
}

type NotificationDeliveryPreferencesDay {
  start: String
  end: String
}

input NotificationDeliveryPreferencesDayInput {
  start: String
  end: String
}

input NotificationDeliveryPreferencesInput {
  mobile: NotificationDeliveryPreferencesChannelInput
}

type NotificationDeliveryPreferencesSchedule {
  disabled: Boolean
  sunday: NotificationDeliveryPreferencesDay!
  monday: NotificationDeliveryPreferencesDay!
  tuesday: NotificationDeliveryPreferencesDay!
  wednesday: NotificationDeliveryPreferencesDay!
  thursday: NotificationDeliveryPreferencesDay!
  friday: NotificationDeliveryPreferencesDay!
  saturday: NotificationDeliveryPreferencesDay!
}

input NotificationDeliveryPreferencesScheduleInput {
  disabled: Boolean
  sunday: NotificationDeliveryPreferencesDayInput!
  monday: NotificationDeliveryPreferencesDayInput!
  tuesday: NotificationDeliveryPreferencesDayInput!
  wednesday: NotificationDeliveryPreferencesDayInput!
  thursday: NotificationDeliveryPreferencesDayInput!
  friday: NotificationDeliveryPreferencesDayInput!
  saturday: NotificationDeliveryPreferencesDayInput!
}

type NotificationEdge {
  node: Notification!
  cursor: String!
}

input NotificationEntityInput {
  issueId: String
  projectId: String
  initiativeId: String
  projectUpdateId: String
  initiativeUpdateId: String
  oauthClientApprovalId: String
  id: String
}

input NotificationFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  type: StringComparator
  archivedAt: DateComparator
  and: [NotificationFilter!]
  or: [NotificationFilter!]
}

type NotificationPayload {
  lastSyncId: Float!
  notification: Notification!
  success: Boolean!
}

interface NotificationSubscription {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle
  label: IssueLabel
  project: Project
  initiative: Initiative
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
}

type NotificationSubscriptionConnection {
  edges: [NotificationSubscriptionEdge!]!
  nodes: [NotificationSubscription!]!
  pageInfo: PageInfo!
}

input NotificationSubscriptionCreateInput {
  id: String
  customerId: String
  customViewId: String
  cycleId: String
  initiativeId: String
  labelId: String
  projectId: String
  teamId: String
  userId: String
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  notificationSubscriptionTypes: [String!]
  active: Boolean
}

type NotificationSubscriptionEdge {
  node: NotificationSubscription!
  cursor: String!
}

type NotificationSubscriptionPayload {
  lastSyncId: Float!
  notificationSubscription: NotificationSubscription!
  success: Boolean!
}

input NotificationSubscriptionUpdateInput {
  notificationSubscriptionTypes: [String!]
  active: Boolean
}

input NotificationUpdateInput {
  readAt: DateTime
  snoozedUntilAt: DateTime
  projectUpdateId: String
  initiativeUpdateId: String
}

input NotionSettingsInput {
  workspaceId: String!
  workspaceName: String!
}

input NullableCommentFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  body: StringComparator
  user: UserFilter
  issue: NullableIssueFilter
  projectUpdate: NullableProjectUpdateFilter
  parent: NullableCommentFilter
  documentContent: NullableDocumentContentFilter
  reactions: ReactionCollectionFilter
  needs: CustomerNeedCollectionFilter
  null: Boolean
  and: [NullableCommentFilter!]
  or: [NullableCommentFilter!]
}

input NullableCustomerFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slackChannelId: StringComparator
  domains: StringArrayComparator
  externalIds: StringArrayComparator
  owner: NullableUserFilter
  needs: CustomerNeedCollectionFilter
  revenue: NumberComparator
  size: NumberComparator
  status: CustomerStatusFilter
  tier: CustomerTierFilter
  null: Boolean
  and: [NullableCustomerFilter!]
  or: [NullableCustomerFilter!]
}

input NullableCycleFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  number: NumberComparator
  name: StringComparator
  startsAt: DateComparator
  endsAt: DateComparator
  completedAt: DateComparator
  isActive: BooleanComparator
  isInCooldown: BooleanComparator
  isNext: BooleanComparator
  isPrevious: BooleanComparator
  isFuture: BooleanComparator
  isPast: BooleanComparator
  team: TeamFilter
  issues: IssueCollectionFilter
  inheritedFromId: IDComparator
  null: Boolean
  and: [NullableCycleFilter!]
  or: [NullableCycleFilter!]
}

input NullableDateComparator {
  eq: DateTimeOrDuration
  neq: DateTimeOrDuration
  in: [DateTimeOrDuration!]
  nin: [DateTimeOrDuration!]
  null: Boolean
  lt: DateTimeOrDuration
  lte: DateTimeOrDuration
  gt: DateTimeOrDuration
  gte: DateTimeOrDuration
}

input NullableDocumentContentFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  content: NullableStringComparator
  project: ProjectFilter
  document: DocumentFilter
  null: Boolean
  and: [NullableDocumentContentFilter!]
  or: [NullableDocumentContentFilter!]
}

input NullableDurationComparator {
  eq: Duration
  neq: Duration
  in: [Duration!]
  nin: [Duration!]
  null: Boolean
  lt: Duration
  lte: Duration
  gt: Duration
  gte: Duration
}

input NullableIssueFilter {
  id: IssueIDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  number: NumberComparator
  title: StringComparator
  description: NullableStringComparator
  priority: NullableNumberComparator
  estimate: EstimateComparator
  startedAt: NullableDateComparator
  triagedAt: NullableDateComparator
  completedAt: NullableDateComparator
  canceledAt: NullableDateComparator
  archivedAt: NullableDateComparator
  autoClosedAt: NullableDateComparator
  autoArchivedAt: NullableDateComparator
  addedToCycleAt: NullableDateComparator
  addedToCyclePeriod: CyclePeriodComparator
  dueDate: NullableTimelessDateComparator
  accumulatedStateUpdatedAt: NullableDateComparator
  snoozedUntilAt: NullableDateComparator
  assignee: NullableUserFilter
  delegate: NullableUserFilter
  lastAppliedTemplate: NullableTemplateFilter
  recurringIssueTemplate: NullableTemplateFilter
  sourceMetadata: SourceMetadataComparator
  creator: NullableUserFilter
  parent: NullableIssueFilter
  snoozedBy: NullableUserFilter
  labels: IssueLabelCollectionFilter
  subscribers: UserCollectionFilter
  hasSharedUsers: RelationExistsComparator
  sharedWith: UserCollectionFilter
  team: TeamFilter
  projectMilestone: NullableProjectMilestoneFilter
  comments: CommentCollectionFilter
  activity: ActivityCollectionFilter
  suggestions: IssueSuggestionCollectionFilter
  cycle: NullableCycleFilter
  project: NullableProjectFilter
  state: WorkflowStateFilter
  children: IssueCollectionFilter
  attachments: AttachmentCollectionFilter
  searchableContent: ContentComparator
  hasRelatedRelations: RelationExistsComparator
  hasDuplicateRelations: RelationExistsComparator
  hasBlockedByRelations: RelationExistsComparator
  hasBlockingRelations: RelationExistsComparator
  hasSuggestedRelatedIssues: RelationExistsComparator
  hasSuggestedSimilarIssues: RelationExistsComparator
  hasSuggestedAssignees: RelationExistsComparator
  hasSuggestedProjects: RelationExistsComparator
  hasSuggestedLabels: RelationExistsComparator
  hasSuggestedTeams: RelationExistsComparator
  slaStatus: SlaStatusComparator
  reactions: ReactionCollectionFilter
  needs: CustomerNeedCollectionFilter
  releases: ReleaseCollectionFilter
  customerCount: NumberComparator
  customerImportantCount: NumberComparator
  leadTime: NullableDurationComparator
  cycleTime: NullableDurationComparator
  ageTime: NullableDurationComparator
  triageTime: NullableDurationComparator
  null: Boolean
  and: [NullableIssueFilter!]
  or: [NullableIssueFilter!]
}

input NullableNumberComparator {
  eq: Float
  neq: Float
  in: [Float!]
  nin: [Float!]
  null: Boolean
  lt: Float
  lte: Float
  gt: Float
  gte: Float
}

input NullableProjectFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  state: StringComparator
  status: ProjectStatusFilter
  priority: NullableNumberComparator
  labels: ProjectLabelCollectionFilter
  searchableContent: ContentComparator
  startedAt: NullableDateComparator
  completedAt: NullableDateComparator
  canceledAt: NullableDateComparator
  startDate: NullableDateComparator
  targetDate: NullableDateComparator
  health: StringComparator
  healthWithAge: StringComparator
  activityType: StringComparator
  hasRelatedRelations: RelationExistsComparator
  hasDependedOnByRelations: RelationExistsComparator
  hasDependsOnRelations: RelationExistsComparator
  hasBlockedByRelations: RelationExistsComparator
  hasBlockingRelations: RelationExistsComparator
  hasViolatedRelations: RelationExistsComparator
  projectUpdates: ProjectUpdatesCollectionFilter
  creator: UserFilter
  lead: NullableUserFilter
  members: UserCollectionFilter
  issues: IssueCollectionFilter
  roadmaps: RoadmapCollectionFilter
  initiatives: InitiativeCollectionFilter
  projectMilestones: ProjectMilestoneCollectionFilter
  completedProjectMilestones: ProjectMilestoneCollectionFilter
  nextProjectMilestone: ProjectMilestoneFilter
  accessibleTeams: TeamCollectionFilter
  lastAppliedTemplate: NullableTemplateFilter
  needs: CustomerNeedCollectionFilter
  customerCount: NumberComparator
  customerImportantCount: NumberComparator
  null: Boolean
  and: [NullableProjectFilter!]
  or: [NullableProjectFilter!]
}

input NullableProjectMilestoneFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: NullableStringComparator
  targetDate: NullableDateComparator
  project: NullableProjectFilter
  null: Boolean
  and: [NullableProjectMilestoneFilter!]
  or: [NullableProjectMilestoneFilter!]
}

input NullableProjectUpdateFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  user: UserFilter
  project: ProjectFilter
  reactions: ReactionCollectionFilter
  null: Boolean
  and: [NullableProjectUpdateFilter!]
  or: [NullableProjectUpdateFilter!]
}

input NullableStringComparator {
  eq: String
  neq: String
  in: [String!]
  nin: [String!]
  null: Boolean
  eqIgnoreCase: String
  neqIgnoreCase: String
  startsWith: String
  startsWithIgnoreCase: String
  notStartsWith: String
  endsWith: String
  notEndsWith: String
  contains: String
  containsIgnoreCase: String
  notContains: String
  notContainsIgnoreCase: String
  containsIgnoreCaseAndAccent: String
}

input NullableTeamFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  key: StringComparator
  description: NullableStringComparator
  private: BooleanComparator
  issues: IssueCollectionFilter
  parent: NullableTeamFilter
  null: Boolean
  and: [NullableTeamFilter!]
  or: [NullableTeamFilter!]
}

input NullableTemplateFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  type: StringComparator
  inheritedFromId: IDComparator
  null: Boolean
  and: [NullableTemplateFilter!]
  or: [NullableTemplateFilter!]
}

input NullableTimelessDateComparator {
  eq: TimelessDateOrDuration
  neq: TimelessDateOrDuration
  in: [TimelessDateOrDuration!]
  nin: [TimelessDateOrDuration!]
  null: Boolean
  lt: TimelessDateOrDuration
  lte: TimelessDateOrDuration
  gt: TimelessDateOrDuration
  gte: TimelessDateOrDuration
}

input NullableUserFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  displayName: StringComparator
  email: StringComparator
  active: BooleanComparator
  assignedIssues: IssueCollectionFilter
  admin: BooleanComparator
  owner: BooleanComparator
  invited: BooleanComparator
  isInvited: BooleanComparator
  app: BooleanComparator
  isMe: BooleanComparator
  null: Boolean
  and: [NullableUserFilter!]
  or: [NullableUserFilter!]
}

input NumberComparator {
  eq: Float
  neq: Float
  in: [Float!]
  nin: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
}

enum OAuthClientApprovalStatus {
  requested
  approved
  denied
}

type OauthClientApproval implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  oauthClientId: String!
  requesterId: String!
  responderId: String
  status: OAuthClientApprovalStatus!
  scopes: [String!]!
  requestReason: String
  denyReason: String
  newlyRequestedScopes: [String!]
}

type OauthClientApprovalNotification implements Notification & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  oauthClientApprovalId: String!
  oauthClientApproval: OauthClientApproval!
}

input OnboardingCustomerSurvey {
  companyRole: String
  companySize: String
}

input OpsgenieInput {
  apiFailedWithUnauthorizedErrorAt: DateTime
}

type Organization implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  urlKey: String!
  logoUrl: String
  periodUploadVolume: Float!
  facets: [Facet!]!
  gitBranchFormat: String
  gitLinkbackMessagesEnabled: Boolean!
  gitPublicLinkbackMessagesEnabled: Boolean!
  gitLinkbackDescriptionsEnabled: Boolean!
  roadmapEnabled: Boolean!
  projectUpdateReminderFrequencyInWeeks: Float
  projectUpdateRemindersDay: Day!
  projectUpdateRemindersHour: Float!
  initiativeUpdateReminderFrequencyInWeeks: Float
  initiativeUpdateRemindersDay: Day!
  initiativeUpdateRemindersHour: Float!
  fiscalYearStartMonth: Float!
  workingDays: [Float!]!
  samlEnabled: Boolean!
  samlSettings: JSONObject
  scimEnabled: Boolean!
  scimSettings: JSONObject
  securitySettings: JSONObject!
  allowedAuthServices: [String!]!
  allowedFileUploadContentTypes: [String!]
  ipRestrictions: [OrganizationIpRestriction!]
  deletionRequestedAt: DateTime
  trialEndsAt: DateTime
  trialStartsAt: DateTime
  previousUrlKeys: [String!]!
  hipaaComplianceEnabled: Boolean!
  themeSettings: JSONObject
  releaseChannel: ReleaseChannel!
  customersConfiguration: JSONObject!
  codeIntelligenceEnabled: Boolean!
  codeIntelligenceRepository: String
  defaultFeedSummarySchedule: FeedSummarySchedule
  feedEnabled: Boolean!
  hideNonPrimaryOrganizations: Boolean!
  aiAddonEnabled: Boolean!
  generatedUpdatesEnabled: Boolean!
  aiThreadSummariesEnabled: Boolean!
  aiDiscussionSummariesEnabled: Boolean!
  aiProviderConfiguration: JSONObject
  linearAgentEnabled: Boolean!
  slaDayCount: SLADayCountType!
  projectUpdatesReminderFrequency: ProjectUpdateReminderFrequency!
  allowedAiProviders: [String!]!
  users(includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
  teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
  projectStatuses: [ProjectStatus!]!
  integrations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IntegrationConnection!
  slackProjectChannelIntegration: Integration
  slackProjectChannelPrefix: String!
  subscription: PaidSubscription
  userCount: Int!
  createdIssueCount: Int!
  templates(filter: NullableTemplateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TemplateConnection!
  labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
  projectLabels(filter: ProjectLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLabelConnection!
  customerCount: Int!
  customersEnabled: Boolean!
  allowMembersToInvite: Boolean
  restrictTeamCreationToAdmins: Boolean
  restrictLabelManagementToAdmins: Boolean
}

type OrganizationAcceptedOrExpiredInviteDetailsPayload {
  status: OrganizationInviteStatus!
}

type OrganizationCancelDeletePayload {
  success: Boolean!
}

type OrganizationDeletePayload {
  success: Boolean!
}

type OrganizationDomain implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  identityProvider: IdentityProvider
  name: String!
  verified: Boolean!
  verificationEmail: String
  creator: User
  authType: OrganizationDomainAuthType!
  claimed: Boolean
  disableOrganizationCreation: Boolean
}

enum OrganizationDomainAuthType {
  saml
  general
}

type OrganizationDomainClaimPayload {
  verificationString: String!
}

input OrganizationDomainCreateInput {
  id: String
  identityProviderId: String
  name: String!
  verificationEmail: String
  authType: String = "general"
}

type OrganizationDomainPayload {
  lastSyncId: Float!
  organizationDomain: OrganizationDomain!
  success: Boolean!
}

type OrganizationDomainSimplePayload {
  success: Boolean!
}

input OrganizationDomainUpdateInput {
  disableOrganizationCreation: Boolean
}

input OrganizationDomainVerificationInput {
  organizationDomainId: String!
  verificationCode: String!
}

type OrganizationExistsPayload {
  success: Boolean!
  exists: Boolean!
}

type OrganizationInvite implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  email: String!
  role: UserRoleType!
  external: Boolean!
  acceptedAt: DateTime
  expiresAt: DateTime
  metadata: JSONObject
  inviter: User!
  invitee: User
  organization: Organization!
}

type OrganizationInviteConnection {
  edges: [OrganizationInviteEdge!]!
  nodes: [OrganizationInvite!]!
  pageInfo: PageInfo!
}

input OrganizationInviteCreateInput {
  id: String
  email: String!
  role: UserRoleType = user
  teamIds: [String!]
  metadata: JSONObject
}

union OrganizationInviteDetailsPayload = OrganizationInviteFullDetailsPayload | OrganizationAcceptedOrExpiredInviteDetailsPayload

type OrganizationInviteEdge {
  node: OrganizationInvite!
  cursor: String!
}

type OrganizationInviteFullDetailsPayload {
  status: OrganizationInviteStatus!
  inviter: String!
  email: String!
  role: UserRoleType!
  createdAt: DateTime!
  organizationName: String!
  organizationId: String!
  organizationLogoUrl: String
  accepted: Boolean!
  expired: Boolean!
  allowedAuthServices: [String!]!
}

type OrganizationInvitePayload {
  lastSyncId: Float!
  organizationInvite: OrganizationInvite!
  success: Boolean!
}

enum OrganizationInviteStatus {
  pending
  accepted
  expired
}

input OrganizationInviteUpdateInput {
  teamIds: [String!]!
}

type OrganizationIpRestriction {
  range: String!
  type: String!
  description: String
  enabled: Boolean!
}

input OrganizationIpRestrictionInput {
  range: String!
  type: String!
  description: String
  enabled: Boolean!
}

type OrganizationMeta {
  region: String!
  allowedAuthServices: [String!]!
}

type OrganizationPayload {
  lastSyncId: Float!
  organization: Organization
  success: Boolean!
}

input OrganizationSecuritySettingsInput {
  personalApiKeysRole: UserRoleType
  invitationsRole: UserRoleType
  teamCreationRole: UserRoleType
  labelManagementRole: UserRoleType
  apiSettingsRole: UserRoleType
  templateManagementRole: UserRoleType
  importRole: UserRoleType
  agentGuidanceRole: UserRoleType
  integrationCreationRole: UserRoleType
}

input OrganizationStartTrialInput {
  planType: String!
}

type OrganizationStartTrialPayload {
  success: Boolean!
}

input OrganizationUpdateInput {
  name: String
  logoUrl: String
  urlKey: String
  gitBranchFormat: String
  gitLinkbackMessagesEnabled: Boolean
  gitPublicLinkbackMessagesEnabled: Boolean
  gitLinkbackDescriptionsEnabled: Boolean
  roadmapEnabled: Boolean
  projectUpdateReminderFrequencyInWeeks: Float
  projectUpdateRemindersDay: Day
  projectUpdateRemindersHour: Float
  initiativeUpdateReminderFrequencyInWeeks: Float
  initiativeUpdateRemindersDay: Day
  initiativeUpdateRemindersHour: Float
  fiscalYearStartMonth: Float
  workingDays: [Float!]
  reducedPersonalInformation: Boolean
  oauthAppReview: Boolean
  allowedAuthServices: [String!]
  slaEnabled: Boolean
  restrictAgentInvocationToMembers: Boolean
  ipRestrictions: [OrganizationIpRestrictionInput!]
  allowedFileUploadContentTypes: [String!]
  themeSettings: JSONObject
  customersEnabled: Boolean
  customersConfiguration: JSONObject
  codeIntelligenceEnabled: Boolean
  codeIntelligenceRepository: String
  feedEnabled: Boolean
  hideNonPrimaryOrganizations: Boolean
  defaultFeedSummarySchedule: FeedSummarySchedule
  aiAddonEnabled: Boolean
  generatedUpdatesEnabled: Boolean
  aiTelemetryEnabled: Boolean
  aiDiscussionSummariesEnabled: Boolean
  aiThreadSummariesEnabled: Boolean
  hipaaComplianceEnabled: Boolean
  securitySettings: OrganizationSecuritySettingsInput
  aiProviderConfiguration: JSONObject
  slackProjectChannelIntegrationId: String
  slackProjectChannelPrefix: String
  linearAgentEnabled: Boolean
}

input OwnerSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String
  endCursor: String
}

input PagerDutyInput {
  apiFailedWithUnauthorizedErrorAt: DateTime
}

enum PaginationNulls {
  first
  last
}

enum PaginationOrderBy {
  createdAt
  updatedAt
}

enum PaginationSortOrder {
  Ascending
  Descending
}

type PaidSubscription implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  seats: Float!
  seatsMinimum: Float
  seatsMaximum: Float
  creator: User
  organization: Organization!
  collectionMethod: String!
  canceledAt: DateTime
  cancelAt: DateTime
  pendingChangeType: String
  nextBillingAt: DateTime
}

input PartialNotificationChannelPreferencesInput {
  mobile: Boolean
  desktop: Boolean
  email: Boolean
  slack: Boolean
}

type PasskeyLoginStartResponse {
  success: Boolean!
  options: JSONObject!
}

type Post implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  body: String!
  bodyData: String!
  writtenSummaryData: JSONObject
  audioSummary: String
  title: String
  slugId: String!
  creator: User
  editedAt: DateTime
  reactionData: JSONObject!
  ttlUrl: String
  user: User
  team: Team
  type: PostType
  evalLogId: String
  feedSummaryScheduleAtCreate: FeedSummarySchedule
}

type PostNotification implements Notification & Entity & Node {
  commentId: String
  parentCommentId: String
  reactionEmoji: String
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  postId: String!
}

enum PostType {
  summary
  update
}

input PrioritySort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
  noPriorityFirst: Boolean = false
}

enum ProductIntelligenceScope {
  workspace
  teamHierarchy
  team
  none
}

type Project implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  updateReminderFrequencyInWeeks: Float
  updateReminderFrequency: Float
  frequencyResolution: FrequencyResolutionType!
  updateRemindersDay: Day
  updateRemindersHour: Float
  name: String!
  description: String!
  slugId: String!
  icon: String
  color: String!
  status: ProjectStatus!
  creator: User
  lead: User
  facets: [Facet!]!
  projectUpdateRemindersPausedUntilAt: DateTime
  startDate: TimelessDate
  startDateResolution: DateResolutionType
  targetDate: TimelessDate
  targetDateResolution: DateResolutionType
  startedAt: DateTime
  completedAt: DateTime
  canceledAt: DateTime
  autoArchivedAt: DateTime
  trashed: Boolean
  sortOrder: Float!
  prioritySortOrder: Float!
  convertedFromIssue: Issue
  lastAppliedTemplate: Template
  priority: Int!
  lastUpdate: ProjectUpdate
  health: ProjectUpdateHealthType
  healthUpdatedAt: DateTime
  issueCountHistory: [Float!]!
  completedIssueCountHistory: [Float!]!
  scopeHistory: [Float!]!
  completedScopeHistory: [Float!]!
  inProgressScopeHistory: [Float!]!
  progressHistory: JSONObject!
  currentProgress: JSONObject!
  slackNewIssue: Boolean!
  slackIssueComments: Boolean!
  slackIssueStatuses: Boolean!
  labelIds: [String!]!
  favorite: Favorite
  url: String!
  initiatives(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeConnection!
  initiativeToProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeToProjectConnection!
  teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
  members(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
  projectUpdates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateConnection!
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  projectMilestones(filter: ProjectMilestoneFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectMilestoneConnection!
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  externalLinks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EntityExternalLinkConnection!
  attachments(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectAttachmentConnection!
  history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectHistoryConnection!
  labels(filter: ProjectLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLabelConnection!
  progress: Float!
  scope: Float!
  integrationsSettings: IntegrationsSettings
  content: String
  contentState: String
  documentContent: DocumentContent
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  relations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectRelationConnection!
  inverseRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectRelationConnection!
  needs(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  state: String!
  priorityLabel: String!
}

type ProjectArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Project
}

type ProjectAttachment implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  title: String!
  subtitle: String
  url: String!
  creator: User
  metadata: JSONObject!
  source: JSONObject
  sourceType: String
}

type ProjectAttachmentConnection {
  edges: [ProjectAttachmentEdge!]!
  nodes: [ProjectAttachment!]!
  pageInfo: PageInfo!
}

type ProjectAttachmentEdge {
  node: ProjectAttachment!
  cursor: String!
}

input ProjectCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  state: StringComparator
  status: ProjectStatusFilter
  priority: NullableNumberComparator
  labels: ProjectLabelCollectionFilter
  searchableContent: ContentComparator
  startedAt: NullableDateComparator
  completedAt: NullableDateComparator
  canceledAt: NullableDateComparator
  startDate: NullableDateComparator
  targetDate: NullableDateComparator
  health: StringComparator
  healthWithAge: StringComparator
  activityType: StringComparator
  hasRelatedRelations: RelationExistsComparator
  hasDependedOnByRelations: RelationExistsComparator
  hasDependsOnRelations: RelationExistsComparator
  hasBlockedByRelations: RelationExistsComparator
  hasBlockingRelations: RelationExistsComparator
  hasViolatedRelations: RelationExistsComparator
  projectUpdates: ProjectUpdatesCollectionFilter
  creator: UserFilter
  lead: NullableUserFilter
  members: UserCollectionFilter
  issues: IssueCollectionFilter
  roadmaps: RoadmapCollectionFilter
  initiatives: InitiativeCollectionFilter
  projectMilestones: ProjectMilestoneCollectionFilter
  completedProjectMilestones: ProjectMilestoneCollectionFilter
  nextProjectMilestone: ProjectMilestoneFilter
  accessibleTeams: TeamCollectionFilter
  lastAppliedTemplate: NullableTemplateFilter
  needs: CustomerNeedCollectionFilter
  customerCount: NumberComparator
  customerImportantCount: NumberComparator
  and: [ProjectCollectionFilter!]
  or: [ProjectCollectionFilter!]
  some: ProjectFilter
  every: ProjectFilter
  length: NumberComparator
}

type ProjectConnection {
  edges: [ProjectEdge!]!
  nodes: [Project!]!
  pageInfo: PageInfo!
}

input ProjectCreateInput {
  id: String
  name: String!
  icon: String
  color: String
  statusId: String
  description: String
  content: String
  teamIds: [String!]!
  convertedFromIssueId: String
  lastAppliedTemplateId: String
  templateId: String
  useDefaultTemplate: Boolean
  leadId: String
  memberIds: [String!]
  startDate: TimelessDate
  startDateResolution: DateResolutionType
  targetDate: TimelessDate
  targetDateResolution: DateResolutionType
  sortOrder: Float
  prioritySortOrder: Float
  priority: Int
  labelIds: [String!]
}

input ProjectCreatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

input ProjectFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  state: StringComparator
  status: ProjectStatusFilter
  priority: NullableNumberComparator
  labels: ProjectLabelCollectionFilter
  searchableContent: ContentComparator
  startedAt: NullableDateComparator
  completedAt: NullableDateComparator
  canceledAt: NullableDateComparator
  startDate: NullableDateComparator
  targetDate: NullableDateComparator
  health: StringComparator
  healthWithAge: StringComparator
  activityType: StringComparator
  hasRelatedRelations: RelationExistsComparator
  hasDependedOnByRelations: RelationExistsComparator
  hasDependsOnRelations: RelationExistsComparator
  hasBlockedByRelations: RelationExistsComparator
  hasBlockingRelations: RelationExistsComparator
  hasViolatedRelations: RelationExistsComparator
  projectUpdates: ProjectUpdatesCollectionFilter
  creator: UserFilter
  lead: NullableUserFilter
  members: UserCollectionFilter
  issues: IssueCollectionFilter
  roadmaps: RoadmapCollectionFilter
  initiatives: InitiativeCollectionFilter
  projectMilestones: ProjectMilestoneCollectionFilter
  completedProjectMilestones: ProjectMilestoneCollectionFilter
  nextProjectMilestone: ProjectMilestoneFilter
  accessibleTeams: TeamCollectionFilter
  lastAppliedTemplate: NullableTemplateFilter
  needs: CustomerNeedCollectionFilter
  customerCount: NumberComparator
  customerImportantCount: NumberComparator
  and: [ProjectFilter!]
  or: [ProjectFilter!]
}

type ProjectFilterSuggestionPayload {
  filter: JSONObject
  logId: String
}

input ProjectHealthSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type ProjectHistory implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  entries: JSONObject!
  project: Project!
}

type ProjectHistoryConnection {
  edges: [ProjectHistoryEdge!]!
  nodes: [ProjectHistory!]!
  pageInfo: PageInfo!
}

type ProjectHistoryEdge {
  node: ProjectHistory!
  cursor: String!
}

type ProjectLabel implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  description: String
  color: String!
  isGroup: Boolean!
  lastAppliedAt: DateTime
  retiredAt: DateTime
  organization: Organization!
  creator: User
  retiredBy: User
  parent: ProjectLabel
  projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [ProjectSortInput!]): ProjectConnection!
  children(filter: ProjectLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLabelConnection!
}

input ProjectLabelCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  isGroup: BooleanComparator
  creator: NullableUserFilter
  parent: ProjectLabelFilter
  null: Boolean
  and: [ProjectLabelCollectionFilter!]
  or: [ProjectLabelCollectionFilter!]
  some: ProjectLabelCollectionFilter
  every: ProjectLabelFilter
  length: NumberComparator
}

type ProjectLabelConnection {
  edges: [ProjectLabelEdge!]!
  nodes: [ProjectLabel!]!
  pageInfo: PageInfo!
}

input ProjectLabelCreateInput {
  id: String
  name: String!
  description: String
  color: String
  parentId: String
  isGroup: Boolean
  retiredAt: DateTime
}

type ProjectLabelEdge {
  node: ProjectLabel!
  cursor: String!
}

input ProjectLabelFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  isGroup: BooleanComparator
  creator: NullableUserFilter
  parent: ProjectLabelFilter
  and: [ProjectLabelFilter!]
  or: [ProjectLabelFilter!]
}

type ProjectLabelPayload {
  lastSyncId: Float!
  projectLabel: ProjectLabel!
  success: Boolean!
}

input ProjectLabelUpdateInput {
  name: String
  description: String
  parentId: String
  color: String
  isGroup: Boolean
  retiredAt: DateTime
}

input ProjectLeadSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input ProjectManualSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type ProjectMilestone implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  documentContent: DocumentContent
  targetDate: TimelessDate
  project: Project!
  progressHistory: JSONObject!
  currentProgress: JSONObject!
  sortOrder: Float!
  description: String
  status: ProjectMilestoneStatus!
  progress: Float!
  descriptionState: String
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
}

input ProjectMilestoneCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: NullableStringComparator
  targetDate: NullableDateComparator
  project: NullableProjectFilter
  and: [ProjectMilestoneCollectionFilter!]
  or: [ProjectMilestoneCollectionFilter!]
  some: ProjectMilestoneFilter
  every: ProjectMilestoneFilter
  length: NumberComparator
}

type ProjectMilestoneConnection {
  edges: [ProjectMilestoneEdge!]!
  nodes: [ProjectMilestone!]!
  pageInfo: PageInfo!
}

input ProjectMilestoneCreateInput {
  id: String
  name: String!
  description: String
  descriptionData: JSONObject
  targetDate: TimelessDate
  projectId: String!
  sortOrder: Float
}

type ProjectMilestoneEdge {
  node: ProjectMilestone!
  cursor: String!
}

input ProjectMilestoneFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: NullableStringComparator
  targetDate: NullableDateComparator
  project: NullableProjectFilter
  and: [ProjectMilestoneFilter!]
  or: [ProjectMilestoneFilter!]
}

input ProjectMilestoneMoveInput {
  projectId: String!
  newIssueTeamId: String
  addIssueTeamToProject: Boolean
  undoIssueTeamIds: [ProjectMilestoneMoveIssueToTeamInput!]
  undoProjectTeamIds: ProjectMilestoneMoveProjectTeamsInput
}

type ProjectMilestoneMoveIssueToTeam {
  issueId: String!
  teamId: String!
}

input ProjectMilestoneMoveIssueToTeamInput {
  issueId: String!
  teamId: String!
}

type ProjectMilestoneMovePayload {
  lastSyncId: Float!
  projectMilestone: ProjectMilestone!
  success: Boolean!
  previousIssueTeamIds: [ProjectMilestoneMoveIssueToTeam!]
  previousProjectTeamIds: ProjectMilestoneMoveProjectTeams
}

type ProjectMilestoneMoveProjectTeams {
  projectId: String!
  teamIds: [String!]!
}

input ProjectMilestoneMoveProjectTeamsInput {
  projectId: String!
  teamIds: [String!]!
}

type ProjectMilestonePayload {
  lastSyncId: Float!
  projectMilestone: ProjectMilestone!
  success: Boolean!
}

enum ProjectMilestoneStatus {
  unstarted
  next
  overdue
  done
}

input ProjectMilestoneUpdateInput {
  name: String
  description: String
  descriptionData: JSONObject
  targetDate: TimelessDate
  sortOrder: Float
  projectId: String
}

input ProjectNameSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type ProjectNotification implements Notification & Entity & Node {
  commentId: String
  parentCommentId: String
  reactionEmoji: String
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  projectId: String!
  projectMilestoneId: String
  projectUpdateId: String
  project: Project!
  document: Document
  projectUpdate: ProjectUpdate
  comment: Comment
  parentComment: Comment
}

type ProjectNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle
  label: IssueLabel
  project: Project!
  initiative: Initiative
  team: Team
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

type ProjectPayload {
  lastSyncId: Float!
  project: Project
  success: Boolean!
}

input ProjectPrioritySort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
  noPriorityFirst: Boolean = false
}

type ProjectRelation implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  project: Project!
  projectMilestone: ProjectMilestone
  anchorType: String!
  relatedProject: Project!
  relatedProjectMilestone: ProjectMilestone
  relatedAnchorType: String!
  user: User
}

type ProjectRelationConnection {
  edges: [ProjectRelationEdge!]!
  nodes: [ProjectRelation!]!
  pageInfo: PageInfo!
}

input ProjectRelationCreateInput {
  id: String
  type: String!
  projectId: String!
  projectMilestoneId: String
  anchorType: String!
  relatedProjectId: String!
  relatedProjectMilestoneId: String
  relatedAnchorType: String!
}

type ProjectRelationEdge {
  node: ProjectRelation!
  cursor: String!
}

type ProjectRelationPayload {
  lastSyncId: Float!
  projectRelation: ProjectRelation!
  success: Boolean!
}

input ProjectRelationUpdateInput {
  type: String
  projectId: String
  projectMilestoneId: String
  anchorType: String
  relatedProjectId: String
  relatedProjectMilestoneId: String
  relatedAnchorType: String
}

type ProjectSearchPayload {
  edges: [ProjectSearchResultEdge!]!
  nodes: [ProjectSearchResult!]!
  pageInfo: PageInfo!
  archivePayload: ArchiveResponse!
  totalCount: Float!
}

type ProjectSearchResult implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  updateReminderFrequencyInWeeks: Float
  updateReminderFrequency: Float
  frequencyResolution: FrequencyResolutionType!
  updateRemindersDay: Day
  updateRemindersHour: Float
  name: String!
  description: String!
  slugId: String!
  icon: String
  color: String!
  status: ProjectStatus!
  creator: User
  lead: User
  facets: [Facet!]!
  projectUpdateRemindersPausedUntilAt: DateTime
  startDate: TimelessDate
  startDateResolution: DateResolutionType
  targetDate: TimelessDate
  targetDateResolution: DateResolutionType
  startedAt: DateTime
  completedAt: DateTime
  canceledAt: DateTime
  autoArchivedAt: DateTime
  trashed: Boolean
  sortOrder: Float!
  prioritySortOrder: Float!
  convertedFromIssue: Issue
  lastAppliedTemplate: Template
  priority: Int!
  lastUpdate: ProjectUpdate
  health: ProjectUpdateHealthType
  healthUpdatedAt: DateTime
  issueCountHistory: [Float!]!
  completedIssueCountHistory: [Float!]!
  scopeHistory: [Float!]!
  completedScopeHistory: [Float!]!
  inProgressScopeHistory: [Float!]!
  progressHistory: JSONObject!
  currentProgress: JSONObject!
  slackNewIssue: Boolean!
  slackIssueComments: Boolean!
  slackIssueStatuses: Boolean!
  labelIds: [String!]!
  favorite: Favorite
  url: String!
  initiatives(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeConnection!
  initiativeToProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeToProjectConnection!
  teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
  members(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
  projectUpdates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateConnection!
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  projectMilestones(filter: ProjectMilestoneFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectMilestoneConnection!
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  externalLinks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EntityExternalLinkConnection!
  attachments(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectAttachmentConnection!
  history(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectHistoryConnection!
  labels(filter: ProjectLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLabelConnection!
  progress: Float!
  scope: Float!
  integrationsSettings: IntegrationsSettings
  content: String
  contentState: String
  documentContent: DocumentContent
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  relations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectRelationConnection!
  inverseRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectRelationConnection!
  needs(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  state: String!
  priorityLabel: String!
  metadata: JSONObject!
}

type ProjectSearchResultEdge {
  node: ProjectSearchResult!
  cursor: String!
}

input ProjectSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input ProjectSortInput {
  name: ProjectNameSort
  status: ProjectStatusSort
  priority: ProjectPrioritySort
  manual: ProjectManualSort
  targetDate: TargetDateSort
  startDate: StartDateSort
  createdAt: ProjectCreatedAtSort
  updatedAt: ProjectUpdatedAtSort
  health: ProjectHealthSort
  lead: ProjectLeadSort
}

type ProjectStatus implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  color: String!
  description: String
  position: Float!
  type: ProjectStatusType!
  indefinite: Boolean!
}

type ProjectStatusArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: ProjectStatus
}

type ProjectStatusConnection {
  edges: [ProjectStatusEdge!]!
  nodes: [ProjectStatus!]!
  pageInfo: PageInfo!
}

type ProjectStatusCountPayload {
  count: Float!
  privateCount: Float!
  archivedTeamCount: Float!
}

input ProjectStatusCreateInput {
  id: String
  name: String!
  color: String!
  description: String
  position: Float!
  type: ProjectStatusType!
  indefinite: Boolean = false
}

type ProjectStatusEdge {
  node: ProjectStatus!
  cursor: String!
}

input ProjectStatusFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  description: StringComparator
  position: NumberComparator
  type: StringComparator
  projects: ProjectCollectionFilter
  and: [ProjectStatusFilter!]
  or: [ProjectStatusFilter!]
}

type ProjectStatusPayload {
  lastSyncId: Float!
  status: ProjectStatus!
  success: Boolean!
}

input ProjectStatusSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

enum ProjectStatusType {
  backlog
  planned
  started
  paused
  completed
  canceled
}

input ProjectStatusUpdateInput {
  name: String
  color: String
  description: String
  position: Float
  type: ProjectStatusType
  indefinite: Boolean
}

enum ProjectTab {
  customers
  documents
  issues
  updates
}

type ProjectUpdate implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  body: String!
  editedAt: DateTime
  reactionData: JSONObject!
  bodyData: String!
  slugId: String!
  project: Project!
  health: ProjectUpdateHealthType!
  user: User!
  infoSnapshot: JSONObject
  isDiffHidden: Boolean!
  url: String!
  isStale: Boolean!
  diff: JSONObject
  diffMarkdown: String
  reactions: [Reaction!]!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  commentCount: Int!
}

type ProjectUpdateArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: ProjectUpdate
}

type ProjectUpdateConnection {
  edges: [ProjectUpdateEdge!]!
  nodes: [ProjectUpdate!]!
  pageInfo: PageInfo!
}

input ProjectUpdateCreateInput {
  id: String
  body: String
  bodyData: JSON
  projectId: String!
  health: ProjectUpdateHealthType
  isDiffHidden: Boolean
}

type ProjectUpdateEdge {
  node: ProjectUpdate!
  cursor: String!
}

input ProjectUpdateFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  user: UserFilter
  project: ProjectFilter
  reactions: ReactionCollectionFilter
  and: [ProjectUpdateFilter!]
  or: [ProjectUpdateFilter!]
}

enum ProjectUpdateHealthType {
  onTrack
  atRisk
  offTrack
}

input ProjectUpdateInput {
  statusId: String
  name: String
  description: String
  content: String
  convertedFromIssueId: String
  lastAppliedTemplateId: String
  icon: String
  color: String
  teamIds: [String!]
  projectUpdateRemindersPausedUntilAt: DateTime
  updateReminderFrequencyInWeeks: Float
  updateReminderFrequency: Float
  frequencyResolution: FrequencyResolutionType
  updateRemindersDay: Day
  updateRemindersHour: Int
  leadId: String
  memberIds: [String!]
  startDate: TimelessDate
  startDateResolution: DateResolutionType
  targetDate: TimelessDate
  targetDateResolution: DateResolutionType
  completedAt: DateTime
  canceledAt: DateTime
  slackNewIssue: Boolean
  slackIssueComments: Boolean
  slackIssueStatuses: Boolean
  sortOrder: Float
  prioritySortOrder: Float
  trashed: Boolean
  priority: Int
  labelIds: [String!]
}

type ProjectUpdatePayload {
  lastSyncId: Float!
  projectUpdate: ProjectUpdate!
  success: Boolean!
}

enum ProjectUpdateReminderFrequency {
  week
  twoWeeks
  month
  never
}

type ProjectUpdateReminderPayload {
  lastSyncId: Float!
  success: Boolean!
}

input ProjectUpdateUpdateInput {
  body: String
  bodyData: JSON
  health: ProjectUpdateHealthType
  isDiffHidden: Boolean
}

input ProjectUpdatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input ProjectUpdatesCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  health: StringComparator
  and: [ProjectUpdatesCollectionFilter!]
  or: [ProjectUpdatesCollectionFilter!]
  some: ProjectUpdatesFilter
  every: ProjectUpdatesFilter
  length: NumberComparator
}

input ProjectUpdatesFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  health: StringComparator
  and: [ProjectUpdatesFilter!]
  or: [ProjectUpdatesFilter!]
}

type PullRequest implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  slugId: String!
  title: String!
  number: Float!
  sourceBranch: String!
  targetBranch: String!
  url: String!
  status: PullRequestStatus!
  mergeSettings: PullRequestMergeSettings
  mergeCommit: PullRequestCommit
  checks: [PullRequestCheck!]!
  commits: [PullRequestCommit!]!
  creator: User
}

type PullRequestCheck {
  name: String!
  workflowName: String
  status: String!
  url: String
  isRequired: Boolean
  startedAt: DateTime
  completedAt: DateTime
}

type PullRequestCommit {
  sha: String!
  message: String!
  committedAt: String!
  additions: Float!
  deletions: Float!
  changedFiles: Float
  authorUserIds: [String!]!
  authorExternalUserIds: [String!]!
}

enum PullRequestMergeMethod {
  MERGE
  REBASE
  SQUASH
}

type PullRequestMergeSettings {
  isMergeQueueEnabled: Boolean!
  squashMergeAllowed: Boolean!
  autoMergeAllowed: Boolean!
  rebaseMergeAllowed: Boolean!
  mergeCommitAllowed: Boolean!
  deleteBranchOnMerge: Boolean!
  mergeQueueMergeMethod: PullRequestMergeMethod
}

type PullRequestNotification implements Notification & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  pullRequestId: String!
  pullRequestCommentId: String
  pullRequest: PullRequest!
}

input PullRequestReferenceInput {
  repositoryOwner: String!
  repositoryName: String!
  number: Float!
}

enum PullRequestReviewTool {
  source
  graphite
}

enum PullRequestStatus {
  draft
  open
  inReview
  approved
  merged
  closed
}

type PushSubscription implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
}

input PushSubscriptionCreateInput {
  id: String
  data: String!
  type: PushSubscriptionType = web
}

type PushSubscriptionPayload {
  lastSyncId: Float!
  entity: PushSubscription!
  success: Boolean!
}

type PushSubscriptionTestPayload {
  success: Boolean!
}

enum PushSubscriptionType {
  web
  apple
  appleDevelopment
  firebase
}

type Query {
  workflowStates(filter: WorkflowStateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WorkflowStateConnection!
  workflowState(id: String!): WorkflowState!
  webhooks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WebhookConnection!
  webhook(id: String!): Webhook!
  failuresForOauthWebhooks(oauthClientId: String!): [WebhookFailureEvent!]!
  userSettings: UserSettings!
  users(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [UserSortInput!]): UserConnection!
  user(id: String!): User!
  viewer: User!
  userSessions(id: String!): [AuthenticationSessionResponse!]!
  triageResponsibilities(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TriageResponsibilityConnection!
  triageResponsibility(id: String!): TriageResponsibility!
  timeSchedules(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TimeScheduleConnection!
  timeSchedule(id: String!): TimeSchedule!
  templates: [Template!]!
  template(id: String!): Template!
  templatesForIntegration(integrationType: String!): [Template!]!
  projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [ProjectSortInput!]): ProjectConnection!
  project(id: String!): Project!
  projectFilterSuggestion(prompt: String!): ProjectFilterSuggestionPayload!
  teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
  administrableTeams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
  team(id: String!): Team!
  teamMemberships(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamMembershipConnection!
  teamMembership(id: String!): TeamMembership!
  semanticSearch(query: String!, types: [SemanticSearchResultType!], maxResults: Int, includeArchived: Boolean, filters: SemanticSearchFilters): SemanticSearchPayload!
  searchDocuments(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, term: String!, includeComments: Boolean, teamId: String): DocumentSearchPayload!
  searchProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, term: String!, includeComments: Boolean, teamId: String): ProjectSearchPayload!
  searchIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, term: String!, includeComments: Boolean, teamId: String): IssueSearchPayload!
  roadmapToProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): RoadmapToProjectConnection!
  roadmapToProject(id: String!): RoadmapToProject!
  roadmaps(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): RoadmapConnection!
  roadmap(id: String!): Roadmap!
  releaseStages(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ReleaseStageConnection!
  releaseStage(id: String!): ReleaseStage!
  releases(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ReleaseConnection!
  release(id: String!): Release!
  releasePipelines(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ReleasePipelineConnection!
  releasePipeline(id: String!): ReleasePipeline!
  releasePipelineByAccessKey: ReleasePipeline!
  latestReleaseByAccessKey: Release
  rateLimitStatus: RateLimitPayload!
  pushSubscriptionTest(targetMobile: Boolean = false, sendStrategy: SendStrategy = push): PushSubscriptionTestPayload!
  projectUpdates(filter: ProjectUpdateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectUpdateConnection!
  projectUpdate(id: String!): ProjectUpdate!
  projectStatuses(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectStatusConnection!
  projectStatusProjectCount(id: String!): ProjectStatusCountPayload!
  projectStatus(id: String!): ProjectStatus!
  projectRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectRelationConnection!
  projectRelation(id: String!): ProjectRelation!
  projectMilestones(filter: ProjectMilestoneFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectMilestoneConnection!
  projectMilestone(id: String!): ProjectMilestone!
  projectLabels(filter: ProjectLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectLabelConnection!
  projectLabel(id: String!): ProjectLabel!
  organization: Organization!
  organizationExists(urlKey: String!): OrganizationExistsPayload!
  archivedTeams: [Team!]!
  organizationMeta(urlKey: String!): OrganizationMeta
  organizationInvites(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): OrganizationInviteConnection!
  organizationInvite(id: String!): OrganizationInvite!
  organizationInviteDetails(id: String!): OrganizationInviteDetailsPayload!
  organizationDomainClaimRequest(id: String!): OrganizationDomainClaimPayload!
  notificationSubscriptions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): NotificationSubscriptionConnection!
  notificationSubscription(id: String!): NotificationSubscription!
  notifications(filter: NotificationFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): NotificationConnection!
  notificationsUnreadCount: Int!
  notification(id: String!): Notification!
  issueToReleases(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueToReleaseConnection!
  issueToRelease(id: String!): IssueToRelease!
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [IssueSortInput!]): IssueConnection!
  issue(id: String!): Issue!
  issueSearch(filter: IssueFilter, query: String, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  issueVcsBranchSearch(branchName: String!): Issue
  issueFigmaFileKeySearch(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, fileKey: String!): IssueConnection!
  issuePriorityValues: [IssuePriorityValue!]!
  issueFilterSuggestion(projectId: String, prompt: String!): IssueFilterSuggestionPayload!
  issueRepositorySuggestions(agentSessionId: String, candidateRepositories: [CandidateRepository!]!, issueId: String!): RepositorySuggestionsPayload!
  issueRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueRelationConnection!
  issueRelation(id: String!): IssueRelation!
  issueLabels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
  issueLabel(id: String!): IssueLabel!
  issueImportCheckCSV(csvUrl: String!, service: String!): IssueImportCheckPayload!
  issueImportCheckSync(issueImportId: String!): IssueImportSyncCheckPayload!
  issueImportJqlCheck(jiraHostname: String!, jiraToken: String!, jiraEmail: String!, jiraProject: String!, jql: String!): IssueImportJqlCheckPayload!
  integrationsSettings(id: String!): IntegrationsSettings!
  integrationTemplates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IntegrationTemplateConnection!
  integrationTemplate(id: String!): IntegrationTemplate!
  integrations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IntegrationConnection!
  integration(id: String!): Integration!
  verifyGitHubEnterpriseServerInstallation(integrationId: String!): GitHubEnterpriseServerInstallVerificationPayload!
  integrationHasScopes(scopes: [String!]!, integrationId: String!): IntegrationHasScopesPayload!
  initiativeUpdates(filter: InitiativeUpdateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeUpdateConnection!
  initiativeUpdate(id: String!): InitiativeUpdate!
  initiativeToProjects(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeToProjectConnection!
  initiativeToProject(id: String!): InitiativeToProject!
  initiatives(filter: InitiativeFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [InitiativeSortInput!]): InitiativeConnection!
  initiative(id: String!): Initiative!
  initiativeRelations(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): InitiativeRelationConnection!
  initiativeRelation(id: String!): ProjectRelation!
  fetchData(query: String!): FetchDataPayload!
  favorites(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): FavoriteConnection!
  favorite(id: String!): Favorite!
  externalUsers(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ExternalUserConnection!
  externalUser(id: String!): ExternalUser!
  entityExternalLink(id: String!): EntityExternalLink!
  emojis(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EmojiConnection!
  emoji(id: String!): Emoji!
  emailIntakeAddress(id: String!): EmailIntakeAddress!
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  document(id: String!): Document!
  documentContentHistory(id: String!): DocumentContentHistoryPayload!
  cycles(filter: CycleFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CycleConnection!
  cycle(id: String!): Cycle!
  customerTiers(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerTierConnection!
  customerTier(id: String!): CustomerTier!
  customerStatuses(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerStatusConnection!
  customerStatus(id: String!): CustomerStatus!
  customers(filter: CustomerFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sorts: [CustomerSortInput!]): CustomerConnection!
  customer(id: String!): Customer!
  customerNeeds(filter: CustomerNeedFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CustomerNeedConnection!
  customerNeed(id: String, hash: String): CustomerNeed!
  issueTitleSuggestionFromCustomerRequest(request: String!): IssueTitleSuggestionFromCustomerRequestPayload!
  customViews(filter: CustomViewFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [CustomViewSortInput!]): CustomViewConnection!
  customView(id: String!): CustomView!
  customViewDetailsSuggestion(modelName: String, filter: JSONObject!): CustomViewSuggestionPayload!
  customViewHasSubscribers(id: String!): CustomViewHasSubscribersPayload!
  comments(filter: CommentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CommentConnection!
  comment(id: String, hash: String): Comment!
  availableUsers: AuthResolverResponse!
  authenticationSessions: [AuthenticationSessionResponse!]!
  ssoUrlFromEmail(isDesktop: Boolean, type: IdentityProviderType! = general, email: String!): SsoUrlFromEmailResponse!
  auditEntryTypes: [AuditEntryType!]!
  auditEntries(filter: AuditEntryFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AuditEntryConnection!
  attachments(filter: AttachmentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AttachmentConnection!
  attachment(id: String!): Attachment!
  attachmentsForURL(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, url: String!): AttachmentConnection!
  attachmentIssue(id: String!): Issue!
  attachmentSources(teamId: String): AttachmentSourcesPayload!
  asksWebSetting(id: String!): AsksWebSettings!
  asksWebPage(id: String!): AsksWebPage!
  applicationInfo(clientId: String!): Application!
  agentSessions(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AgentSessionConnection!
  agentSession(id: String!): AgentSession!
  agentActivities(filter: AgentActivityFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): AgentActivityConnection!
  agentActivity(id: String!): AgentActivity!
}

type RateLimitPayload {
  identifier: String
  kind: String!
  limits: [RateLimitResultPayload!]!
}

type RateLimitResultPayload {
  type: String!
  requestedAmount: Float!
  allowedAmount: Float!
  period: Float!
  remainingAmount: Float!
  reset: Float!
}

type Reaction implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  emoji: String!
  issue: Issue
  comment: Comment
  projectUpdate: ProjectUpdate
  initiativeUpdate: InitiativeUpdate
  post: Post
  user: User
  externalUser: ExternalUser
}

input ReactionCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  emoji: StringComparator
  customEmojiId: IDComparator
  and: [ReactionCollectionFilter!]
  or: [ReactionCollectionFilter!]
  some: ReactionFilter
  every: ReactionFilter
  length: NumberComparator
}

input ReactionCreateInput {
  id: String
  emoji: String!
  commentId: String
  projectUpdateId: String
  initiativeUpdateId: String
  issueId: String
  postId: String
  pullRequestId: String
  pullRequestCommentId: String
}

input ReactionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  emoji: StringComparator
  customEmojiId: IDComparator
  and: [ReactionFilter!]
  or: [ReactionFilter!]
}

type ReactionPayload {
  lastSyncId: Float!
  reaction: Reaction!
  success: Boolean!
}

input RelationExistsComparator {
  eq: Boolean
  neq: Boolean
}

type Release implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  description: String
  version: String
  commitSha: String
  pipeline: ReleasePipeline!
  stage: ReleaseStage!
  slugId: String!
  startDate: TimelessDate
  targetDate: TimelessDate
  startedAt: DateTime
  completedAt: DateTime
  canceledAt: DateTime
  url: String!
  documents(filter: DocumentFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DocumentConnection!
  links(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): EntityExternalLinkConnection!
}

type ReleaseArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Release
}

enum ReleaseChannel {
  development
  internal
  privateBeta
  beta
  preRelease
  public
}

input ReleaseCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  pipeline: ReleasePipelineFilter
  stage: ReleaseStageFilter
  and: [ReleaseCollectionFilter!]
  or: [ReleaseCollectionFilter!]
  some: ReleaseFilter
  every: ReleaseFilter
  length: NumberComparator
}

input ReleaseCompleteInput {
  version: String
  commitSha: String
  pipelineId: String!
}

input ReleaseCompleteInputBase {
  version: String
  commitSha: String
}

type ReleaseConnection {
  edges: [ReleaseEdge!]!
  nodes: [Release!]!
  pageInfo: PageInfo!
}

input ReleaseCreateInput {
  id: String
  name: String!
  description: String
  version: String
  commitSha: String
  pipelineId: String!
  stageId: String
  startDate: TimelessDate
  targetDate: TimelessDate
}

input ReleaseDebugSinkInput {
  inspectedShas: [String!]!
  issues: JSONObject!
  pullRequests: [JSONObject!]!
  includePaths: [String!]
}

type ReleaseEdge {
  node: Release!
  cursor: String!
}

input ReleaseFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  pipeline: ReleasePipelineFilter
  stage: ReleaseStageFilter
  and: [ReleaseFilter!]
  or: [ReleaseFilter!]
}

type ReleasePayload {
  lastSyncId: Float!
  release: Release!
  success: Boolean!
}

type ReleasePipeline implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  slugId: String!
  type: ReleasePipelineType!
  includePathPatterns: [String!]!
  stages(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ReleaseStageConnection!
  releases(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ReleaseConnection!
}

type ReleasePipelineArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: ReleasePipeline
}

type ReleasePipelineConnection {
  edges: [ReleasePipelineEdge!]!
  nodes: [ReleasePipeline!]!
  pageInfo: PageInfo!
}

input ReleasePipelineCreateInput {
  id: String
  name: String!
  slugId: String
  type: ReleasePipelineType
  includePathPatterns: [String!]
}

type ReleasePipelineEdge {
  node: ReleasePipeline!
  cursor: String!
}

input ReleasePipelineFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  and: [ReleasePipelineFilter!]
  or: [ReleasePipelineFilter!]
}

type ReleasePipelinePayload {
  lastSyncId: Float!
  releasePipeline: ReleasePipeline!
  success: Boolean!
}

enum ReleasePipelineType {
  continuous
  scheduled
}

input ReleasePipelineUpdateInput {
  name: String
  slugId: String
  type: ReleasePipelineType
  includePathPatterns: [String!]
}

type ReleaseStage implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  color: String!
  type: ReleaseStageType!
  position: Float!
  pipeline: ReleasePipeline!
  releases(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ReleaseConnection!
}

type ReleaseStageArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: ReleaseStage
}

type ReleaseStageConnection {
  edges: [ReleaseStageEdge!]!
  nodes: [ReleaseStage!]!
  pageInfo: PageInfo!
}

input ReleaseStageCreateInput {
  id: String
  name: String!
  color: String!
  type: ReleaseStageType!
  position: Float!
  pipelineId: String!
}

type ReleaseStageEdge {
  node: ReleaseStage!
  cursor: String!
}

input ReleaseStageFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  type: ReleaseStageTypeComparator
  name: StringComparator
  and: [ReleaseStageFilter!]
  or: [ReleaseStageFilter!]
}

type ReleaseStagePayload {
  lastSyncId: Float!
  releaseStage: ReleaseStage!
  success: Boolean!
}

enum ReleaseStageType {
  planned
  started
  completed
  canceled
}

input ReleaseStageTypeComparator {
  eq: ReleaseStageType
  neq: ReleaseStageType
  in: [ReleaseStageType!]
  nin: [ReleaseStageType!]
  null: Boolean
}

input ReleaseStageUpdateInput {
  name: String
  color: String
  type: ReleaseStageType
  position: Float
}

input ReleaseSyncInput {
  id: String
  name: String
  description: String
  version: String
  commitSha: String!
  stageId: String
  issueReferences: [IssueReferenceInput!]
  pullRequestReferences: [PullRequestReferenceInput!]
  repository: RepositoryDataInput
  debugSink: ReleaseDebugSinkInput
  startDate: TimelessDate
  targetDate: TimelessDate
  pipelineId: String!
}

input ReleaseSyncInputBase {
  id: String
  name: String
  description: String
  version: String
  commitSha: String!
  stageId: String
  issueReferences: [IssueReferenceInput!]
  pullRequestReferences: [PullRequestReferenceInput!]
  repository: RepositoryDataInput
  debugSink: ReleaseDebugSinkInput
  startDate: TimelessDate
  targetDate: TimelessDate
}

input ReleaseUpdateByPipelineInput {
  version: String
  stage: String
  pipelineId: String!
}

input ReleaseUpdateByPipelineInputBase {
  version: String
  stage: String
}

input ReleaseUpdateInput {
  name: String
  description: String
  version: String
  commitSha: String
  pipelineId: String
  stageId: String
  startDate: TimelessDate
  targetDate: TimelessDate
}

input RepositoryDataInput {
  owner: String!
  name: String!
  provider: String!
  url: String!
}

type RepositorySuggestion {
  repositoryFullName: String!
  hostname: String
  confidence: Float!
}

type RepositorySuggestionsPayload {
  suggestions: [RepositorySuggestion!]!
}

input RevenueSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type Roadmap implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  description: String
  organization: Organization!
  creator: User!
  owner: User
  slugId: String!
  sortOrder: Float!
  color: String
  projects(filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): ProjectConnection!
  url: String!
}

type RoadmapArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Roadmap
}

input RoadmapCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  creator: UserFilter
  and: [RoadmapCollectionFilter!]
  or: [RoadmapCollectionFilter!]
  some: RoadmapFilter
  every: RoadmapFilter
  length: NumberComparator
}

type RoadmapConnection {
  edges: [RoadmapEdge!]!
  nodes: [Roadmap!]!
  pageInfo: PageInfo!
}

input RoadmapCreateInput {
  id: String
  name: String!
  description: String
  ownerId: String
  sortOrder: Float
  color: String
}

type RoadmapEdge {
  node: Roadmap!
  cursor: String!
}

input RoadmapFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  slugId: StringComparator
  creator: UserFilter
  and: [RoadmapFilter!]
  or: [RoadmapFilter!]
}

type RoadmapPayload {
  lastSyncId: Float!
  roadmap: Roadmap!
  success: Boolean!
}

type RoadmapToProject implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  project: Project!
  roadmap: Roadmap!
  sortOrder: String!
}

type RoadmapToProjectConnection {
  edges: [RoadmapToProjectEdge!]!
  nodes: [RoadmapToProject!]!
  pageInfo: PageInfo!
}

input RoadmapToProjectCreateInput {
  id: String
  projectId: String!
  roadmapId: String!
  sortOrder: Float
}

type RoadmapToProjectEdge {
  node: RoadmapToProject!
  cursor: String!
}

type RoadmapToProjectPayload {
  lastSyncId: Float!
  roadmapToProject: RoadmapToProject!
  success: Boolean!
}

input RoadmapToProjectUpdateInput {
  sortOrder: Float
}

input RoadmapUpdateInput {
  name: String
  description: String
  ownerId: String
  sortOrder: Float
  color: String
}

input RootIssueSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
  sort: IssueSortInput!
}

enum SLADayCountType {
  all
  onlyBusinessDays
}

input SalesforceMetadataIntegrationComparator {
  caseMetadata: JSONObject
}

input SalesforceSettingsInput {
  sendNoteOnStatusChange: Boolean
  sendNoteOnComment: Boolean
  automateTicketReopeningOnCompletion: Boolean
  automateTicketReopeningOnCancellation: Boolean
  automateTicketReopeningOnComment: Boolean
  disableCustomerRequestsAutoCreation: Boolean
  automateTicketReopeningOnProjectCompletion: Boolean
  automateTicketReopeningOnProjectCancellation: Boolean
  enableAiIntake: Boolean
  subdomain: String
  url: String
  reopenCaseStatus: String
  restrictVisibility: Boolean
  defaultTeam: String
}

input SemanticSearchFilters {
  issues: IssueFilter
  projects: ProjectFilter
  initiatives: InitiativeFilter
  documents: DocumentFilter
}

type SemanticSearchPayload {
  enabled: Boolean!
  results: [SemanticSearchResult!]!
}

type SemanticSearchResult implements Node {
  id: ID!
  type: SemanticSearchResultType!
  issue: Issue
  project: Project
  initiative: Initiative
  document: Document
}

enum SemanticSearchResultType {
  issue
  project
  initiative
  document
}

enum SendStrategy {
  desktopThenPush
  desktopAndPush
  desktop
  push
}

input SentrySettingsInput {
  organizationSlug: String!
  organizationId: ID!
  resolvingCompletesIssues: Boolean!
  unresolvingReopensIssues: Boolean!
}

type SesDomainIdentity implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  domain: String!
  region: String!
  organization: Organization!
  creator: User
  canSendFromCustomDomain: Boolean!
  dnsRecords: [SesDomainIdentityDnsRecord!]!
}

type SesDomainIdentityDnsRecord {
  type: String!
  name: String!
  content: String!
  isVerified: Boolean!
}

input SizeSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

enum SlaStatus {
  Breached
  HighRisk
  MediumRisk
  LowRisk
  Completed
  Failed
}

input SlaStatusComparator {
  eq: SlaStatus
  neq: SlaStatus
  in: [SlaStatus!]
  nin: [SlaStatus!]
  null: Boolean
}

input SlaStatusSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input SlackAsksSettingsInput {
  teamName: String
  teamId: String
  enterpriseName: String
  enterpriseId: String
  shouldUnfurl: Boolean
  shouldUseDefaultUnfurl: Boolean
  externalUserActions: Boolean
  slackChannelMapping: [SlackChannelNameMappingInput!]
  canAdministrate: UserRoleType!
  customerVisibility: CustomerVisibilityMode
  enableAgent: Boolean
  enableLinearAgentWorkflowAccess: Boolean
}

type SlackAsksTeamSettings {
  id: String!
  hasDefaultAsk: Boolean!
}

input SlackAsksTeamSettingsInput {
  id: String!
  hasDefaultAsk: Boolean!
}

type SlackChannelConnectPayload {
  lastSyncId: Float!
  integration: Integration
  success: Boolean!
  addBot: Boolean!
  nudgeToConnectMainSlackIntegration: Boolean
  nudgeToUpdateMainSlackIntegration: Boolean
}

type SlackChannelNameMapping {
  id: String!
  name: String!
  isPrivate: Boolean
  isShared: Boolean
  botAdded: Boolean
  teams: [SlackAsksTeamSettings!]!
  autoCreateOnMessage: Boolean
  autoCreateOnEmoji: Boolean
  autoCreateOnBotMention: Boolean
  autoCreateTemplateId: String
  postCancellationUpdates: Boolean
  postCompletionUpdates: Boolean
  postAcceptedFromTriageUpdates: Boolean
  aiTitles: Boolean
}

input SlackChannelNameMappingInput {
  id: String!
  name: String!
  isPrivate: Boolean
  isShared: Boolean
  botAdded: Boolean
  teams: [SlackAsksTeamSettingsInput!]!
  autoCreateOnMessage: Boolean
  autoCreateOnEmoji: Boolean
  autoCreateOnBotMention: Boolean
  autoCreateTemplateId: String
  postCancellationUpdates: Boolean
  postCompletionUpdates: Boolean
  postAcceptedFromTriageUpdates: Boolean
  aiTitles: Boolean
}

enum SlackChannelType {
  DirectMessage
  MultiPersonDirectMessage
  Private
  PrivateGroup
  Public
}

input SlackPostSettingsInput {
  channel: String!
  channelId: String!
  configurationUrl: String!
  teamId: String
  channelType: SlackChannelType
}

input SlackSettingsInput {
  teamName: String
  teamId: String
  enterpriseName: String
  enterpriseId: String
  shouldUnfurl: Boolean
  shouldUseDefaultUnfurl: Boolean
  externalUserActions: Boolean
  linkOnIssueIdMention: Boolean!
  enableAgent: Boolean
  enableLinearAgentWorkflowAccess: Boolean
}

input SourceMetadataComparator {
  eq: String
  neq: String
  in: [String!]
  nin: [String!]
  null: Boolean
  subType: SubTypeComparator
  salesforceMetadata: SalesforceMetadataIntegrationComparator
}

input SourceTypeComparator {
  eq: String
  neq: String
  in: [String!]
  nin: [String!]
  eqIgnoreCase: String
  neqIgnoreCase: String
  startsWith: String
  startsWithIgnoreCase: String
  notStartsWith: String
  endsWith: String
  notEndsWith: String
  contains: String
  containsIgnoreCase: String
  notContains: String
  notContainsIgnoreCase: String
  containsIgnoreCaseAndAccent: String
}

type SsoUrlFromEmailResponse {
  success: Boolean!
  samlSsoUrl: String!
}

input StartDateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

scalar String

input StringArrayComparator {
  length: NumberComparator
  every: StringItemComparator
  some: StringItemComparator
}

input StringComparator {
  eq: String
  neq: String
  in: [String!]
  nin: [String!]
  eqIgnoreCase: String
  neqIgnoreCase: String
  startsWith: String
  startsWithIgnoreCase: String
  notStartsWith: String
  endsWith: String
  notEndsWith: String
  contains: String
  containsIgnoreCase: String
  notContains: String
  notContainsIgnoreCase: String
  containsIgnoreCaseAndAccent: String
}

input StringItemComparator {
  eq: String
  neq: String
  in: [String!]
  nin: [String!]
  eqIgnoreCase: String
  neqIgnoreCase: String
  startsWith: String
  startsWithIgnoreCase: String
  notStartsWith: String
  endsWith: String
  notEndsWith: String
  contains: String
  containsIgnoreCase: String
  notContains: String
  notContainsIgnoreCase: String
  containsIgnoreCaseAndAccent: String
}

input SubTypeComparator {
  eq: String
  neq: String
  in: [String!]
  nin: [String!]
  null: Boolean
}

type SuccessPayload {
  lastSyncId: Float!
  success: Boolean!
}

type Summary implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  issue: Issue!
  content: JSONObject!
  evalLogId: String
  generationStatus: SummaryGenerationStatus!
  generatedAt: DateTime!
}

enum SummaryGenerationStatus {
  pending
  completed
  failed
}

type SyncedExternalThread {
  id: ID
  type: String!
  subType: String
  name: String
  displayName: String
  url: String
  isConnected: Boolean!
  isPersonalIntegrationConnected: Boolean!
  isPersonalIntegrationRequired: Boolean!
}

input TargetDateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type Team implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  key: String!
  description: String
  icon: String
  color: String
  retiredAt: DateTime
  organization: Organization!
  parent: Team
  children: [Team!]!
  cyclesEnabled: Boolean!
  cycleStartDay: Float!
  cycleDuration: Float!
  cycleCooldownTime: Float!
  cycleIssueAutoAssignStarted: Boolean!
  cycleIssueAutoAssignCompleted: Boolean!
  cycleLockToActive: Boolean!
  upcomingCycleCount: Float!
  timezone: String!
  inheritWorkflowStatuses: Boolean!
  inheritIssueEstimation: Boolean!
  issueEstimationType: String!
  issueOrderingNoPriorityFirst: Boolean!
  issueEstimationAllowZero: Boolean!
  setIssueSortOrderOnStateChange: String!
  issueEstimationExtended: Boolean!
  defaultIssueEstimate: Float!
  triageEnabled: Boolean!
  requirePriorityToLeaveTriage: Boolean!
  defaultIssueState: WorkflowState
  defaultTemplateForMembers: Template
  defaultTemplateForMembersId: String
  defaultTemplateForNonMembers: Template
  defaultTemplateForNonMembersId: String
  defaultProjectTemplate: Template
  triageIssueState: WorkflowState
  private: Boolean!
  allMembersCanJoin: Boolean
  securitySettings: JSONObject!
  facets: [Facet!]!
  posts: [Post!]!
  scimManaged: Boolean!
  scimGroupName: String
  progressHistory: JSONObject!
  currentProgress: JSONObject!
  draftWorkflowState: WorkflowState
  startWorkflowState: WorkflowState
  reviewWorkflowState: WorkflowState
  mergeableWorkflowState: WorkflowState
  mergeWorkflowState: WorkflowState
  groupIssueHistory: Boolean!
  aiThreadSummariesEnabled: Boolean!
  aiDiscussionSummariesEnabled: Boolean!
  slackNewIssue: Boolean!
  slackIssueComments: Boolean!
  slackIssueStatuses: Boolean!
  autoClosePeriod: Float
  autoCloseStateId: String
  autoArchivePeriod: Float!
  autoCloseParentIssues: Boolean
  autoCloseChildIssues: Boolean
  markedAsDuplicateWorkflowState: WorkflowState
  joinByDefault: Boolean
  cycleCalenderUrl: String!
  displayName: String!
  issues(includeSubTeams: Boolean = false, filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  issueCount(includeArchived: Boolean = false): Int!
  cycles(filter: CycleFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): CycleConnection!
  activeCycle: Cycle
  triageResponsibility: TriageResponsibility
  members(filter: UserFilter, includeDisabled: Boolean, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): UserConnection!
  membership(userId: String!): TeamMembership
  memberships(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamMembershipConnection!
  projects(includeSubTeams: Boolean = false, filter: ProjectFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy, sort: [ProjectSortInput!]): ProjectConnection!
  states(filter: WorkflowStateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WorkflowStateConnection!
  gitAutomationStates(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): GitAutomationStateConnection!
  templates(filter: NullableTemplateFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TemplateConnection!
  labels(filter: IssueLabelFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueLabelConnection!
  webhooks(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): WebhookConnection!
  integrationsSettings: IntegrationsSettings
  issueSortOrderDefaultToBottom: Boolean!
  inviteHash: String!
}

type TeamArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: Team
}

input TeamCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  and: [TeamCollectionFilter!]
  or: [TeamCollectionFilter!]
  some: TeamFilter
  every: TeamFilter
  length: NumberComparator
  parent: NullableTeamFilter
}

type TeamConnection {
  edges: [TeamEdge!]!
  nodes: [Team!]!
  pageInfo: PageInfo!
}

input TeamCreateInput {
  id: String
  name: String!
  description: String
  key: String
  icon: String
  color: String
  cyclesEnabled: Boolean
  cycleStartDay: Float
  cycleDuration: Int
  cycleCooldownTime: Int
  cycleIssueAutoAssignStarted: Boolean
  cycleIssueAutoAssignCompleted: Boolean
  cycleLockToActive: Boolean
  upcomingCycleCount: Float
  triageEnabled: Boolean
  requirePriorityToLeaveTriage: Boolean
  timezone: String
  inheritIssueEstimation: Boolean
  inheritWorkflowStatuses: Boolean
  issueEstimationType: String
  issueEstimationAllowZero: Boolean
  setIssueSortOrderOnStateChange: String
  issueEstimationExtended: Boolean
  defaultIssueEstimate: Float
  groupIssueHistory: Boolean
  defaultTemplateForMembersId: String
  defaultTemplateForNonMembersId: String
  defaultProjectTemplateId: String
  private: Boolean
  autoClosePeriod: Float
  autoCloseStateId: String
  autoArchivePeriod: Float
  markedAsDuplicateWorkflowStateId: String
  parentId: String
  inheritProductIntelligenceScope: Boolean
  productIntelligenceScope: ProductIntelligenceScope
}

type TeamEdge {
  node: Team!
  cursor: String!
}

input TeamFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  key: StringComparator
  description: NullableStringComparator
  private: BooleanComparator
  issues: IssueCollectionFilter
  parent: NullableTeamFilter
  and: [TeamFilter!]
  or: [TeamFilter!]
}

type TeamMembership implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  user: User!
  team: Team!
  owner: Boolean!
  sortOrder: Float!
}

type TeamMembershipConnection {
  edges: [TeamMembershipEdge!]!
  nodes: [TeamMembership!]!
  pageInfo: PageInfo!
}

input TeamMembershipCreateInput {
  id: String
  userId: String!
  teamId: String!
  owner: Boolean
  sortOrder: Float
}

type TeamMembershipEdge {
  node: TeamMembership!
  cursor: String!
}

type TeamMembershipPayload {
  lastSyncId: Float!
  teamMembership: TeamMembership
  success: Boolean!
}

input TeamMembershipUpdateInput {
  owner: Boolean
  sortOrder: Float
}

type TeamNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle
  label: IssueLabel
  project: Project
  initiative: Initiative
  team: Team!
  user: User
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

type TeamPayload {
  lastSyncId: Float!
  team: Team
  success: Boolean!
}

enum TeamRetirementSubTeamHandling {
  unnest
  retire
}

enum TeamRoleType {
  owner
  member
}

input TeamSecuritySettingsInput {
  labelManagement: TeamRoleType
  memberManagement: TeamRoleType
  teamManagement: TeamRoleType
  templateManagement: TeamRoleType
}

input TeamSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input TeamUpdateInput {
  name: String
  description: String
  key: String
  icon: String
  color: String
  cyclesEnabled: Boolean
  cycleStartDay: Float
  cycleDuration: Int
  cycleCooldownTime: Int
  cycleIssueAutoAssignStarted: Boolean
  cycleIssueAutoAssignCompleted: Boolean
  cycleLockToActive: Boolean
  cycleEnabledStartDate: DateTime
  upcomingCycleCount: Float
  timezone: String
  inheritIssueEstimation: Boolean
  issueEstimationType: String
  issueEstimationAllowZero: Boolean
  setIssueSortOrderOnStateChange: String
  issueEstimationExtended: Boolean
  defaultIssueEstimate: Float
  slackNewIssue: Boolean
  slackIssueComments: Boolean
  slackIssueStatuses: Boolean
  groupIssueHistory: Boolean
  aiThreadSummariesEnabled: Boolean
  aiDiscussionSummariesEnabled: Boolean
  defaultTemplateForMembersId: String
  defaultTemplateForNonMembersId: String
  defaultProjectTemplateId: String
  private: Boolean
  triageEnabled: Boolean
  requirePriorityToLeaveTriage: Boolean
  defaultIssueStateId: String
  autoClosePeriod: Float
  autoCloseStateId: String
  autoCloseParentIssues: Boolean
  autoCloseChildIssues: Boolean
  autoArchivePeriod: Float
  markedAsDuplicateWorkflowStateId: String
  joinByDefault: Boolean
  scimManaged: Boolean
  parentId: String
  inheritWorkflowStatuses: Boolean
  inheritProductIntelligenceScope: Boolean
  productIntelligenceScope: ProductIntelligenceScope
  securitySettings: TeamSecuritySettingsInput
  allMembersCanJoin: Boolean
  retiredAt: DateTime
  handleSubTeamsOnRetirement: TeamRetirementSubTeamHandling
}

type Template implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  name: String!
  description: String
  templateData: JSON!
  sortOrder: Float!
  lastAppliedAt: DateTime
  organization: Organization!
  team: Team
  creator: User
  lastUpdatedBy: User
  inheritedFrom: Template
  hasFormFields: Boolean!
}

type TemplateConnection {
  edges: [TemplateEdge!]!
  nodes: [Template!]!
  pageInfo: PageInfo!
}

input TemplateCreateInput {
  id: String
  type: String!
  teamId: String
  name: String!
  description: String
  templateData: JSON!
  sortOrder: Float
}

type TemplateEdge {
  node: Template!
  cursor: String!
}

type TemplatePayload {
  lastSyncId: Float!
  template: Template!
  success: Boolean!
}

input TemplateUpdateInput {
  name: String
  description: String
  teamId: String
  templateData: JSON
  sortOrder: Float
}

input TierSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input TimeInStatusSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type TimeSchedule implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  entries: [TimeScheduleEntry!]
  externalId: String
  externalUrl: String
  organization: Organization!
  integration: Integration
}

type TimeScheduleConnection {
  edges: [TimeScheduleEdge!]!
  nodes: [TimeSchedule!]!
  pageInfo: PageInfo!
}

input TimeScheduleCreateInput {
  id: String
  name: String!
  entries: [TimeScheduleEntryInput!]!
  externalId: String
  externalUrl: String
}

type TimeScheduleEdge {
  node: TimeSchedule!
  cursor: String!
}

type TimeScheduleEntry {
  startsAt: DateTime!
  endsAt: DateTime!
  userId: String
  userEmail: String
}

input TimeScheduleEntryInput {
  startsAt: DateTime!
  endsAt: DateTime!
  userId: String
  userEmail: String
}

type TimeSchedulePayload {
  lastSyncId: Float!
  timeSchedule: TimeSchedule!
  success: Boolean!
}

input TimeScheduleUpdateInput {
  name: String
  entries: [TimeScheduleEntryInput!]
  externalId: String
  externalUrl: String
}

scalar TimelessDate

scalar TimelessDateOrDuration

input TitleSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

input TokenUserAccountAuthInput {
  email: String!
  token: String!
  timezone: String!
  inviteLink: String
}

type TriageResponsibility implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  action: TriageResponsibilityAction!
  manualSelection: TriageResponsibilityManualSelection
  team: Team!
  timeSchedule: TimeSchedule
  currentUser: User
}

enum TriageResponsibilityAction {
  assign
  notify
}

type TriageResponsibilityConnection {
  edges: [TriageResponsibilityEdge!]!
  nodes: [TriageResponsibility!]!
  pageInfo: PageInfo!
}

input TriageResponsibilityCreateInput {
  id: String
  teamId: String!
  action: String!
  manualSelection: TriageResponsibilityManualSelectionInput
  timeScheduleId: String
}

type TriageResponsibilityEdge {
  node: TriageResponsibility!
  cursor: String!
}

type TriageResponsibilityManualSelection {
  userIds: [String!]!
  assignmentIndex: Int
}

input TriageResponsibilityManualSelectionInput {
  userIds: [String!]!
  assignmentIndex: Int
}

type TriageResponsibilityPayload {
  lastSyncId: Float!
  triageResponsibility: TriageResponsibility!
  success: Boolean!
}

input TriageResponsibilityUpdateInput {
  action: String
  manualSelection: TriageResponsibilityManualSelectionInput
  timeScheduleId: String
}

enum TriageRuleErrorType {
  cycle
  default
  labelGroupConflict
}

scalar UUID

input UpdatedAtSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type UploadFile {
  filename: String!
  contentType: String!
  size: Int!
  uploadUrl: String!
  assetUrl: String!
  metaData: JSONObject
  headers: [UploadFileHeader!]!
}

type UploadFileHeader {
  key: String!
  value: String!
}

type UploadPayload {
  lastSyncId: Float!
  uploadFile: UploadFile
  success: Boolean!
}

type User implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  displayName: String!
  email: String!
  avatarUrl: String
  disableReason: String
  calendarHash: String
  description: String
  statusEmoji: String
  statusLabel: String
  statusUntilAt: DateTime
  timezone: String
  organization: Organization!
  lastSeen: DateTime
  identityProvider: IdentityProvider
  initials: String!
  avatarBackgroundColor: String!
  guest: Boolean!
  app: Boolean!
  isMentionable: Boolean!
  isAssignable: Boolean!
  active: Boolean!
  issueDrafts(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueDraftConnection!
  drafts(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): DraftConnection!
  url: String!
  assignedIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  delegatedIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  createdIssues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
  createdIssueCount: Int!
  teams(filter: TeamFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamConnection!
  teamMemberships(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): TeamMembershipConnection!
  feedFacets(before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): FacetConnection!
  canAccessAnyPublicTeam: Boolean!
  isMe: Boolean!
  admin: Boolean!
  owner: Boolean!
  supportsAgentSessions: Boolean!
  inviteHash: String!
  gitHubUserId: String
}

type UserAdminPayload {
  success: Boolean!
}

input UserCollectionFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  displayName: StringComparator
  email: StringComparator
  active: BooleanComparator
  assignedIssues: IssueCollectionFilter
  admin: BooleanComparator
  owner: BooleanComparator
  invited: BooleanComparator
  isInvited: BooleanComparator
  app: BooleanComparator
  isMe: BooleanComparator
  and: [UserCollectionFilter!]
  or: [UserCollectionFilter!]
  some: UserFilter
  every: UserFilter
  length: NumberComparator
}

type UserConnection {
  edges: [UserEdge!]!
  nodes: [User!]!
  pageInfo: PageInfo!
}

enum UserContextViewType {
  assigned
}

input UserDisplayNameSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type UserEdge {
  node: User!
  cursor: String!
}

input UserFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  displayName: StringComparator
  email: StringComparator
  active: BooleanComparator
  assignedIssues: IssueCollectionFilter
  admin: BooleanComparator
  owner: BooleanComparator
  invited: BooleanComparator
  isInvited: BooleanComparator
  app: BooleanComparator
  isMe: BooleanComparator
  and: [UserFilter!]
  or: [UserFilter!]
}

enum UserFlagType {
  updatedSlackThreadSyncIntegration
  completedOnboarding
  desktopInstalled
  teamsPageIntroductionDismissed
  joinTeamIntroductionDismissed
  desktopDownloadToastDismissed
  emptyBacklogDismissed
  emptyCustomViewsDismissed
  emptyActiveIssuesDismissed
  emptyMyIssuesDismissed
  triageWelcomeDismissed
  cycleWelcomeDismissed
  projectWelcomeDismissed
  projectBacklogWelcomeDismissed
  projectUpdatesWelcomeDismissed
  pulseWelcomeDismissed
  analyticsWelcomeDismissed
  insightsWelcomeDismissed
  insightsHelpDismissed
  figmaPromptDismissed
  issueMovePromptCompleted
  migrateThemePreference
  listSelectionTip
  emptyParagraphSlashCommandTip
  editorSlashCommandUsed
  canPlaySnake
  canPlayTetris
  importBannerDismissed
  tryInvitePeopleDismissed
  tryRoadmapsDismissed
  tryCyclesDismissed
  tryTriageDismissed
  tryGithubDismissed
  rewindBannerDismissed
  helpIslandFeatureInsightsDismissed
  dueDateShortcutMigration
  slackCommentReactionTipShown
  issueLabelSuggestionUsed
  threadedCommentsNudgeIsSeen
  desktopTabsOnboardingDismissed
  milestoneOnboardingIsSeenAndDismissed
  projectBoardOnboardingIsSeenAndDismissed
  figmaPluginBannerDismissed
  initiativesBannerDismissed
  commandMenuClearShortcutTip
  slackBotWelcomeMessageShown
  slackAgentPromoFromCreateNewIssueShown
  all
}

enum UserFlagUpdateOperation {
  incr
  decr
  clear
  lock
}

input UserNameSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
}

type UserNotificationSubscription implements NotificationSubscription & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  subscriber: User!
  customer: Customer
  customView: CustomView
  cycle: Cycle
  label: IssueLabel
  project: Project
  initiative: Initiative
  team: Team
  user: User!
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
  active: Boolean!
  notificationSubscriptionTypes: [String!]!
}

type UserPayload {
  lastSyncId: Float!
  user: User
  success: Boolean!
}

enum UserRoleType {
  owner
  admin
  guest
  user
  app
}

type UserSettings implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  notificationDeliveryPreferences: NotificationDeliveryPreferences!
  unsubscribedFrom: [String!]!
  user: User!
  calendarHash: String
  subscribedToChangelog: Boolean!
  subscribedToDPA: Boolean!
  subscribedToInviteAccepted: Boolean!
  subscribedToPrivacyLegalUpdates: Boolean!
  feedSummarySchedule: FeedSummarySchedule
  showFullUserNames: Boolean!
  feedLastSeenTime: DateTime
  autoAssignToSelf: Boolean!
  notificationCategoryPreferences: NotificationCategoryPreferences!
  notificationChannelPreferences: NotificationChannelPreferences!
  theme(deviceType: UserSettingsThemeDeviceType = desktop, mode: UserSettingsThemeMode = light): UserSettingsTheme
}

type UserSettingsCustomSidebarTheme {
  accent: [Float!]!
  base: [Float!]!
  contrast: Int!
}

type UserSettingsCustomTheme {
  accent: [Float!]!
  base: [Float!]!
  contrast: Int!
  sidebar: UserSettingsCustomSidebarTheme
}

type UserSettingsFlagPayload {
  lastSyncId: Float!
  flag: String
  value: Int
  success: Boolean!
}

type UserSettingsFlagsResetPayload {
  lastSyncId: Float!
  success: Boolean!
}

type UserSettingsPayload {
  lastSyncId: Float!
  userSettings: UserSettings!
  success: Boolean!
}

type UserSettingsTheme {
  preset: UserSettingsThemePreset!
  custom: UserSettingsCustomTheme
}

enum UserSettingsThemeDeviceType {
  desktop
  mobileWeb
}

enum UserSettingsThemeMode {
  light
  dark
}

enum UserSettingsThemePreset {
  system
  light
  pureLight
  dark
  magicBlue
  classicDark
  custom
}

input UserSettingsUpdateInput {
  settings: JSONObject
  subscribedToChangelog: Boolean
  subscribedToDPA: Boolean
  subscribedToInviteAccepted: Boolean
  subscribedToPrivacyLegalUpdates: Boolean
  subscribedToGeneralMarketingCommunications: Boolean
  notificationCategoryPreferences: NotificationCategoryPreferencesInput
  notificationChannelPreferences: PartialNotificationChannelPreferencesInput
  notificationDeliveryPreferences: NotificationDeliveryPreferencesInput
  usageWarningHistory: JSONObject
  feedSummarySchedule: FeedSummarySchedule
  feedLastSeenTime: DateTime
}

input UserSortInput {
  name: UserNameSort
  displayName: UserDisplayNameSort
}

input UserUpdateInput {
  name: String
  displayName: String
  avatarUrl: String
  description: String
  statusEmoji: String
  statusLabel: String
  statusUntilAt: DateTime
  timezone: String
}

type ViewPreferences implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  viewType: String!
  preferences: ViewPreferencesValues!
}

input ViewPreferencesCreateInput {
  id: String
  type: ViewPreferencesType!
  viewType: ViewType!
  preferences: JSONObject!
  insights: JSONObject
  teamId: String
  projectId: String
  initiativeId: String
  labelId: String
  projectLabelId: String
  customViewId: String
  userId: String
}

type ViewPreferencesPayload {
  lastSyncId: Float!
  viewPreferences: ViewPreferences!
  success: Boolean!
}

enum ViewPreferencesType {
  organization
  user
}

input ViewPreferencesUpdateInput {
  preferences: JSONObject
  insights: JSONObject
}

type ViewPreferencesValues {
  viewOrdering: String
  issueGrouping: String
  issueSubGrouping: String
  showCompletedIssues: String
}

enum ViewType {
  inbox
  myIssues
  myIssuesCreatedByMe
  myIssuesSubscribedTo
  myIssuesActivity
  myIssuesSharedWithMe
  userProfile
  userProfileCreatedByUser
  board
  completedCycle
  cycle
  release
  project
  projectDocuments
  label
  triage
  activeIssues
  backlog
  subIssues
  allIssues
  dashboards
  customView
  customViews
  initiative
  initiativeOverview
  initiativeOverviewSubInitiatives
  initiatives
  initiativesPlanned
  initiativesCompleted
  projects
  projectsAll
  projectsBacklog
  projectsClosed
  projectLabel
  search
  splitSearch
  teams
  archive
  quickView
  issueIdentifiers
  customers
  customer
  embeddedCustomerNeeds
  projectCustomerNeeds
  reviews
  myReviews
  createdReviews
  agents
  feedAll
  feedCreated
  feedFollowing
  feedPopular
  workspaceMembers
  releasePipelines
  roadmapAll
  roadmap
  roadmaps
  roadmapClosed
  roadmapBacklog
}

type Webhook implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  label: String
  url: String
  enabled: Boolean!
  team: Team
  teamIds: [String!]
  allPublicTeams: Boolean!
  creator: User
  secret: String
  resourceTypes: [String!]!
  failures: [WebhookFailureEvent!]!
}

type WebhookConnection {
  edges: [WebhookEdge!]!
  nodes: [Webhook!]!
  pageInfo: PageInfo!
}

input WebhookCreateInput {
  label: String
  id: String
  enabled: Boolean = true
  secret: String
  url: String!
  resourceTypes: [String!]!
  teamId: String
  allPublicTeams: Boolean
}

type WebhookEdge {
  node: Webhook!
  cursor: String!
}

type WebhookFailureEvent {
  id: ID!
  createdAt: DateTime!
  webhook: Webhook!
  url: String!
  httpStatus: Float
  responseOrError: String
  executionId: String!
}

type WebhookPayload {
  lastSyncId: Float!
  webhook: Webhook!
  success: Boolean!
}

type WebhookRotateSecretPayload {
  lastSyncId: Float!
  success: Boolean!
  secret: String!
}

input WebhookUpdateInput {
  label: String
  secret: String
  enabled: Boolean
  url: String
  resourceTypes: [String!]
}

type WelcomeMessage implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  title: String
  enabled: Boolean!
  updatedBy: User
}

type WelcomeMessageNotification implements Notification & Entity & Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  type: String!
  actor: User
  externalUserActor: ExternalUser
  user: User!
  readAt: DateTime
  emailedAt: DateTime
  snoozedUntilAt: DateTime
  unsnoozedAt: DateTime
  category: NotificationCategory!
  url: String!
  inboxUrl: String!
  title: String!
  subtitle: String!
  isLinearActor: Boolean!
  actorAvatarUrl: String
  actorInitials: String
  actorAvatarColor: String!
  issueStatusType: String
  projectUpdateHealth: String
  initiativeUpdateHealth: String
  groupingKey: String!
  groupingPriority: Float!
  botActor: ActorBot
  welcomeMessageId: String!
}

type WorkflowDefinition implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  groupName: String
  description: String
  type: WorkflowType!
  trigger: WorkflowTrigger!
  triggerType: WorkflowTriggerType!
  conditions: JSONObject
  enabled: Boolean!
  team: Team
  creator: User!
  activities: JSONObject!
  sortOrder: String!
  lastExecutedAt: DateTime
  lastUpdatedBy: User
  label: IssueLabel
  cycle: Cycle
  user: User
  project: Project
  initiative: Initiative
  customView: CustomView
  contextViewType: ContextViewType
  userContextViewType: UserContextViewType
}

type WorkflowState implements Node {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  archivedAt: DateTime
  name: String!
  color: String!
  description: String
  position: Float!
  type: String!
  team: Team!
  inheritedFrom: WorkflowState
  issues(filter: IssueFilter, before: String, after: String, first: Int, last: Int, includeArchived: Boolean, orderBy: PaginationOrderBy): IssueConnection!
}

type WorkflowStateArchivePayload implements ArchivePayload {
  lastSyncId: Float!
  success: Boolean!
  entity: WorkflowState
}

type WorkflowStateConnection {
  edges: [WorkflowStateEdge!]!
  nodes: [WorkflowState!]!
  pageInfo: PageInfo!
}

input WorkflowStateCreateInput {
  id: String
  type: String!
  name: String!
  color: String!
  description: String
  position: Float
  teamId: String!
}

type WorkflowStateEdge {
  node: WorkflowState!
  cursor: String!
}

input WorkflowStateFilter {
  id: IDComparator
  createdAt: DateComparator
  updatedAt: DateComparator
  name: StringComparator
  description: StringComparator
  position: NumberComparator
  type: StringComparator
  team: TeamFilter
  issues: IssueCollectionFilter
  and: [WorkflowStateFilter!]
  or: [WorkflowStateFilter!]
}

type WorkflowStatePayload {
  lastSyncId: Float!
  workflowState: WorkflowState!
  success: Boolean!
}

input WorkflowStateSort {
  nulls: PaginationNulls = last
  order: PaginationSortOrder
  closedIssuesOrderedByRecency: Boolean = false
}

input WorkflowStateUpdateInput {
  name: String
  color: String
  description: String
  position: Float
}

enum WorkflowTrigger {
  entityCreated
  entityUpdated
  entityCreatedOrUpdated
  entityRemoved
  entityUnarchived
}

enum WorkflowTriggerType {
  issue
  project
}

enum WorkflowType {
  sla
  custom
  viewSubscription
  triage
}

input ZendeskSettingsInput {
  sendNoteOnStatusChange: Boolean
  sendNoteOnComment: Boolean
  automateTicketReopeningOnCompletion: Boolean
  automateTicketReopeningOnCancellation: Boolean
  automateTicketReopeningOnComment: Boolean
  disableCustomerRequestsAutoCreation: Boolean
  automateTicketReopeningOnProjectCompletion: Boolean
  automateTicketReopeningOnProjectCancellation: Boolean
  enableAiIntake: Boolean
  subdomain: String!
  url: String!
  botUserId: String
  canReadCustomers: Boolean
  supportsOAuthRefresh: Boolean
  hostMappings: [String!]
}
